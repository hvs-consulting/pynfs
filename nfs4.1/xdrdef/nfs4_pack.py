# Generated by rpcgen.py from /home/pentest/Documents/linux-pynfs/nfs4.1/./xdrdef/nfs4.x on Fri Feb 14 09:26:47 2025
import sys,os
from . import nfs4_const as const
from . import nfs4_type as types

try:
    import xdrlib3 as xdrlib
    from xdrlib3 import Error as XDRError
except:
    import xdrlib as xdrlib
    from xdrlib import Error as XDRError

class nullclass(object):
    pass

class NFS4Packer(xdrlib.Packer):
    def __init__(self, check_enum=True, check_array=True):
        xdrlib.Packer.__init__(self)
        self.check_enum = check_enum
        self.check_array = check_array

    pack_int = xdrlib.Packer.pack_int
    pack_uint = xdrlib.Packer.pack_uint
    pack_unsigned = xdrlib.Packer.pack_uint
    pack_hyper = xdrlib.Packer.pack_hyper
    pack_uhyper = xdrlib.Packer.pack_uhyper
    pack_float = xdrlib.Packer.pack_float
    pack_double = xdrlib.Packer.pack_double
    pack_quadruple = xdrlib.Packer.pack_double
    pack_bool = xdrlib.Packer.pack_bool
    pack_opaque = xdrlib.Packer.pack_opaque
    pack_string = xdrlib.Packer.pack_string
    def pack_authsys_parms(self, data):
        if hasattr(self, 'filter_authsys_parms'):
            data = getattr(self, 'filter_authsys_parms')(data)
        if data.stamp is None:
            raise TypeError('data.stamp == None')
        self.pack_uint(data.stamp)
        if data.machinename is None:
            raise TypeError('data.machinename == None')
        if len(data.machinename) > 255 and self.check_array:
            raise XDRError('array length too long for data.machinename')
        self.pack_string(data.machinename)
        if data.uid is None:
            raise TypeError('data.uid == None')
        self.pack_uint(data.uid)
        if data.gid is None:
            raise TypeError('data.gid == None')
        self.pack_uint(data.gid)
        if data.gids is None:
            raise TypeError('data.gids == None')
        if len(data.gids) > 16 and self.check_array:
            raise XDRError('array length too long for data.gids')
        self.pack_array(data.gids, self.pack_uint)

    pack_int32_t = pack_int

    pack_uint32_t = pack_uint

    pack_int64_t = pack_hyper

    pack_uint64_t = pack_uhyper

    def pack_nfs_ftype4(self, data):
        if hasattr(self, 'filter_nfs_ftype4'):
            data = getattr(self, 'filter_nfs_ftype4')(data)
        if self.check_enum and data not in [const.NF4REG, const.NF4DIR, const.NF4BLK, const.NF4CHR, const.NF4LNK, const.NF4SOCK, const.NF4FIFO, const.NF4ATTRDIR, const.NF4NAMEDATTR]:
            raise XDRError('value=%s not in enum nfs_ftype4' % data)
        self.pack_int(data)

    def pack_nfsstat4(self, data):
        if hasattr(self, 'filter_nfsstat4'):
            data = getattr(self, 'filter_nfsstat4')(data)
        if self.check_enum and data not in [const.NFS4_OK, const.NFS4ERR_PERM, const.NFS4ERR_NOENT, const.NFS4ERR_IO, const.NFS4ERR_NXIO, const.NFS4ERR_ACCESS, const.NFS4ERR_EXIST, const.NFS4ERR_XDEV, const.NFS4ERR_NOTDIR, const.NFS4ERR_ISDIR, const.NFS4ERR_INVAL, const.NFS4ERR_FBIG, const.NFS4ERR_NOSPC, const.NFS4ERR_ROFS, const.NFS4ERR_MLINK, const.NFS4ERR_NAMETOOLONG, const.NFS4ERR_NOTEMPTY, const.NFS4ERR_DQUOT, const.NFS4ERR_STALE, const.NFS4ERR_BADHANDLE, const.NFS4ERR_BAD_COOKIE, const.NFS4ERR_NOTSUPP, const.NFS4ERR_TOOSMALL, const.NFS4ERR_SERVERFAULT, const.NFS4ERR_BADTYPE, const.NFS4ERR_DELAY, const.NFS4ERR_SAME, const.NFS4ERR_DENIED, const.NFS4ERR_EXPIRED, const.NFS4ERR_LOCKED, const.NFS4ERR_GRACE, const.NFS4ERR_FHEXPIRED, const.NFS4ERR_SHARE_DENIED, const.NFS4ERR_WRONGSEC, const.NFS4ERR_CLID_INUSE, const.NFS4ERR_RESOURCE, const.NFS4ERR_MOVED, const.NFS4ERR_NOFILEHANDLE, const.NFS4ERR_MINOR_VERS_MISMATCH, const.NFS4ERR_STALE_CLIENTID, const.NFS4ERR_STALE_STATEID, const.NFS4ERR_OLD_STATEID, const.NFS4ERR_BAD_STATEID, const.NFS4ERR_BAD_SEQID, const.NFS4ERR_NOT_SAME, const.NFS4ERR_LOCK_RANGE, const.NFS4ERR_SYMLINK, const.NFS4ERR_RESTOREFH, const.NFS4ERR_LEASE_MOVED, const.NFS4ERR_ATTRNOTSUPP, const.NFS4ERR_NO_GRACE, const.NFS4ERR_RECLAIM_BAD, const.NFS4ERR_RECLAIM_CONFLICT, const.NFS4ERR_BADXDR, const.NFS4ERR_LOCKS_HELD, const.NFS4ERR_OPENMODE, const.NFS4ERR_BADOWNER, const.NFS4ERR_BADCHAR, const.NFS4ERR_BADNAME, const.NFS4ERR_BAD_RANGE, const.NFS4ERR_LOCK_NOTSUPP, const.NFS4ERR_OP_ILLEGAL, const.NFS4ERR_DEADLOCK, const.NFS4ERR_FILE_OPEN, const.NFS4ERR_ADMIN_REVOKED, const.NFS4ERR_CB_PATH_DOWN, const.NFS4ERR_BADIOMODE, const.NFS4ERR_BADLAYOUT, const.NFS4ERR_BAD_SESSION_DIGEST, const.NFS4ERR_BADSESSION, const.NFS4ERR_BADSLOT, const.NFS4ERR_COMPLETE_ALREADY, const.NFS4ERR_CONN_NOT_BOUND_TO_SESSION, const.NFS4ERR_DELEG_ALREADY_WANTED, const.NFS4ERR_BACK_CHAN_BUSY, const.NFS4ERR_LAYOUTTRYLATER, const.NFS4ERR_LAYOUTUNAVAILABLE, const.NFS4ERR_NOMATCHING_LAYOUT, const.NFS4ERR_RECALLCONFLICT, const.NFS4ERR_UNKNOWN_LAYOUTTYPE, const.NFS4ERR_SEQ_MISORDERED, const.NFS4ERR_SEQUENCE_POS, const.NFS4ERR_REQ_TOO_BIG, const.NFS4ERR_REP_TOO_BIG, const.NFS4ERR_REP_TOO_BIG_TO_CACHE, const.NFS4ERR_RETRY_UNCACHED_REP, const.NFS4ERR_UNSAFE_COMPOUND, const.NFS4ERR_TOO_MANY_OPS, const.NFS4ERR_OP_NOT_IN_SESSION, const.NFS4ERR_HASH_ALG_UNSUPP, const.NFS4ERR_CLIENTID_BUSY, const.NFS4ERR_PNFS_IO_HOLE, const.NFS4ERR_SEQ_FALSE_RETRY, const.NFS4ERR_BAD_HIGH_SLOT, const.NFS4ERR_DEADSESSION, const.NFS4ERR_ENCR_ALG_UNSUPP, const.NFS4ERR_PNFS_NO_LAYOUT, const.NFS4ERR_NOT_ONLY_OP, const.NFS4ERR_WRONG_CRED, const.NFS4ERR_WRONG_TYPE, const.NFS4ERR_DIRDELEG_UNAVAIL, const.NFS4ERR_REJECT_DELEG, const.NFS4ERR_RETURNCONFLICT, const.NFS4ERR_DELEG_REVOKED, const.NFS4ERR_PARTNER_NOTSUPP, const.NFS4ERR_PARTNER_NO_AUTH, const.NFS4ERR_UNION_NOTSUPP, const.NFS4ERR_OFFLOAD_DENIED, const.NFS4ERR_WRONG_LFS, const.NFS4ERR_BADLABEL, const.NFS4ERR_OFFLOAD_NO_REQS, const.NFS4ERR_NOXATTR, const.NFS4ERR_XATTR2BIG]:
            raise XDRError('value=%s not in enum nfsstat4' % data)
        self.pack_int(data)

    def pack_attrlist4(self, data):
        if hasattr(self, 'filter_attrlist4'):
            data = getattr(self, 'filter_attrlist4')(data)
        self.pack_opaque(data)

    def pack_bitmap4(self, data):
        if hasattr(self, 'filter_bitmap4'):
            data = getattr(self, 'filter_bitmap4')(data)
        self.pack_array(data, self.pack_uint32_t)

    pack_changeid4 = pack_uint64_t

    pack_clientid4 = pack_uint64_t

    pack_count4 = pack_uint32_t

    pack_length4 = pack_uint64_t

    pack_mode4 = pack_uint32_t

    pack_nfs_cookie4 = pack_uint64_t

    def pack_nfs_fh4(self, data):
        if hasattr(self, 'filter_nfs_fh4'):
            data = getattr(self, 'filter_nfs_fh4')(data)
        if len(data) > const.NFS4_FHSIZE and self.check_array:
            raise XDRError('array length too long for data')
        self.pack_opaque(data)

    pack_offset4 = pack_uint64_t

    pack_qop4 = pack_uint32_t

    def pack_sec_oid4(self, data):
        if hasattr(self, 'filter_sec_oid4'):
            data = getattr(self, 'filter_sec_oid4')(data)
        self.pack_opaque(data)

    pack_sequenceid4 = pack_uint32_t

    pack_seqid4 = pack_uint32_t

    def pack_sessionid4(self, data):
        if hasattr(self, 'filter_sessionid4'):
            data = getattr(self, 'filter_sessionid4')(data)
        self.pack_fopaque(const.NFS4_SESSIONID_SIZE, data)

    pack_slotid4 = pack_uint32_t

    def pack_utf8string(self, data):
        if hasattr(self, 'filter_utf8string'):
            data = getattr(self, 'filter_utf8string')(data)
        self.pack_opaque(data)

    pack_utf8str_cis = pack_utf8string

    pack_utf8str_cs = pack_utf8string

    pack_utf8str_mixed = pack_utf8string

    pack_component4 = pack_utf8str_cs

    def pack_linktext4(self, data):
        if hasattr(self, 'filter_linktext4'):
            data = getattr(self, 'filter_linktext4')(data)
        self.pack_opaque(data)

    pack_ascii_REQUIRED4 = pack_utf8string

    def pack_pathname4(self, data):
        if hasattr(self, 'filter_pathname4'):
            data = getattr(self, 'filter_pathname4')(data)
        self.pack_array(data, self.pack_component4)

    def pack_verifier4(self, data):
        if hasattr(self, 'filter_verifier4'):
            data = getattr(self, 'filter_verifier4')(data)
        self.pack_fopaque(const.NFS4_VERIFIER_SIZE, data)

    def pack_secret4(self, data):
        if hasattr(self, 'filter_secret4'):
            data = getattr(self, 'filter_secret4')(data)
        self.pack_string(data)

    pack_policy4 = pack_uint32_t

    def pack_nfstime4(self, data):
        if hasattr(self, 'filter_nfstime4'):
            data = getattr(self, 'filter_nfstime4')(data)
        if data.seconds is None:
            raise TypeError('data.seconds == None')
        self.pack_int64_t(data.seconds)
        if data.nseconds is None:
            raise TypeError('data.nseconds == None')
        self.pack_uint32_t(data.nseconds)

    def pack_time_how4(self, data):
        if hasattr(self, 'filter_time_how4'):
            data = getattr(self, 'filter_time_how4')(data)
        if self.check_enum and data not in [const.SET_TO_SERVER_TIME4, const.SET_TO_CLIENT_TIME4]:
            raise XDRError('value=%s not in enum time_how4' % data)
        self.pack_int(data)

    def pack_settime4(self, data):
        if hasattr(self, 'filter_settime4'):
            data = getattr(self, 'filter_settime4')(data)
        if data.set_it is None:
            raise TypeError('data.set_it == None')
        self.pack_time_how4(data.set_it)
        if data.set_it == const.SET_TO_CLIENT_TIME4:
            if data.time is None:
                raise TypeError('data.time == None')
            self.pack_nfstime4(data.time)
        else:
            pass

    pack_nfs_lease4 = pack_uint32_t

    def pack_fsid4(self, data):
        if hasattr(self, 'filter_fsid4'):
            data = getattr(self, 'filter_fsid4')(data)
        if data.major is None:
            raise TypeError('data.major == None')
        self.pack_uint64_t(data.major)
        if data.minor is None:
            raise TypeError('data.minor == None')
        self.pack_uint64_t(data.minor)

    def pack_change_policy4(self, data):
        if hasattr(self, 'filter_change_policy4'):
            data = getattr(self, 'filter_change_policy4')(data)
        if data.cp_major is None:
            raise TypeError('data.cp_major == None')
        self.pack_uint64_t(data.cp_major)
        if data.cp_minor is None:
            raise TypeError('data.cp_minor == None')
        self.pack_uint64_t(data.cp_minor)

    def pack_fs_location4(self, data):
        if hasattr(self, 'filter_fs_location4'):
            data = getattr(self, 'filter_fs_location4')(data)
        if data.server is None:
            raise TypeError('data.server == None')
        self.pack_array(data.server, self.pack_utf8str_cis)
        if data.rootpath is None:
            raise TypeError('data.rootpath == None')
        self.pack_pathname4(data.rootpath)

    def pack_fs_locations4(self, data):
        if hasattr(self, 'filter_fs_locations4'):
            data = getattr(self, 'filter_fs_locations4')(data)
        if data.fs_root is None:
            raise TypeError('data.fs_root == None')
        self.pack_pathname4(data.fs_root)
        if data.locations is None:
            raise TypeError('data.locations == None')
        self.pack_array(data.locations, self.pack_fs_location4)

    pack_acetype4 = pack_uint32_t

    pack_aceflag4 = pack_uint32_t

    pack_acemask4 = pack_uint32_t

    def pack_nfsace4(self, data):
        if hasattr(self, 'filter_nfsace4'):
            data = getattr(self, 'filter_nfsace4')(data)
        if data.type is None:
            raise TypeError('data.type == None')
        self.pack_acetype4(data.type)
        if data.flag is None:
            raise TypeError('data.flag == None')
        self.pack_aceflag4(data.flag)
        if data.access_mask is None:
            raise TypeError('data.access_mask == None')
        self.pack_acemask4(data.access_mask)
        if data.who is None:
            raise TypeError('data.who == None')
        self.pack_utf8str_mixed(data.who)

    pack_aclflag4 = pack_uint32_t

    def pack_nfsacl41(self, data):
        if hasattr(self, 'filter_nfsacl41'):
            data = getattr(self, 'filter_nfsacl41')(data)
        if data.na41_flag is None:
            raise TypeError('data.na41_flag == None')
        self.pack_aclflag4(data.na41_flag)
        if data.na41_aces is None:
            raise TypeError('data.na41_aces == None')
        self.pack_array(data.na41_aces, self.pack_nfsace4)

    def pack_mode_masked4(self, data):
        if hasattr(self, 'filter_mode_masked4'):
            data = getattr(self, 'filter_mode_masked4')(data)
        if data.mm_value_to_set is None:
            raise TypeError('data.mm_value_to_set == None')
        self.pack_mode4(data.mm_value_to_set)
        if data.mm_mask_bits is None:
            raise TypeError('data.mm_mask_bits == None')
        self.pack_mode4(data.mm_mask_bits)

    def pack_specdata4(self, data):
        if hasattr(self, 'filter_specdata4'):
            data = getattr(self, 'filter_specdata4')(data)
        if data.specdata1 is None:
            raise TypeError('data.specdata1 == None')
        self.pack_uint32_t(data.specdata1)
        if data.specdata2 is None:
            raise TypeError('data.specdata2 == None')
        self.pack_uint32_t(data.specdata2)

    def pack_netaddr4(self, data):
        if hasattr(self, 'filter_netaddr4'):
            data = getattr(self, 'filter_netaddr4')(data)
        if data.na_r_netid is None:
            raise TypeError('data.na_r_netid == None')
        self.pack_string(data.na_r_netid)
        if data.na_r_addr is None:
            raise TypeError('data.na_r_addr == None')
        self.pack_string(data.na_r_addr)

    def pack_nfs_impl_id4(self, data):
        if hasattr(self, 'filter_nfs_impl_id4'):
            data = getattr(self, 'filter_nfs_impl_id4')(data)
        if data.nii_domain is None:
            raise TypeError('data.nii_domain == None')
        self.pack_utf8str_cis(data.nii_domain)
        if data.nii_name is None:
            raise TypeError('data.nii_name == None')
        self.pack_utf8str_cs(data.nii_name)
        if data.nii_date is None:
            raise TypeError('data.nii_date == None')
        self.pack_nfstime4(data.nii_date)

    def pack_stateid4(self, data):
        if hasattr(self, 'filter_stateid4'):
            data = getattr(self, 'filter_stateid4')(data)
        if data.seqid is None:
            raise TypeError('data.seqid == None')
        self.pack_uint32_t(data.seqid)
        if data.other is None:
            raise TypeError('data.other == None')
        self.pack_fopaque(const.NFS4_OTHER_SIZE, data.other)

    def pack_layouttype4(self, data):
        if hasattr(self, 'filter_layouttype4'):
            data = getattr(self, 'filter_layouttype4')(data)
        if self.check_enum and data not in [const.LAYOUT4_NFSV4_1_FILES, const.LAYOUT4_OSD2_OBJECTS, const.LAYOUT4_BLOCK_VOLUME, const.LAYOUT4_FLEX_FILES]:
            raise XDRError('value=%s not in enum layouttype4' % data)
        self.pack_int(data)

    def pack_layout_content4(self, data):
        if hasattr(self, 'filter_layout_content4'):
            data = getattr(self, 'filter_layout_content4')(data)
        if data.loc_type is None:
            raise TypeError('data.loc_type == None')
        self.pack_layouttype4(data.loc_type)
        if data.loc_body is None:
            raise TypeError('data.loc_body == None')
        self.pack_opaque(data.loc_body)

    def pack_layouthint4(self, data):
        if hasattr(self, 'filter_layouthint4'):
            data = getattr(self, 'filter_layouthint4')(data)
        if data.loh_type is None:
            raise TypeError('data.loh_type == None')
        self.pack_layouttype4(data.loh_type)
        if data.loh_body is None:
            raise TypeError('data.loh_body == None')
        self.pack_opaque(data.loh_body)

    def pack_layoutiomode4(self, data):
        if hasattr(self, 'filter_layoutiomode4'):
            data = getattr(self, 'filter_layoutiomode4')(data)
        if self.check_enum and data not in [const.LAYOUTIOMODE4_READ, const.LAYOUTIOMODE4_RW, const.LAYOUTIOMODE4_ANY]:
            raise XDRError('value=%s not in enum layoutiomode4' % data)
        self.pack_int(data)

    def pack_layout4(self, data):
        if hasattr(self, 'filter_layout4'):
            data = getattr(self, 'filter_layout4')(data)
        if data.lo_offset is None:
            raise TypeError('data.lo_offset == None')
        self.pack_offset4(data.lo_offset)
        if data.lo_length is None:
            raise TypeError('data.lo_length == None')
        self.pack_length4(data.lo_length)
        if data.lo_iomode is None:
            raise TypeError('data.lo_iomode == None')
        self.pack_layoutiomode4(data.lo_iomode)
        if data.lo_content is None:
            raise TypeError('data.lo_content == None')
        self.pack_layout_content4(data.lo_content)

    def pack_deviceid4(self, data):
        if hasattr(self, 'filter_deviceid4'):
            data = getattr(self, 'filter_deviceid4')(data)
        self.pack_fopaque(const.NFS4_DEVICEID4_SIZE, data)

    def pack_device_addr4(self, data):
        if hasattr(self, 'filter_device_addr4'):
            data = getattr(self, 'filter_device_addr4')(data)
        if data.da_layout_type is None:
            raise TypeError('data.da_layout_type == None')
        self.pack_layouttype4(data.da_layout_type)
        if data.da_addr_body is None:
            raise TypeError('data.da_addr_body == None')
        self.pack_opaque(data.da_addr_body)

    def pack_layoutupdate4(self, data):
        if hasattr(self, 'filter_layoutupdate4'):
            data = getattr(self, 'filter_layoutupdate4')(data)
        if data.lou_type is None:
            raise TypeError('data.lou_type == None')
        self.pack_layouttype4(data.lou_type)
        if data.lou_body is None:
            raise TypeError('data.lou_body == None')
        self.pack_opaque(data.lou_body)

    def pack_layoutreturn_type4(self, data):
        if hasattr(self, 'filter_layoutreturn_type4'):
            data = getattr(self, 'filter_layoutreturn_type4')(data)
        if self.check_enum and data not in [const.LAYOUTRETURN4_FILE, const.LAYOUTRETURN4_FSID, const.LAYOUTRETURN4_ALL]:
            raise XDRError('value=%s not in enum layoutreturn_type4' % data)
        self.pack_int(data)

    def pack_layoutreturn_file4(self, data):
        if hasattr(self, 'filter_layoutreturn_file4'):
            data = getattr(self, 'filter_layoutreturn_file4')(data)
        if data.lrf_offset is None:
            raise TypeError('data.lrf_offset == None')
        self.pack_offset4(data.lrf_offset)
        if data.lrf_length is None:
            raise TypeError('data.lrf_length == None')
        self.pack_length4(data.lrf_length)
        if data.lrf_stateid is None:
            raise TypeError('data.lrf_stateid == None')
        self.pack_stateid4(data.lrf_stateid)
        if data.lrf_body is None:
            raise TypeError('data.lrf_body == None')
        self.pack_opaque(data.lrf_body)

    def pack_layoutreturn4(self, data):
        if hasattr(self, 'filter_layoutreturn4'):
            data = getattr(self, 'filter_layoutreturn4')(data)
        if data.lr_returntype is None:
            raise TypeError('data.lr_returntype == None')
        self.pack_layoutreturn_type4(data.lr_returntype)
        if data.lr_returntype == const.LAYOUTRETURN4_FILE:
            if data.lr_layout is None:
                raise TypeError('data.lr_layout == None')
            self.pack_layoutreturn_file4(data.lr_layout)
        else:
            pass

    def pack_fs4_status_type(self, data):
        if hasattr(self, 'filter_fs4_status_type'):
            data = getattr(self, 'filter_fs4_status_type')(data)
        if self.check_enum and data not in [const.STATUS4_FIXED, const.STATUS4_UPDATED, const.STATUS4_VERSIONED, const.STATUS4_WRITABLE, const.STATUS4_REFERRAL]:
            raise XDRError('value=%s not in enum fs4_status_type' % data)
        self.pack_int(data)

    def pack_fs4_status(self, data):
        if hasattr(self, 'filter_fs4_status'):
            data = getattr(self, 'filter_fs4_status')(data)
        if data.fss_absent is None:
            raise TypeError('data.fss_absent == None')
        self.pack_bool(data.fss_absent)
        if data.fss_type is None:
            raise TypeError('data.fss_type == None')
        self.pack_fs4_status_type(data.fss_type)
        if data.fss_source is None:
            raise TypeError('data.fss_source == None')
        self.pack_utf8str_cs(data.fss_source)
        if data.fss_current is None:
            raise TypeError('data.fss_current == None')
        self.pack_utf8str_cs(data.fss_current)
        if data.fss_age is None:
            raise TypeError('data.fss_age == None')
        self.pack_int32_t(data.fss_age)
        if data.fss_version is None:
            raise TypeError('data.fss_version == None')
        self.pack_nfstime4(data.fss_version)

    pack_threshold4_read_size = pack_length4

    pack_threshold4_write_size = pack_length4

    pack_threshold4_read_iosize = pack_length4

    pack_threshold4_write_iosize = pack_length4

    def pack_threshold_item4(self, data):
        if hasattr(self, 'filter_threshold_item4'):
            data = getattr(self, 'filter_threshold_item4')(data)
        if data.thi_layout_type is None:
            raise TypeError('data.thi_layout_type == None')
        self.pack_layouttype4(data.thi_layout_type)
        if data.thi_hintset is None:
            raise TypeError('data.thi_hintset == None')
        self.pack_bitmap4(data.thi_hintset)
        if data.thi_hintlist is None:
            raise TypeError('data.thi_hintlist == None')
        self.pack_opaque(data.thi_hintlist)

    def pack_mdsthreshold4(self, data):
        if hasattr(self, 'filter_mdsthreshold4'):
            data = getattr(self, 'filter_mdsthreshold4')(data)
        if data.mth_hints is None:
            raise TypeError('data.mth_hints == None')
        self.pack_array(data.mth_hints, self.pack_threshold_item4)

    def pack_retention_get4(self, data):
        if hasattr(self, 'filter_retention_get4'):
            data = getattr(self, 'filter_retention_get4')(data)
        if data.rg_duration is None:
            raise TypeError('data.rg_duration == None')
        self.pack_uint64_t(data.rg_duration)
        if data.rg_begin_time is None:
            raise TypeError('data.rg_begin_time == None')
        if len(data.rg_begin_time) > 1 and self.check_array:
            raise XDRError('array length too long for data.rg_begin_time')
        self.pack_array(data.rg_begin_time, self.pack_nfstime4)

    def pack_retention_set4(self, data):
        if hasattr(self, 'filter_retention_set4'):
            data = getattr(self, 'filter_retention_set4')(data)
        if data.rs_enable is None:
            raise TypeError('data.rs_enable == None')
        self.pack_bool(data.rs_enable)
        if data.rs_duration is None:
            raise TypeError('data.rs_duration == None')
        if len(data.rs_duration) > 1 and self.check_array:
            raise XDRError('array length too long for data.rs_duration')
        self.pack_array(data.rs_duration, self.pack_uint64_t)

    pack_fs_charset_cap4 = pack_uint32_t

    def pack_netloc_type4(self, data):
        if hasattr(self, 'filter_netloc_type4'):
            data = getattr(self, 'filter_netloc_type4')(data)
        if self.check_enum and data not in [const.NL4_NAME, const.NL4_URL, const.NL4_NETADDR]:
            raise XDRError('value=%s not in enum netloc_type4' % data)
        self.pack_int(data)

    def pack_netloc4(self, data):
        if hasattr(self, 'filter_netloc4'):
            data = getattr(self, 'filter_netloc4')(data)
        if data.nl_type is None:
            raise TypeError('data.nl_type == None')
        self.pack_netloc_type4(data.nl_type)
        if data.nl_type == const.NL4_NAME:
            if data.nl_name is None:
                raise TypeError('data.nl_name == None')
            self.pack_utf8str_cis(data.nl_name)
        elif data.nl_type == const.NL4_URL:
            if data.nl_url is None:
                raise TypeError('data.nl_url == None')
            self.pack_utf8str_cis(data.nl_url)
        elif data.nl_type == const.NL4_NETADDR:
            if data.nl_addr is None:
                raise TypeError('data.nl_addr == None')
            self.pack_netaddr4(data.nl_addr)
        else:
            raise XDRError('bad switch=%s' % data.nl_type)

    def pack_change_attr_type4(self, data):
        if hasattr(self, 'filter_change_attr_type4'):
            data = getattr(self, 'filter_change_attr_type4')(data)
        if self.check_enum and data not in [const.NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR, const.NFS4_CHANGE_TYPE_IS_VERSION_COUNTER, const.NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS, const.NFS4_CHANGE_TYPE_IS_TIME_METADATA, const.NFS4_CHANGE_TYPE_IS_UNDEFINED]:
            raise XDRError('value=%s not in enum change_attr_type4' % data)
        self.pack_int(data)

    def pack_labelformat_spec4(self, data):
        if hasattr(self, 'filter_labelformat_spec4'):
            data = getattr(self, 'filter_labelformat_spec4')(data)
        if data.lfs_lfs is None:
            raise TypeError('data.lfs_lfs == None')
        self.pack_policy4(data.lfs_lfs)
        if data.lfs_pi is None:
            raise TypeError('data.lfs_pi == None')
        self.pack_policy4(data.lfs_pi)

    def pack_sec_label4(self, data):
        if hasattr(self, 'filter_sec_label4'):
            data = getattr(self, 'filter_sec_label4')(data)
        if data.slai_lfs is None:
            raise TypeError('data.slai_lfs == None')
        self.pack_labelformat_spec4(data.slai_lfs)
        if data.slai_data is None:
            raise TypeError('data.slai_data == None')
        self.pack_opaque(data.slai_data)

    def pack_copy_from_auth_priv(self, data):
        if hasattr(self, 'filter_copy_from_auth_priv'):
            data = getattr(self, 'filter_copy_from_auth_priv')(data)
        if data.cfap_shared_secret is None:
            raise TypeError('data.cfap_shared_secret == None')
        self.pack_secret4(data.cfap_shared_secret)
        if data.cfap_destination is None:
            raise TypeError('data.cfap_destination == None')
        self.pack_netloc4(data.cfap_destination)
        if data.cfap_username is None:
            raise TypeError('data.cfap_username == None')
        self.pack_utf8str_mixed(data.cfap_username)

    def pack_copy_to_auth_priv(self, data):
        if hasattr(self, 'filter_copy_to_auth_priv'):
            data = getattr(self, 'filter_copy_to_auth_priv')(data)
        if data.ctap_shared_secret is None:
            raise TypeError('data.ctap_shared_secret == None')
        self.pack_secret4(data.ctap_shared_secret)
        if data.ctap_source is None:
            raise TypeError('data.ctap_source == None')
        self.pack_array(data.ctap_source, self.pack_netloc4)
        if data.ctap_username is None:
            raise TypeError('data.ctap_username == None')
        self.pack_utf8str_mixed(data.ctap_username)

    def pack_copy_confirm_auth_priv(self, data):
        if hasattr(self, 'filter_copy_confirm_auth_priv'):
            data = getattr(self, 'filter_copy_confirm_auth_priv')(data)
        if data.ccap_shared_secret_mic is None:
            raise TypeError('data.ccap_shared_secret_mic == None')
        self.pack_opaque(data.ccap_shared_secret_mic)
        if data.ccap_username is None:
            raise TypeError('data.ccap_username == None')
        self.pack_utf8str_mixed(data.ccap_username)

    def pack_app_data_block4(self, data):
        if hasattr(self, 'filter_app_data_block4'):
            data = getattr(self, 'filter_app_data_block4')(data)
        if data.adb_offset is None:
            raise TypeError('data.adb_offset == None')
        self.pack_offset4(data.adb_offset)
        if data.adb_block_size is None:
            raise TypeError('data.adb_block_size == None')
        self.pack_length4(data.adb_block_size)
        if data.adb_block_count is None:
            raise TypeError('data.adb_block_count == None')
        self.pack_length4(data.adb_block_count)
        if data.adb_reloff_blocknum is None:
            raise TypeError('data.adb_reloff_blocknum == None')
        self.pack_length4(data.adb_reloff_blocknum)
        if data.adb_block_num is None:
            raise TypeError('data.adb_block_num == None')
        self.pack_count4(data.adb_block_num)
        if data.adb_reloff_pattern is None:
            raise TypeError('data.adb_reloff_pattern == None')
        self.pack_length4(data.adb_reloff_pattern)
        if data.adb_pattern is None:
            raise TypeError('data.adb_pattern == None')
        self.pack_opaque(data.adb_pattern)

    def pack_data4(self, data):
        if hasattr(self, 'filter_data4'):
            data = getattr(self, 'filter_data4')(data)
        if data.d_offset is None:
            raise TypeError('data.d_offset == None')
        self.pack_offset4(data.d_offset)
        if data.d_data is None:
            raise TypeError('data.d_data == None')
        self.pack_opaque(data.d_data)

    def pack_data_info4(self, data):
        if hasattr(self, 'filter_data_info4'):
            data = getattr(self, 'filter_data_info4')(data)
        if data.di_offset is None:
            raise TypeError('data.di_offset == None')
        self.pack_offset4(data.di_offset)
        if data.di_length is None:
            raise TypeError('data.di_length == None')
        self.pack_length4(data.di_length)

    def pack_data_content4(self, data):
        if hasattr(self, 'filter_data_content4'):
            data = getattr(self, 'filter_data_content4')(data)
        if self.check_enum and data not in [const.NFS4_CONTENT_DATA, const.NFS4_CONTENT_HOLE]:
            raise XDRError('value=%s not in enum data_content4' % data)
        self.pack_int(data)

    def pack_stable_how4(self, data):
        if hasattr(self, 'filter_stable_how4'):
            data = getattr(self, 'filter_stable_how4')(data)
        if self.check_enum and data not in [const.UNSTABLE4, const.DATA_SYNC4, const.FILE_SYNC4]:
            raise XDRError('value=%s not in enum stable_how4' % data)
        self.pack_int(data)

    def pack_write_response4(self, data):
        if hasattr(self, 'filter_write_response4'):
            data = getattr(self, 'filter_write_response4')(data)
        if data.wr_callback_id is None:
            raise TypeError('data.wr_callback_id == None')
        if len(data.wr_callback_id) > 1 and self.check_array:
            raise XDRError('array length too long for data.wr_callback_id')
        self.pack_array(data.wr_callback_id, self.pack_stateid4)
        if data.wr_count is None:
            raise TypeError('data.wr_count == None')
        self.pack_length4(data.wr_count)
        if data.wr_committed is None:
            raise TypeError('data.wr_committed == None')
        self.pack_stable_how4(data.wr_committed)
        if data.wr_writeverf is None:
            raise TypeError('data.wr_writeverf == None')
        self.pack_verifier4(data.wr_writeverf)

    pack_xattrkey4 = pack_component4

    def pack_xattrvalue4(self, data):
        if hasattr(self, 'filter_xattrvalue4'):
            data = getattr(self, 'filter_xattrvalue4')(data)
        self.pack_opaque(data)

    pack_fattr4_supported_attrs = pack_bitmap4

    pack_fattr4_type = pack_nfs_ftype4

    pack_fattr4_fh_expire_type = pack_uint32_t

    pack_fattr4_change = pack_changeid4

    pack_fattr4_size = pack_uint64_t

    pack_fattr4_link_support = pack_bool

    pack_fattr4_symlink_support = pack_bool

    pack_fattr4_named_attr = pack_bool

    pack_fattr4_fsid = pack_fsid4

    pack_fattr4_unique_handles = pack_bool

    pack_fattr4_lease_time = pack_nfs_lease4

    pack_fattr4_rdattr_error = pack_nfsstat4

    def pack_fattr4_acl(self, data):
        if hasattr(self, 'filter_fattr4_acl'):
            data = getattr(self, 'filter_fattr4_acl')(data)
        self.pack_array(data, self.pack_nfsace4)

    pack_fattr4_aclsupport = pack_uint32_t

    pack_fattr4_archive = pack_bool

    pack_fattr4_cansettime = pack_bool

    pack_fattr4_case_insensitive = pack_bool

    pack_fattr4_case_preserving = pack_bool

    pack_fattr4_chown_restricted = pack_bool

    pack_fattr4_fileid = pack_uint64_t

    pack_fattr4_files_avail = pack_uint64_t

    pack_fattr4_filehandle = pack_nfs_fh4

    pack_fattr4_files_free = pack_uint64_t

    pack_fattr4_files_total = pack_uint64_t

    pack_fattr4_fs_locations = pack_fs_locations4

    pack_fattr4_hidden = pack_bool

    pack_fattr4_homogeneous = pack_bool

    pack_fattr4_maxfilesize = pack_uint64_t

    pack_fattr4_maxlink = pack_uint32_t

    pack_fattr4_maxname = pack_uint32_t

    pack_fattr4_maxread = pack_uint64_t

    pack_fattr4_maxwrite = pack_uint64_t

    pack_fattr4_mimetype = pack_ascii_REQUIRED4

    pack_fattr4_mode = pack_mode4

    pack_fattr4_mode_set_masked = pack_mode_masked4

    pack_fattr4_mounted_on_fileid = pack_uint64_t

    pack_fattr4_no_trunc = pack_bool

    pack_fattr4_numlinks = pack_uint32_t

    pack_fattr4_owner = pack_utf8str_mixed

    pack_fattr4_owner_group = pack_utf8str_mixed

    pack_fattr4_quota_avail_hard = pack_uint64_t

    pack_fattr4_quota_avail_soft = pack_uint64_t

    pack_fattr4_quota_used = pack_uint64_t

    pack_fattr4_rawdev = pack_specdata4

    pack_fattr4_space_avail = pack_uint64_t

    pack_fattr4_space_free = pack_uint64_t

    pack_fattr4_space_total = pack_uint64_t

    pack_fattr4_space_used = pack_uint64_t

    pack_fattr4_system = pack_bool

    pack_fattr4_time_access = pack_nfstime4

    pack_fattr4_time_access_set = pack_settime4

    pack_fattr4_time_backup = pack_nfstime4

    pack_fattr4_time_create = pack_nfstime4

    pack_fattr4_time_delta = pack_nfstime4

    pack_fattr4_time_metadata = pack_nfstime4

    pack_fattr4_time_modify = pack_nfstime4

    pack_fattr4_time_modify_set = pack_settime4

    pack_fattr4_suppattr_exclcreat = pack_bitmap4

    pack_fattr4_dir_notif_delay = pack_nfstime4

    pack_fattr4_dirent_notif_delay = pack_nfstime4

    def pack_fattr4_fs_layout_types(self, data):
        if hasattr(self, 'filter_fattr4_fs_layout_types'):
            data = getattr(self, 'filter_fattr4_fs_layout_types')(data)
        self.pack_array(data, self.pack_layouttype4)

    pack_fattr4_fs_status = pack_fs4_status

    pack_fattr4_fs_charset_cap = pack_fs_charset_cap4

    pack_fattr4_layout_alignment = pack_uint32_t

    pack_fattr4_layout_blksize = pack_uint32_t

    pack_fattr4_layout_hint = pack_layouthint4

    def pack_fattr4_layout_types(self, data):
        if hasattr(self, 'filter_fattr4_layout_types'):
            data = getattr(self, 'filter_fattr4_layout_types')(data)
        self.pack_array(data, self.pack_layouttype4)

    pack_fattr4_mdsthreshold = pack_mdsthreshold4

    pack_fattr4_retention_get = pack_retention_get4

    pack_fattr4_retention_set = pack_retention_set4

    pack_fattr4_retentevt_get = pack_retention_get4

    pack_fattr4_retentevt_set = pack_retention_set4

    pack_fattr4_retention_hold = pack_uint64_t

    pack_fattr4_dacl = pack_nfsacl41

    pack_fattr4_sacl = pack_nfsacl41

    pack_fattr4_change_policy = pack_change_policy4

    pack_fattr4_space_freed = pack_uint64_t

    pack_fattr4_change_attr_type = pack_change_attr_type4

    pack_fattr4_sec_label = pack_sec_label4

    pack_fattr4_clone_blksize = pack_uint32_t

    pack_fattr4_xattr_support = pack_bool

    def pack_fattr4(self, data):
        if hasattr(self, 'filter_fattr4'):
            data = getattr(self, 'filter_fattr4')(data)
        if data.attrmask is None:
            raise TypeError('data.attrmask == None')
        self.pack_bitmap4(data.attrmask)
        if data.attr_vals is None:
            raise TypeError('data.attr_vals == None')
        self.pack_attrlist4(data.attr_vals)

    def pack_change_info4(self, data):
        if hasattr(self, 'filter_change_info4'):
            data = getattr(self, 'filter_change_info4')(data)
        if data.atomic is None:
            raise TypeError('data.atomic == None')
        self.pack_bool(data.atomic)
        if data.before is None:
            raise TypeError('data.before == None')
        self.pack_changeid4(data.before)
        if data.after is None:
            raise TypeError('data.after == None')
        self.pack_changeid4(data.after)

    pack_clientaddr4 = pack_netaddr4

    def pack_cb_client4(self, data):
        if hasattr(self, 'filter_cb_client4'):
            data = getattr(self, 'filter_cb_client4')(data)
        if data.cb_program is None:
            raise TypeError('data.cb_program == None')
        self.pack_uint32_t(data.cb_program)
        if data.cb_location is None:
            raise TypeError('data.cb_location == None')
        self.pack_netaddr4(data.cb_location)

    def pack_nfs_client_id4(self, data):
        if hasattr(self, 'filter_nfs_client_id4'):
            data = getattr(self, 'filter_nfs_client_id4')(data)
        if data.verifier is None:
            raise TypeError('data.verifier == None')
        self.pack_verifier4(data.verifier)
        if data.id is None:
            raise TypeError('data.id == None')
        if len(data.id) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.id')
        self.pack_opaque(data.id)

    def pack_client_owner4(self, data):
        if hasattr(self, 'filter_client_owner4'):
            data = getattr(self, 'filter_client_owner4')(data)
        if data.co_verifier is None:
            raise TypeError('data.co_verifier == None')
        self.pack_verifier4(data.co_verifier)
        if data.co_ownerid is None:
            raise TypeError('data.co_ownerid == None')
        if len(data.co_ownerid) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.co_ownerid')
        self.pack_opaque(data.co_ownerid)

    def pack_server_owner4(self, data):
        if hasattr(self, 'filter_server_owner4'):
            data = getattr(self, 'filter_server_owner4')(data)
        if data.so_minor_id is None:
            raise TypeError('data.so_minor_id == None')
        self.pack_uint64_t(data.so_minor_id)
        if data.so_major_id is None:
            raise TypeError('data.so_major_id == None')
        if len(data.so_major_id) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.so_major_id')
        self.pack_opaque(data.so_major_id)

    def pack_state_owner4(self, data):
        if hasattr(self, 'filter_state_owner4'):
            data = getattr(self, 'filter_state_owner4')(data)
        if data.clientid is None:
            raise TypeError('data.clientid == None')
        self.pack_clientid4(data.clientid)
        if data.owner is None:
            raise TypeError('data.owner == None')
        if len(data.owner) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.owner')
        self.pack_opaque(data.owner)

    pack_open_owner4 = pack_state_owner4

    pack_lock_owner4 = pack_state_owner4

    def pack_nfs_lock_type4(self, data):
        if hasattr(self, 'filter_nfs_lock_type4'):
            data = getattr(self, 'filter_nfs_lock_type4')(data)
        if self.check_enum and data not in [const.READ_LT, const.WRITE_LT, const.READW_LT, const.WRITEW_LT]:
            raise XDRError('value=%s not in enum nfs_lock_type4' % data)
        self.pack_int(data)

    def pack_ssv_subkey4(self, data):
        if hasattr(self, 'filter_ssv_subkey4'):
            data = getattr(self, 'filter_ssv_subkey4')(data)
        if self.check_enum and data not in [const.SSV4_SUBKEY_MIC_I2T, const.SSV4_SUBKEY_MIC_T2I, const.SSV4_SUBKEY_SEAL_I2T, const.SSV4_SUBKEY_SEAL_T2I]:
            raise XDRError('value=%s not in enum ssv_subkey4' % data)
        self.pack_int(data)

    def pack_ssv_mic_plain_tkn4(self, data):
        if hasattr(self, 'filter_ssv_mic_plain_tkn4'):
            data = getattr(self, 'filter_ssv_mic_plain_tkn4')(data)
        if data.smpt_ssv_seq is None:
            raise TypeError('data.smpt_ssv_seq == None')
        self.pack_uint32_t(data.smpt_ssv_seq)
        if data.smpt_orig_plain is None:
            raise TypeError('data.smpt_orig_plain == None')
        self.pack_opaque(data.smpt_orig_plain)

    def pack_ssv_mic_tkn4(self, data):
        if hasattr(self, 'filter_ssv_mic_tkn4'):
            data = getattr(self, 'filter_ssv_mic_tkn4')(data)
        if data.smt_ssv_seq is None:
            raise TypeError('data.smt_ssv_seq == None')
        self.pack_uint32_t(data.smt_ssv_seq)
        if data.smt_hmac is None:
            raise TypeError('data.smt_hmac == None')
        self.pack_opaque(data.smt_hmac)

    def pack_ssv_seal_plain_tkn4(self, data):
        if hasattr(self, 'filter_ssv_seal_plain_tkn4'):
            data = getattr(self, 'filter_ssv_seal_plain_tkn4')(data)
        if data.sspt_confounder is None:
            raise TypeError('data.sspt_confounder == None')
        self.pack_opaque(data.sspt_confounder)
        if data.sspt_ssv_seq is None:
            raise TypeError('data.sspt_ssv_seq == None')
        self.pack_uint32_t(data.sspt_ssv_seq)
        if data.sspt_orig_plain is None:
            raise TypeError('data.sspt_orig_plain == None')
        self.pack_opaque(data.sspt_orig_plain)
        if data.sspt_pad is None:
            raise TypeError('data.sspt_pad == None')
        self.pack_opaque(data.sspt_pad)

    def pack_ssv_seal_cipher_tkn4(self, data):
        if hasattr(self, 'filter_ssv_seal_cipher_tkn4'):
            data = getattr(self, 'filter_ssv_seal_cipher_tkn4')(data)
        if data.ssct_ssv_seq is None:
            raise TypeError('data.ssct_ssv_seq == None')
        self.pack_uint32_t(data.ssct_ssv_seq)
        if data.ssct_iv is None:
            raise TypeError('data.ssct_iv == None')
        self.pack_opaque(data.ssct_iv)
        if data.ssct_encr_data is None:
            raise TypeError('data.ssct_encr_data == None')
        self.pack_opaque(data.ssct_encr_data)
        if data.ssct_hmac is None:
            raise TypeError('data.ssct_hmac == None')
        self.pack_opaque(data.ssct_hmac)

    def pack_fs_locations_server4(self, data):
        if hasattr(self, 'filter_fs_locations_server4'):
            data = getattr(self, 'filter_fs_locations_server4')(data)
        if data.fls_currency is None:
            raise TypeError('data.fls_currency == None')
        self.pack_int32_t(data.fls_currency)
        if data.fls_info is None:
            raise TypeError('data.fls_info == None')
        self.pack_opaque(data.fls_info)
        if data.fls_server is None:
            raise TypeError('data.fls_server == None')
        self.pack_utf8str_cis(data.fls_server)

    def pack_fs_locations_item4(self, data):
        if hasattr(self, 'filter_fs_locations_item4'):
            data = getattr(self, 'filter_fs_locations_item4')(data)
        if data.fli_entries is None:
            raise TypeError('data.fli_entries == None')
        self.pack_array(data.fli_entries, self.pack_fs_locations_server4)
        if data.fli_rootpath is None:
            raise TypeError('data.fli_rootpath == None')
        self.pack_pathname4(data.fli_rootpath)

    def pack_fs_locations_info4(self, data):
        if hasattr(self, 'filter_fs_locations_info4'):
            data = getattr(self, 'filter_fs_locations_info4')(data)
        if data.fli_flags is None:
            raise TypeError('data.fli_flags == None')
        self.pack_uint32_t(data.fli_flags)
        if data.fli_valid_for is None:
            raise TypeError('data.fli_valid_for == None')
        self.pack_int32_t(data.fli_valid_for)
        if data.fli_fs_root is None:
            raise TypeError('data.fli_fs_root == None')
        self.pack_pathname4(data.fli_fs_root)
        if data.fli_items is None:
            raise TypeError('data.fli_items == None')
        self.pack_array(data.fli_items, self.pack_fs_locations_item4)

    pack_fattr4_fs_locations_info = pack_fs_locations_info4

    pack_nfl_util4 = pack_uint32_t

    def pack_filelayout_hint_care4(self, data):
        if hasattr(self, 'filter_filelayout_hint_care4'):
            data = getattr(self, 'filter_filelayout_hint_care4')(data)
        if self.check_enum and data not in [const.NFLH4_CARE_DENSE, const.NFLH4_CARE_COMMIT_THRU_MDS, const.NFL42_CARE_IO_ADVISE_THRU_MDS, const.NFLH4_CARE_STRIPE_UNIT_SIZE, const.NFLH4_CARE_STRIPE_COUNT]:
            raise XDRError('value=%s not in enum filelayout_hint_care4' % data)
        self.pack_int(data)

    def pack_nfsv4_1_file_layouthint4(self, data):
        if hasattr(self, 'filter_nfsv4_1_file_layouthint4'):
            data = getattr(self, 'filter_nfsv4_1_file_layouthint4')(data)
        if data.nflh_care is None:
            raise TypeError('data.nflh_care == None')
        self.pack_uint32_t(data.nflh_care)
        if data.nflh_util is None:
            raise TypeError('data.nflh_util == None')
        self.pack_nfl_util4(data.nflh_util)
        if data.nflh_stripe_count is None:
            raise TypeError('data.nflh_stripe_count == None')
        self.pack_count4(data.nflh_stripe_count)

    def pack_multipath_list4(self, data):
        if hasattr(self, 'filter_multipath_list4'):
            data = getattr(self, 'filter_multipath_list4')(data)
        self.pack_array(data, self.pack_netaddr4)

    def pack_nfsv4_1_file_layout_ds_addr4(self, data):
        if hasattr(self, 'filter_nfsv4_1_file_layout_ds_addr4'):
            data = getattr(self, 'filter_nfsv4_1_file_layout_ds_addr4')(data)
        if data.nflda_stripe_indices is None:
            raise TypeError('data.nflda_stripe_indices == None')
        self.pack_array(data.nflda_stripe_indices, self.pack_uint32_t)
        if data.nflda_multipath_ds_list is None:
            raise TypeError('data.nflda_multipath_ds_list == None')
        self.pack_array(data.nflda_multipath_ds_list, self.pack_multipath_list4)

    def pack_nfsv4_1_file_layout4(self, data):
        if hasattr(self, 'filter_nfsv4_1_file_layout4'):
            data = getattr(self, 'filter_nfsv4_1_file_layout4')(data)
        if data.nfl_deviceid is None:
            raise TypeError('data.nfl_deviceid == None')
        self.pack_deviceid4(data.nfl_deviceid)
        if data.nfl_util is None:
            raise TypeError('data.nfl_util == None')
        self.pack_nfl_util4(data.nfl_util)
        if data.nfl_first_stripe_index is None:
            raise TypeError('data.nfl_first_stripe_index == None')
        self.pack_uint32_t(data.nfl_first_stripe_index)
        if data.nfl_pattern_offset is None:
            raise TypeError('data.nfl_pattern_offset == None')
        self.pack_offset4(data.nfl_pattern_offset)
        if data.nfl_fh_list is None:
            raise TypeError('data.nfl_fh_list == None')
        self.pack_array(data.nfl_fh_list, self.pack_nfs_fh4)

    def pack_nfs_opnum4(self, data):
        if hasattr(self, 'filter_nfs_opnum4'):
            data = getattr(self, 'filter_nfs_opnum4')(data)
        if self.check_enum and data not in [const.OP_ACCESS, const.OP_CLOSE, const.OP_COMMIT, const.OP_CREATE, const.OP_DELEGPURGE, const.OP_DELEGRETURN, const.OP_GETATTR, const.OP_GETFH, const.OP_LINK, const.OP_LOCK, const.OP_LOCKT, const.OP_LOCKU, const.OP_LOOKUP, const.OP_LOOKUPP, const.OP_NVERIFY, const.OP_OPEN, const.OP_OPENATTR, const.OP_OPEN_CONFIRM, const.OP_OPEN_DOWNGRADE, const.OP_PUTFH, const.OP_PUTPUBFH, const.OP_PUTROOTFH, const.OP_READ, const.OP_READDIR, const.OP_READLINK, const.OP_REMOVE, const.OP_RENAME, const.OP_RENEW, const.OP_RESTOREFH, const.OP_SAVEFH, const.OP_SECINFO, const.OP_SETATTR, const.OP_SETCLIENTID, const.OP_SETCLIENTID_CONFIRM, const.OP_VERIFY, const.OP_WRITE, const.OP_RELEASE_LOCKOWNER, const.OP_BACKCHANNEL_CTL, const.OP_BIND_CONN_TO_SESSION, const.OP_EXCHANGE_ID, const.OP_CREATE_SESSION, const.OP_DESTROY_SESSION, const.OP_FREE_STATEID, const.OP_GET_DIR_DELEGATION, const.OP_GETDEVICEINFO, const.OP_GETDEVICELIST, const.OP_LAYOUTCOMMIT, const.OP_LAYOUTGET, const.OP_LAYOUTRETURN, const.OP_SECINFO_NO_NAME, const.OP_SEQUENCE, const.OP_SET_SSV, const.OP_TEST_STATEID, const.OP_WANT_DELEGATION, const.OP_DESTROY_CLIENTID, const.OP_RECLAIM_COMPLETE, const.OP_ALLOCATE, const.OP_COPY, const.OP_COPY_NOTIFY, const.OP_DEALLOCATE, const.OP_IO_ADVISE, const.OP_LAYOUTERROR, const.OP_LAYOUTSTATS, const.OP_OFFLOAD_CANCEL, const.OP_OFFLOAD_STATUS, const.OP_READ_PLUS, const.OP_SEEK, const.OP_WRITE_SAME, const.OP_CLONE, const.OP_GETXATTR, const.OP_SETXATTR, const.OP_LISTXATTRS, const.OP_REMOVEXATTR, const.OP_ILLEGAL]:
            raise XDRError('value=%s not in enum nfs_opnum4' % data)
        self.pack_int(data)

    def pack_ACCESS4args(self, data):
        if hasattr(self, 'filter_ACCESS4args'):
            data = getattr(self, 'filter_ACCESS4args')(data)
        if data.access is None:
            raise TypeError('data.access == None')
        self.pack_uint32_t(data.access)

    def pack_ACCESS4resok(self, data):
        if hasattr(self, 'filter_ACCESS4resok'):
            data = getattr(self, 'filter_ACCESS4resok')(data)
        if data.supported is None:
            raise TypeError('data.supported == None')
        self.pack_uint32_t(data.supported)
        if data.access is None:
            raise TypeError('data.access == None')
        self.pack_uint32_t(data.access)

    def pack_ACCESS4res(self, data):
        if hasattr(self, 'filter_ACCESS4res'):
            data = getattr(self, 'filter_ACCESS4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_ACCESS4resok(data.resok4)
        else:
            pass

    def pack_CLONE4args(self, data):
        if hasattr(self, 'filter_CLONE4args'):
            data = getattr(self, 'filter_CLONE4args')(data)
        if data.cl_src_stateid is None:
            raise TypeError('data.cl_src_stateid == None')
        self.pack_stateid4(data.cl_src_stateid)
        if data.cl_dst_stateid is None:
            raise TypeError('data.cl_dst_stateid == None')
        self.pack_stateid4(data.cl_dst_stateid)
        if data.cl_src_offset is None:
            raise TypeError('data.cl_src_offset == None')
        self.pack_offset4(data.cl_src_offset)
        if data.cl_dst_offset is None:
            raise TypeError('data.cl_dst_offset == None')
        self.pack_offset4(data.cl_dst_offset)
        if data.cl_count is None:
            raise TypeError('data.cl_count == None')
        self.pack_length4(data.cl_count)

    def pack_CLONE4res(self, data):
        if hasattr(self, 'filter_CLONE4res'):
            data = getattr(self, 'filter_CLONE4res')(data)
        if data.cl_status is None:
            raise TypeError('data.cl_status == None')
        self.pack_nfsstat4(data.cl_status)

    def pack_CLOSE4args(self, data):
        if hasattr(self, 'filter_CLOSE4args'):
            data = getattr(self, 'filter_CLOSE4args')(data)
        if data.seqid is None:
            raise TypeError('data.seqid == None')
        self.pack_seqid4(data.seqid)
        if data.open_stateid is None:
            raise TypeError('data.open_stateid == None')
        self.pack_stateid4(data.open_stateid)

    def pack_CLOSE4res(self, data):
        if hasattr(self, 'filter_CLOSE4res'):
            data = getattr(self, 'filter_CLOSE4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.open_stateid is None:
                raise TypeError('data.open_stateid == None')
            self.pack_stateid4(data.open_stateid)
        else:
            pass

    def pack_COMMIT4args(self, data):
        if hasattr(self, 'filter_COMMIT4args'):
            data = getattr(self, 'filter_COMMIT4args')(data)
        if data.offset is None:
            raise TypeError('data.offset == None')
        self.pack_offset4(data.offset)
        if data.count is None:
            raise TypeError('data.count == None')
        self.pack_count4(data.count)

    def pack_COMMIT4resok(self, data):
        if hasattr(self, 'filter_COMMIT4resok'):
            data = getattr(self, 'filter_COMMIT4resok')(data)
        if data.writeverf is None:
            raise TypeError('data.writeverf == None')
        self.pack_verifier4(data.writeverf)

    def pack_COMMIT4res(self, data):
        if hasattr(self, 'filter_COMMIT4res'):
            data = getattr(self, 'filter_COMMIT4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_COMMIT4resok(data.resok4)
        else:
            pass

    def pack_createtype4(self, data):
        if hasattr(self, 'filter_createtype4'):
            data = getattr(self, 'filter_createtype4')(data)
        if data.type is None:
            raise TypeError('data.type == None')
        self.pack_nfs_ftype4(data.type)
        if data.type == const.NF4LNK:
            if data.linkdata is None:
                raise TypeError('data.linkdata == None')
            self.pack_linktext4(data.linkdata)
        elif data.type == const.NF4BLK or data.type == const.NF4CHR:
            if data.devdata is None:
                raise TypeError('data.devdata == None')
            self.pack_specdata4(data.devdata)
        elif data.type == const.NF4SOCK or data.type == const.NF4FIFO or data.type == const.NF4DIR:
            pass
        else:
            pass

    def pack_CREATE4args(self, data):
        if hasattr(self, 'filter_CREATE4args'):
            data = getattr(self, 'filter_CREATE4args')(data)
        if data.objtype is None:
            raise TypeError('data.objtype == None')
        self.pack_createtype4(data.objtype)
        if data.objname is None:
            raise TypeError('data.objname == None')
        self.pack_component4(data.objname)
        if data.createattrs is None:
            raise TypeError('data.createattrs == None')
        self.pack_fattr4(data.createattrs)

    def pack_CREATE4resok(self, data):
        if hasattr(self, 'filter_CREATE4resok'):
            data = getattr(self, 'filter_CREATE4resok')(data)
        if data.cinfo is None:
            raise TypeError('data.cinfo == None')
        self.pack_change_info4(data.cinfo)
        if data.attrset is None:
            raise TypeError('data.attrset == None')
        self.pack_bitmap4(data.attrset)

    def pack_CREATE4res(self, data):
        if hasattr(self, 'filter_CREATE4res'):
            data = getattr(self, 'filter_CREATE4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_CREATE4resok(data.resok4)
        else:
            pass

    def pack_DELEGPURGE4args(self, data):
        if hasattr(self, 'filter_DELEGPURGE4args'):
            data = getattr(self, 'filter_DELEGPURGE4args')(data)
        if data.clientid is None:
            raise TypeError('data.clientid == None')
        self.pack_clientid4(data.clientid)

    def pack_DELEGPURGE4res(self, data):
        if hasattr(self, 'filter_DELEGPURGE4res'):
            data = getattr(self, 'filter_DELEGPURGE4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_DELEGRETURN4args(self, data):
        if hasattr(self, 'filter_DELEGRETURN4args'):
            data = getattr(self, 'filter_DELEGRETURN4args')(data)
        if data.deleg_stateid is None:
            raise TypeError('data.deleg_stateid == None')
        self.pack_stateid4(data.deleg_stateid)

    def pack_DELEGRETURN4res(self, data):
        if hasattr(self, 'filter_DELEGRETURN4res'):
            data = getattr(self, 'filter_DELEGRETURN4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_GETATTR4args(self, data):
        if hasattr(self, 'filter_GETATTR4args'):
            data = getattr(self, 'filter_GETATTR4args')(data)
        if data.attr_request is None:
            raise TypeError('data.attr_request == None')
        self.pack_bitmap4(data.attr_request)

    def pack_GETATTR4resok(self, data):
        if hasattr(self, 'filter_GETATTR4resok'):
            data = getattr(self, 'filter_GETATTR4resok')(data)
        if data.obj_attributes is None:
            raise TypeError('data.obj_attributes == None')
        self.pack_fattr4(data.obj_attributes)

    def pack_GETATTR4res(self, data):
        if hasattr(self, 'filter_GETATTR4res'):
            data = getattr(self, 'filter_GETATTR4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_GETATTR4resok(data.resok4)
        else:
            pass

    def pack_GETFH4resok(self, data):
        if hasattr(self, 'filter_GETFH4resok'):
            data = getattr(self, 'filter_GETFH4resok')(data)
        if data.object is None:
            raise TypeError('data.object == None')
        self.pack_nfs_fh4(data.object)

    def pack_GETFH4res(self, data):
        if hasattr(self, 'filter_GETFH4res'):
            data = getattr(self, 'filter_GETFH4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_GETFH4resok(data.resok4)
        else:
            pass

    def pack_LINK4args(self, data):
        if hasattr(self, 'filter_LINK4args'):
            data = getattr(self, 'filter_LINK4args')(data)
        if data.newname is None:
            raise TypeError('data.newname == None')
        self.pack_component4(data.newname)

    def pack_LINK4resok(self, data):
        if hasattr(self, 'filter_LINK4resok'):
            data = getattr(self, 'filter_LINK4resok')(data)
        if data.cinfo is None:
            raise TypeError('data.cinfo == None')
        self.pack_change_info4(data.cinfo)

    def pack_LINK4res(self, data):
        if hasattr(self, 'filter_LINK4res'):
            data = getattr(self, 'filter_LINK4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_LINK4resok(data.resok4)
        else:
            pass

    def pack_open_to_lock_owner4(self, data):
        if hasattr(self, 'filter_open_to_lock_owner4'):
            data = getattr(self, 'filter_open_to_lock_owner4')(data)
        if data.open_seqid is None:
            raise TypeError('data.open_seqid == None')
        self.pack_seqid4(data.open_seqid)
        if data.open_stateid is None:
            raise TypeError('data.open_stateid == None')
        self.pack_stateid4(data.open_stateid)
        if data.lock_seqid is None:
            raise TypeError('data.lock_seqid == None')
        self.pack_seqid4(data.lock_seqid)
        if data.lock_owner is None:
            raise TypeError('data.lock_owner == None')
        self.pack_lock_owner4(data.lock_owner)

    def pack_exist_lock_owner4(self, data):
        if hasattr(self, 'filter_exist_lock_owner4'):
            data = getattr(self, 'filter_exist_lock_owner4')(data)
        if data.lock_stateid is None:
            raise TypeError('data.lock_stateid == None')
        self.pack_stateid4(data.lock_stateid)
        if data.lock_seqid is None:
            raise TypeError('data.lock_seqid == None')
        self.pack_seqid4(data.lock_seqid)

    def pack_locker4(self, data):
        if hasattr(self, 'filter_locker4'):
            data = getattr(self, 'filter_locker4')(data)
        if data.new_lock_owner is None:
            raise TypeError('data.new_lock_owner == None')
        self.pack_bool(data.new_lock_owner)
        if data.new_lock_owner == const.TRUE:
            if data.open_owner is None:
                raise TypeError('data.open_owner == None')
            self.pack_open_to_lock_owner4(data.open_owner)
        elif data.new_lock_owner == const.FALSE:
            if data.lock_owner is None:
                raise TypeError('data.lock_owner == None')
            self.pack_exist_lock_owner4(data.lock_owner)
        else:
            raise XDRError('bad switch=%s' % data.new_lock_owner)

    def pack_LOCK4args(self, data):
        if hasattr(self, 'filter_LOCK4args'):
            data = getattr(self, 'filter_LOCK4args')(data)
        if data.locktype is None:
            raise TypeError('data.locktype == None')
        self.pack_nfs_lock_type4(data.locktype)
        if data.reclaim is None:
            raise TypeError('data.reclaim == None')
        self.pack_bool(data.reclaim)
        if data.offset is None:
            raise TypeError('data.offset == None')
        self.pack_offset4(data.offset)
        if data.length is None:
            raise TypeError('data.length == None')
        self.pack_length4(data.length)
        if data.locker is None:
            raise TypeError('data.locker == None')
        self.pack_locker4(data.locker)

    def pack_LOCK4denied(self, data):
        if hasattr(self, 'filter_LOCK4denied'):
            data = getattr(self, 'filter_LOCK4denied')(data)
        if data.offset is None:
            raise TypeError('data.offset == None')
        self.pack_offset4(data.offset)
        if data.length is None:
            raise TypeError('data.length == None')
        self.pack_length4(data.length)
        if data.locktype is None:
            raise TypeError('data.locktype == None')
        self.pack_nfs_lock_type4(data.locktype)
        if data.owner is None:
            raise TypeError('data.owner == None')
        self.pack_lock_owner4(data.owner)

    def pack_LOCK4resok(self, data):
        if hasattr(self, 'filter_LOCK4resok'):
            data = getattr(self, 'filter_LOCK4resok')(data)
        if data.lock_stateid is None:
            raise TypeError('data.lock_stateid == None')
        self.pack_stateid4(data.lock_stateid)

    def pack_LOCK4res(self, data):
        if hasattr(self, 'filter_LOCK4res'):
            data = getattr(self, 'filter_LOCK4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_LOCK4resok(data.resok4)
        elif data.status == const.NFS4ERR_DENIED:
            if data.denied is None:
                raise TypeError('data.denied == None')
            self.pack_LOCK4denied(data.denied)
        else:
            pass

    def pack_LOCKT4args(self, data):
        if hasattr(self, 'filter_LOCKT4args'):
            data = getattr(self, 'filter_LOCKT4args')(data)
        if data.locktype is None:
            raise TypeError('data.locktype == None')
        self.pack_nfs_lock_type4(data.locktype)
        if data.offset is None:
            raise TypeError('data.offset == None')
        self.pack_offset4(data.offset)
        if data.length is None:
            raise TypeError('data.length == None')
        self.pack_length4(data.length)
        if data.owner is None:
            raise TypeError('data.owner == None')
        self.pack_lock_owner4(data.owner)

    def pack_LOCKT4res(self, data):
        if hasattr(self, 'filter_LOCKT4res'):
            data = getattr(self, 'filter_LOCKT4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4ERR_DENIED:
            if data.denied is None:
                raise TypeError('data.denied == None')
            self.pack_LOCK4denied(data.denied)
        elif data.status == const.NFS4_OK:
            pass
        else:
            pass

    def pack_LOCKU4args(self, data):
        if hasattr(self, 'filter_LOCKU4args'):
            data = getattr(self, 'filter_LOCKU4args')(data)
        if data.locktype is None:
            raise TypeError('data.locktype == None')
        self.pack_nfs_lock_type4(data.locktype)
        if data.seqid is None:
            raise TypeError('data.seqid == None')
        self.pack_seqid4(data.seqid)
        if data.lock_stateid is None:
            raise TypeError('data.lock_stateid == None')
        self.pack_stateid4(data.lock_stateid)
        if data.offset is None:
            raise TypeError('data.offset == None')
        self.pack_offset4(data.offset)
        if data.length is None:
            raise TypeError('data.length == None')
        self.pack_length4(data.length)

    def pack_LOCKU4res(self, data):
        if hasattr(self, 'filter_LOCKU4res'):
            data = getattr(self, 'filter_LOCKU4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.lock_stateid is None:
                raise TypeError('data.lock_stateid == None')
            self.pack_stateid4(data.lock_stateid)
        else:
            pass

    def pack_LOOKUP4args(self, data):
        if hasattr(self, 'filter_LOOKUP4args'):
            data = getattr(self, 'filter_LOOKUP4args')(data)
        if data.objname is None:
            raise TypeError('data.objname == None')
        self.pack_component4(data.objname)

    def pack_LOOKUP4res(self, data):
        if hasattr(self, 'filter_LOOKUP4res'):
            data = getattr(self, 'filter_LOOKUP4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_LOOKUPP4res(self, data):
        if hasattr(self, 'filter_LOOKUPP4res'):
            data = getattr(self, 'filter_LOOKUPP4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_NVERIFY4args(self, data):
        if hasattr(self, 'filter_NVERIFY4args'):
            data = getattr(self, 'filter_NVERIFY4args')(data)
        if data.obj_attributes is None:
            raise TypeError('data.obj_attributes == None')
        self.pack_fattr4(data.obj_attributes)

    def pack_NVERIFY4res(self, data):
        if hasattr(self, 'filter_NVERIFY4res'):
            data = getattr(self, 'filter_NVERIFY4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_createmode4(self, data):
        if hasattr(self, 'filter_createmode4'):
            data = getattr(self, 'filter_createmode4')(data)
        if self.check_enum and data not in [const.UNCHECKED4, const.GUARDED4, const.EXCLUSIVE4, const.EXCLUSIVE4_1]:
            raise XDRError('value=%s not in enum createmode4' % data)
        self.pack_int(data)

    def pack_creatverfattr(self, data):
        if hasattr(self, 'filter_creatverfattr'):
            data = getattr(self, 'filter_creatverfattr')(data)
        if data.cva_verf is None:
            raise TypeError('data.cva_verf == None')
        self.pack_verifier4(data.cva_verf)
        if data.cva_attrs is None:
            raise TypeError('data.cva_attrs == None')
        self.pack_fattr4(data.cva_attrs)

    def pack_createhow4(self, data):
        if hasattr(self, 'filter_createhow4'):
            data = getattr(self, 'filter_createhow4')(data)
        if data.mode is None:
            raise TypeError('data.mode == None')
        self.pack_createmode4(data.mode)
        if data.mode == const.UNCHECKED4 or data.mode == const.GUARDED4:
            if data.createattrs is None:
                raise TypeError('data.createattrs == None')
            self.pack_fattr4(data.createattrs)
        elif data.mode == const.EXCLUSIVE4:
            if data.createverf is None:
                raise TypeError('data.createverf == None')
            self.pack_verifier4(data.createverf)
        elif data.mode == const.EXCLUSIVE4_1:
            if data.ch_createboth is None:
                raise TypeError('data.ch_createboth == None')
            self.pack_creatverfattr(data.ch_createboth)
        else:
            raise XDRError('bad switch=%s' % data.mode)

    def pack_opentype4(self, data):
        if hasattr(self, 'filter_opentype4'):
            data = getattr(self, 'filter_opentype4')(data)
        if self.check_enum and data not in [const.OPEN4_NOCREATE, const.OPEN4_CREATE]:
            raise XDRError('value=%s not in enum opentype4' % data)
        self.pack_int(data)

    def pack_openflag4(self, data):
        if hasattr(self, 'filter_openflag4'):
            data = getattr(self, 'filter_openflag4')(data)
        if data.opentype is None:
            raise TypeError('data.opentype == None')
        self.pack_opentype4(data.opentype)
        if data.opentype == const.OPEN4_CREATE:
            if data.how is None:
                raise TypeError('data.how == None')
            self.pack_createhow4(data.how)
        else:
            pass

    def pack_limit_by4(self, data):
        if hasattr(self, 'filter_limit_by4'):
            data = getattr(self, 'filter_limit_by4')(data)
        if self.check_enum and data not in [const.NFS_LIMIT_SIZE, const.NFS_LIMIT_BLOCKS]:
            raise XDRError('value=%s not in enum limit_by4' % data)
        self.pack_int(data)

    def pack_nfs_modified_limit4(self, data):
        if hasattr(self, 'filter_nfs_modified_limit4'):
            data = getattr(self, 'filter_nfs_modified_limit4')(data)
        if data.num_blocks is None:
            raise TypeError('data.num_blocks == None')
        self.pack_uint32_t(data.num_blocks)
        if data.bytes_per_block is None:
            raise TypeError('data.bytes_per_block == None')
        self.pack_uint32_t(data.bytes_per_block)

    def pack_nfs_space_limit4(self, data):
        if hasattr(self, 'filter_nfs_space_limit4'):
            data = getattr(self, 'filter_nfs_space_limit4')(data)
        if data.limitby is None:
            raise TypeError('data.limitby == None')
        self.pack_limit_by4(data.limitby)
        if data.limitby == const.NFS_LIMIT_SIZE:
            if data.filesize is None:
                raise TypeError('data.filesize == None')
            self.pack_uint64_t(data.filesize)
        elif data.limitby == const.NFS_LIMIT_BLOCKS:
            if data.mod_blocks is None:
                raise TypeError('data.mod_blocks == None')
            self.pack_nfs_modified_limit4(data.mod_blocks)
        else:
            raise XDRError('bad switch=%s' % data.limitby)

    def pack_open_delegation_type4(self, data):
        if hasattr(self, 'filter_open_delegation_type4'):
            data = getattr(self, 'filter_open_delegation_type4')(data)
        if self.check_enum and data not in [const.OPEN_DELEGATE_NONE, const.OPEN_DELEGATE_READ, const.OPEN_DELEGATE_WRITE, const.OPEN_DELEGATE_NONE_EXT, const.OPEN_DELEGATE_READ_ATTRS_DELEG, const.OPEN_DELEGATE_WRITE_ATTRS_DELEG]:
            raise XDRError('value=%s not in enum open_delegation_type4' % data)
        self.pack_int(data)

    def pack_open_claim_type4(self, data):
        if hasattr(self, 'filter_open_claim_type4'):
            data = getattr(self, 'filter_open_claim_type4')(data)
        if self.check_enum and data not in [const.CLAIM_NULL, const.CLAIM_PREVIOUS, const.CLAIM_DELEGATE_CUR, const.CLAIM_DELEGATE_PREV, const.CLAIM_FH, const.CLAIM_DELEG_CUR_FH, const.CLAIM_DELEG_PREV_FH]:
            raise XDRError('value=%s not in enum open_claim_type4' % data)
        self.pack_int(data)

    def pack_open_claim_delegate_cur4(self, data):
        if hasattr(self, 'filter_open_claim_delegate_cur4'):
            data = getattr(self, 'filter_open_claim_delegate_cur4')(data)
        if data.delegate_stateid is None:
            raise TypeError('data.delegate_stateid == None')
        self.pack_stateid4(data.delegate_stateid)
        if data.file is None:
            raise TypeError('data.file == None')
        self.pack_component4(data.file)

    def pack_open_claim4(self, data):
        if hasattr(self, 'filter_open_claim4'):
            data = getattr(self, 'filter_open_claim4')(data)
        if data.claim is None:
            raise TypeError('data.claim == None')
        self.pack_open_claim_type4(data.claim)
        if data.claim == const.CLAIM_NULL:
            if data.file is None:
                raise TypeError('data.file == None')
            self.pack_component4(data.file)
        elif data.claim == const.CLAIM_PREVIOUS:
            if data.delegate_type is None:
                raise TypeError('data.delegate_type == None')
            self.pack_open_delegation_type4(data.delegate_type)
        elif data.claim == const.CLAIM_DELEGATE_CUR:
            if data.delegate_cur_info is None:
                raise TypeError('data.delegate_cur_info == None')
            self.pack_open_claim_delegate_cur4(data.delegate_cur_info)
        elif data.claim == const.CLAIM_DELEGATE_PREV:
            if data.file_delegate_prev is None:
                raise TypeError('data.file_delegate_prev == None')
            self.pack_component4(data.file_delegate_prev)
        elif data.claim == const.CLAIM_FH:
            pass
        elif data.claim == const.CLAIM_DELEG_PREV_FH:
            pass
        elif data.claim == const.CLAIM_DELEG_CUR_FH:
            if data.oc_delegate_stateid is None:
                raise TypeError('data.oc_delegate_stateid == None')
            self.pack_stateid4(data.oc_delegate_stateid)
        else:
            raise XDRError('bad switch=%s' % data.claim)

    def pack_OPEN4args(self, data):
        if hasattr(self, 'filter_OPEN4args'):
            data = getattr(self, 'filter_OPEN4args')(data)
        if data.seqid is None:
            raise TypeError('data.seqid == None')
        self.pack_seqid4(data.seqid)
        if data.share_access is None:
            raise TypeError('data.share_access == None')
        self.pack_uint32_t(data.share_access)
        if data.share_deny is None:
            raise TypeError('data.share_deny == None')
        self.pack_uint32_t(data.share_deny)
        if data.owner is None:
            raise TypeError('data.owner == None')
        self.pack_open_owner4(data.owner)
        if data.openhow is None:
            raise TypeError('data.openhow == None')
        self.pack_openflag4(data.openhow)
        if data.claim is None:
            raise TypeError('data.claim == None')
        self.pack_open_claim4(data.claim)

    def pack_open_read_delegation4(self, data):
        if hasattr(self, 'filter_open_read_delegation4'):
            data = getattr(self, 'filter_open_read_delegation4')(data)
        if data.stateid is None:
            raise TypeError('data.stateid == None')
        self.pack_stateid4(data.stateid)
        if data.recall is None:
            raise TypeError('data.recall == None')
        self.pack_bool(data.recall)
        if data.permissions is None:
            raise TypeError('data.permissions == None')
        self.pack_nfsace4(data.permissions)

    def pack_open_write_delegation4(self, data):
        if hasattr(self, 'filter_open_write_delegation4'):
            data = getattr(self, 'filter_open_write_delegation4')(data)
        if data.stateid is None:
            raise TypeError('data.stateid == None')
        self.pack_stateid4(data.stateid)
        if data.recall is None:
            raise TypeError('data.recall == None')
        self.pack_bool(data.recall)
        if data.space_limit is None:
            raise TypeError('data.space_limit == None')
        self.pack_nfs_space_limit4(data.space_limit)
        if data.permissions is None:
            raise TypeError('data.permissions == None')
        self.pack_nfsace4(data.permissions)

    def pack_why_no_delegation4(self, data):
        if hasattr(self, 'filter_why_no_delegation4'):
            data = getattr(self, 'filter_why_no_delegation4')(data)
        if self.check_enum and data not in [const.WND4_NOT_WANTED, const.WND4_CONTENTION, const.WND4_RESOURCE, const.WND4_NOT_SUPP_FTYPE, const.WND4_WRITE_DELEG_NOT_SUPP_FTYPE, const.WND4_NOT_SUPP_UPGRADE, const.WND4_NOT_SUPP_DOWNGRADE, const.WND4_CANCELLED, const.WND4_IS_DIR]:
            raise XDRError('value=%s not in enum why_no_delegation4' % data)
        self.pack_int(data)

    def pack_open_none_delegation4(self, data):
        if hasattr(self, 'filter_open_none_delegation4'):
            data = getattr(self, 'filter_open_none_delegation4')(data)
        if data.ond_why is None:
            raise TypeError('data.ond_why == None')
        self.pack_why_no_delegation4(data.ond_why)
        if data.ond_why == const.WND4_CONTENTION:
            if data.ond_server_will_push_deleg is None:
                raise TypeError('data.ond_server_will_push_deleg == None')
            self.pack_bool(data.ond_server_will_push_deleg)
        elif data.ond_why == const.WND4_RESOURCE:
            if data.ond_server_will_signal_avail is None:
                raise TypeError('data.ond_server_will_signal_avail == None')
            self.pack_bool(data.ond_server_will_signal_avail)
        else:
            pass

    def pack_open_delegation4(self, data):
        if hasattr(self, 'filter_open_delegation4'):
            data = getattr(self, 'filter_open_delegation4')(data)
        if data.delegation_type is None:
            raise TypeError('data.delegation_type == None')
        self.pack_open_delegation_type4(data.delegation_type)
        if data.delegation_type == const.OPEN_DELEGATE_NONE:
            pass
        elif data.delegation_type == const.OPEN_DELEGATE_READ or data.delegation_type == const.OPEN_DELEGATE_READ_ATTRS_DELEG:
            if data.read is None:
                raise TypeError('data.read == None')
            self.pack_open_read_delegation4(data.read)
        elif data.delegation_type == const.OPEN_DELEGATE_WRITE or data.delegation_type == const.OPEN_DELEGATE_WRITE_ATTRS_DELEG:
            if data.write is None:
                raise TypeError('data.write == None')
            self.pack_open_write_delegation4(data.write)
        elif data.delegation_type == const.OPEN_DELEGATE_NONE_EXT:
            if data.od_whynone is None:
                raise TypeError('data.od_whynone == None')
            self.pack_open_none_delegation4(data.od_whynone)
        else:
            raise XDRError('bad switch=%s' % data.delegation_type)

    def pack_OPEN4resok(self, data):
        if hasattr(self, 'filter_OPEN4resok'):
            data = getattr(self, 'filter_OPEN4resok')(data)
        if data.stateid is None:
            raise TypeError('data.stateid == None')
        self.pack_stateid4(data.stateid)
        if data.cinfo is None:
            raise TypeError('data.cinfo == None')
        self.pack_change_info4(data.cinfo)
        if data.rflags is None:
            raise TypeError('data.rflags == None')
        self.pack_uint32_t(data.rflags)
        if data.attrset is None:
            raise TypeError('data.attrset == None')
        self.pack_bitmap4(data.attrset)
        if data.delegation is None:
            raise TypeError('data.delegation == None')
        self.pack_open_delegation4(data.delegation)

    def pack_OPEN4res(self, data):
        if hasattr(self, 'filter_OPEN4res'):
            data = getattr(self, 'filter_OPEN4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_OPEN4resok(data.resok4)
        else:
            pass

    def pack_OPENATTR4args(self, data):
        if hasattr(self, 'filter_OPENATTR4args'):
            data = getattr(self, 'filter_OPENATTR4args')(data)
        if data.createdir is None:
            raise TypeError('data.createdir == None')
        self.pack_bool(data.createdir)

    def pack_OPENATTR4res(self, data):
        if hasattr(self, 'filter_OPENATTR4res'):
            data = getattr(self, 'filter_OPENATTR4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_OPEN_CONFIRM4args(self, data):
        if hasattr(self, 'filter_OPEN_CONFIRM4args'):
            data = getattr(self, 'filter_OPEN_CONFIRM4args')(data)
        if data.open_stateid is None:
            raise TypeError('data.open_stateid == None')
        self.pack_stateid4(data.open_stateid)
        if data.seqid is None:
            raise TypeError('data.seqid == None')
        self.pack_seqid4(data.seqid)

    def pack_OPEN_CONFIRM4resok(self, data):
        if hasattr(self, 'filter_OPEN_CONFIRM4resok'):
            data = getattr(self, 'filter_OPEN_CONFIRM4resok')(data)
        if data.open_stateid is None:
            raise TypeError('data.open_stateid == None')
        self.pack_stateid4(data.open_stateid)

    def pack_OPEN_CONFIRM4res(self, data):
        if hasattr(self, 'filter_OPEN_CONFIRM4res'):
            data = getattr(self, 'filter_OPEN_CONFIRM4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_OPEN_CONFIRM4resok(data.resok4)
        else:
            pass

    def pack_OPEN_DOWNGRADE4args(self, data):
        if hasattr(self, 'filter_OPEN_DOWNGRADE4args'):
            data = getattr(self, 'filter_OPEN_DOWNGRADE4args')(data)
        if data.open_stateid is None:
            raise TypeError('data.open_stateid == None')
        self.pack_stateid4(data.open_stateid)
        if data.seqid is None:
            raise TypeError('data.seqid == None')
        self.pack_seqid4(data.seqid)
        if data.share_access is None:
            raise TypeError('data.share_access == None')
        self.pack_uint32_t(data.share_access)
        if data.share_deny is None:
            raise TypeError('data.share_deny == None')
        self.pack_uint32_t(data.share_deny)

    def pack_OPEN_DOWNGRADE4resok(self, data):
        if hasattr(self, 'filter_OPEN_DOWNGRADE4resok'):
            data = getattr(self, 'filter_OPEN_DOWNGRADE4resok')(data)
        if data.open_stateid is None:
            raise TypeError('data.open_stateid == None')
        self.pack_stateid4(data.open_stateid)

    def pack_OPEN_DOWNGRADE4res(self, data):
        if hasattr(self, 'filter_OPEN_DOWNGRADE4res'):
            data = getattr(self, 'filter_OPEN_DOWNGRADE4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_OPEN_DOWNGRADE4resok(data.resok4)
        else:
            pass

    def pack_PUTFH4args(self, data):
        if hasattr(self, 'filter_PUTFH4args'):
            data = getattr(self, 'filter_PUTFH4args')(data)
        if data.object is None:
            raise TypeError('data.object == None')
        self.pack_nfs_fh4(data.object)

    def pack_PUTFH4res(self, data):
        if hasattr(self, 'filter_PUTFH4res'):
            data = getattr(self, 'filter_PUTFH4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_PUTPUBFH4res(self, data):
        if hasattr(self, 'filter_PUTPUBFH4res'):
            data = getattr(self, 'filter_PUTPUBFH4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_PUTROOTFH4res(self, data):
        if hasattr(self, 'filter_PUTROOTFH4res'):
            data = getattr(self, 'filter_PUTROOTFH4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_READ4args(self, data):
        if hasattr(self, 'filter_READ4args'):
            data = getattr(self, 'filter_READ4args')(data)
        if data.stateid is None:
            raise TypeError('data.stateid == None')
        self.pack_stateid4(data.stateid)
        if data.offset is None:
            raise TypeError('data.offset == None')
        self.pack_offset4(data.offset)
        if data.count is None:
            raise TypeError('data.count == None')
        self.pack_count4(data.count)

    def pack_READ4resok(self, data):
        if hasattr(self, 'filter_READ4resok'):
            data = getattr(self, 'filter_READ4resok')(data)
        if data.eof is None:
            raise TypeError('data.eof == None')
        self.pack_bool(data.eof)
        if data.data is None:
            raise TypeError('data.data == None')
        self.pack_opaque(data.data)

    def pack_READ4res(self, data):
        if hasattr(self, 'filter_READ4res'):
            data = getattr(self, 'filter_READ4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_READ4resok(data.resok4)
        else:
            pass

    def pack_READDIR4args(self, data):
        if hasattr(self, 'filter_READDIR4args'):
            data = getattr(self, 'filter_READDIR4args')(data)
        if data.cookie is None:
            raise TypeError('data.cookie == None')
        self.pack_nfs_cookie4(data.cookie)
        if data.cookieverf is None:
            raise TypeError('data.cookieverf == None')
        self.pack_verifier4(data.cookieverf)
        if data.dircount is None:
            raise TypeError('data.dircount == None')
        self.pack_count4(data.dircount)
        if data.maxcount is None:
            raise TypeError('data.maxcount == None')
        self.pack_count4(data.maxcount)
        if data.attr_request is None:
            raise TypeError('data.attr_request == None')
        self.pack_bitmap4(data.attr_request)

    def pack_entry4(self, data):
        if hasattr(self, 'filter_entry4'):
            data = getattr(self, 'filter_entry4')(data)
        if data.cookie is None:
            raise TypeError('data.cookie == None')
        self.pack_nfs_cookie4(data.cookie)
        if data.name is None:
            raise TypeError('data.name == None')
        self.pack_component4(data.name)
        if data.attrs is None:
            raise TypeError('data.attrs == None')
        self.pack_fattr4(data.attrs)
        if data.nextentry is None:
            raise TypeError('data.nextentry == None')
        if len(data.nextentry) > 1 and self.check_array:
            raise XDRError('array length too long for data.nextentry')
        self.pack_array(data.nextentry, self.pack_entry4)

    def pack_dirlist4(self, data):
        if hasattr(self, 'filter_dirlist4'):
            data = getattr(self, 'filter_dirlist4')(data)
        if data.entries is None:
            raise TypeError('data.entries == None')
        if len(data.entries) > 1 and self.check_array:
            raise XDRError('array length too long for data.entries')
        self.pack_array(data.entries, self.pack_entry4)
        if data.eof is None:
            raise TypeError('data.eof == None')
        self.pack_bool(data.eof)

    def pack_READDIR4resok(self, data):
        if hasattr(self, 'filter_READDIR4resok'):
            data = getattr(self, 'filter_READDIR4resok')(data)
        if data.cookieverf is None:
            raise TypeError('data.cookieverf == None')
        self.pack_verifier4(data.cookieverf)
        if data.reply is None:
            raise TypeError('data.reply == None')
        self.pack_dirlist4(data.reply)

    def pack_READDIR4res(self, data):
        if hasattr(self, 'filter_READDIR4res'):
            data = getattr(self, 'filter_READDIR4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_READDIR4resok(data.resok4)
        else:
            pass

    def pack_READLINK4resok(self, data):
        if hasattr(self, 'filter_READLINK4resok'):
            data = getattr(self, 'filter_READLINK4resok')(data)
        if data.link is None:
            raise TypeError('data.link == None')
        self.pack_linktext4(data.link)

    def pack_READLINK4res(self, data):
        if hasattr(self, 'filter_READLINK4res'):
            data = getattr(self, 'filter_READLINK4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_READLINK4resok(data.resok4)
        else:
            pass

    def pack_REMOVE4args(self, data):
        if hasattr(self, 'filter_REMOVE4args'):
            data = getattr(self, 'filter_REMOVE4args')(data)
        if data.target is None:
            raise TypeError('data.target == None')
        self.pack_component4(data.target)

    def pack_REMOVE4resok(self, data):
        if hasattr(self, 'filter_REMOVE4resok'):
            data = getattr(self, 'filter_REMOVE4resok')(data)
        if data.cinfo is None:
            raise TypeError('data.cinfo == None')
        self.pack_change_info4(data.cinfo)

    def pack_REMOVE4res(self, data):
        if hasattr(self, 'filter_REMOVE4res'):
            data = getattr(self, 'filter_REMOVE4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_REMOVE4resok(data.resok4)
        else:
            pass

    def pack_RENAME4args(self, data):
        if hasattr(self, 'filter_RENAME4args'):
            data = getattr(self, 'filter_RENAME4args')(data)
        if data.oldname is None:
            raise TypeError('data.oldname == None')
        self.pack_component4(data.oldname)
        if data.newname is None:
            raise TypeError('data.newname == None')
        self.pack_component4(data.newname)

    def pack_RENAME4resok(self, data):
        if hasattr(self, 'filter_RENAME4resok'):
            data = getattr(self, 'filter_RENAME4resok')(data)
        if data.source_cinfo is None:
            raise TypeError('data.source_cinfo == None')
        self.pack_change_info4(data.source_cinfo)
        if data.target_cinfo is None:
            raise TypeError('data.target_cinfo == None')
        self.pack_change_info4(data.target_cinfo)

    def pack_RENAME4res(self, data):
        if hasattr(self, 'filter_RENAME4res'):
            data = getattr(self, 'filter_RENAME4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_RENAME4resok(data.resok4)
        else:
            pass

    def pack_RENEW4args(self, data):
        if hasattr(self, 'filter_RENEW4args'):
            data = getattr(self, 'filter_RENEW4args')(data)
        if data.clientid is None:
            raise TypeError('data.clientid == None')
        self.pack_clientid4(data.clientid)

    def pack_RENEW4res(self, data):
        if hasattr(self, 'filter_RENEW4res'):
            data = getattr(self, 'filter_RENEW4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_RESTOREFH4res(self, data):
        if hasattr(self, 'filter_RESTOREFH4res'):
            data = getattr(self, 'filter_RESTOREFH4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_SAVEFH4res(self, data):
        if hasattr(self, 'filter_SAVEFH4res'):
            data = getattr(self, 'filter_SAVEFH4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_SECINFO4args(self, data):
        if hasattr(self, 'filter_SECINFO4args'):
            data = getattr(self, 'filter_SECINFO4args')(data)
        if data.name is None:
            raise TypeError('data.name == None')
        self.pack_component4(data.name)

    def pack_rpc_gss_svc_t(self, data):
        if hasattr(self, 'filter_rpc_gss_svc_t'):
            data = getattr(self, 'filter_rpc_gss_svc_t')(data)
        if self.check_enum and data not in [const.RPC_GSS_SVC_NONE, const.RPC_GSS_SVC_INTEGRITY, const.RPC_GSS_SVC_PRIVACY]:
            raise XDRError('value=%s not in enum rpc_gss_svc_t' % data)
        self.pack_int(data)

    def pack_rpcsec_gss_info(self, data):
        if hasattr(self, 'filter_rpcsec_gss_info'):
            data = getattr(self, 'filter_rpcsec_gss_info')(data)
        if data.oid is None:
            raise TypeError('data.oid == None')
        self.pack_sec_oid4(data.oid)
        if data.qop is None:
            raise TypeError('data.qop == None')
        self.pack_qop4(data.qop)
        if data.service is None:
            raise TypeError('data.service == None')
        self.pack_rpc_gss_svc_t(data.service)

    def pack_secinfo4(self, data):
        if hasattr(self, 'filter_secinfo4'):
            data = getattr(self, 'filter_secinfo4')(data)
        if data.flavor is None:
            raise TypeError('data.flavor == None')
        self.pack_uint32_t(data.flavor)
        if data.flavor == const.RPCSEC_GSS:
            if data.flavor_info is None:
                raise TypeError('data.flavor_info == None')
            self.pack_rpcsec_gss_info(data.flavor_info)
        else:
            pass

    def pack_SECINFO4resok(self, data):
        if hasattr(self, 'filter_SECINFO4resok'):
            data = getattr(self, 'filter_SECINFO4resok')(data)
        self.pack_array(data, self.pack_secinfo4)

    def pack_SECINFO4res(self, data):
        if hasattr(self, 'filter_SECINFO4res'):
            data = getattr(self, 'filter_SECINFO4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_SECINFO4resok(data.resok4)
        else:
            pass

    def pack_SETATTR4args(self, data):
        if hasattr(self, 'filter_SETATTR4args'):
            data = getattr(self, 'filter_SETATTR4args')(data)
        if data.stateid is None:
            raise TypeError('data.stateid == None')
        self.pack_stateid4(data.stateid)
        if data.obj_attributes is None:
            raise TypeError('data.obj_attributes == None')
        self.pack_fattr4(data.obj_attributes)

    def pack_SETATTR4res(self, data):
        if hasattr(self, 'filter_SETATTR4res'):
            data = getattr(self, 'filter_SETATTR4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.attrsset is None:
            raise TypeError('data.attrsset == None')
        self.pack_bitmap4(data.attrsset)

    def pack_SETCLIENTID4args(self, data):
        if hasattr(self, 'filter_SETCLIENTID4args'):
            data = getattr(self, 'filter_SETCLIENTID4args')(data)
        if data.client is None:
            raise TypeError('data.client == None')
        self.pack_nfs_client_id4(data.client)
        if data.callback is None:
            raise TypeError('data.callback == None')
        self.pack_cb_client4(data.callback)
        if data.callback_ident is None:
            raise TypeError('data.callback_ident == None')
        self.pack_uint32_t(data.callback_ident)

    def pack_SETCLIENTID4resok(self, data):
        if hasattr(self, 'filter_SETCLIENTID4resok'):
            data = getattr(self, 'filter_SETCLIENTID4resok')(data)
        if data.clientid is None:
            raise TypeError('data.clientid == None')
        self.pack_clientid4(data.clientid)
        if data.setclientid_confirm is None:
            raise TypeError('data.setclientid_confirm == None')
        self.pack_verifier4(data.setclientid_confirm)

    def pack_SETCLIENTID4res(self, data):
        if hasattr(self, 'filter_SETCLIENTID4res'):
            data = getattr(self, 'filter_SETCLIENTID4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_SETCLIENTID4resok(data.resok4)
        elif data.status == const.NFS4ERR_CLID_INUSE:
            if data.client_using is None:
                raise TypeError('data.client_using == None')
            self.pack_clientaddr4(data.client_using)
        else:
            pass

    def pack_SETCLIENTID_CONFIRM4args(self, data):
        if hasattr(self, 'filter_SETCLIENTID_CONFIRM4args'):
            data = getattr(self, 'filter_SETCLIENTID_CONFIRM4args')(data)
        if data.clientid is None:
            raise TypeError('data.clientid == None')
        self.pack_clientid4(data.clientid)
        if data.setclientid_confirm is None:
            raise TypeError('data.setclientid_confirm == None')
        self.pack_verifier4(data.setclientid_confirm)

    def pack_SETCLIENTID_CONFIRM4res(self, data):
        if hasattr(self, 'filter_SETCLIENTID_CONFIRM4res'):
            data = getattr(self, 'filter_SETCLIENTID_CONFIRM4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_VERIFY4args(self, data):
        if hasattr(self, 'filter_VERIFY4args'):
            data = getattr(self, 'filter_VERIFY4args')(data)
        if data.obj_attributes is None:
            raise TypeError('data.obj_attributes == None')
        self.pack_fattr4(data.obj_attributes)

    def pack_VERIFY4res(self, data):
        if hasattr(self, 'filter_VERIFY4res'):
            data = getattr(self, 'filter_VERIFY4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_WRITE4args(self, data):
        if hasattr(self, 'filter_WRITE4args'):
            data = getattr(self, 'filter_WRITE4args')(data)
        if data.stateid is None:
            raise TypeError('data.stateid == None')
        self.pack_stateid4(data.stateid)
        if data.offset is None:
            raise TypeError('data.offset == None')
        self.pack_offset4(data.offset)
        if data.stable is None:
            raise TypeError('data.stable == None')
        self.pack_stable_how4(data.stable)
        if data.data is None:
            raise TypeError('data.data == None')
        self.pack_opaque(data.data)

    def pack_WRITE4resok(self, data):
        if hasattr(self, 'filter_WRITE4resok'):
            data = getattr(self, 'filter_WRITE4resok')(data)
        if data.count is None:
            raise TypeError('data.count == None')
        self.pack_count4(data.count)
        if data.committed is None:
            raise TypeError('data.committed == None')
        self.pack_stable_how4(data.committed)
        if data.writeverf is None:
            raise TypeError('data.writeverf == None')
        self.pack_verifier4(data.writeverf)

    def pack_WRITE4res(self, data):
        if hasattr(self, 'filter_WRITE4res'):
            data = getattr(self, 'filter_WRITE4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_WRITE4resok(data.resok4)
        else:
            pass

    def pack_RELEASE_LOCKOWNER4args(self, data):
        if hasattr(self, 'filter_RELEASE_LOCKOWNER4args'):
            data = getattr(self, 'filter_RELEASE_LOCKOWNER4args')(data)
        if data.lock_owner is None:
            raise TypeError('data.lock_owner == None')
        self.pack_lock_owner4(data.lock_owner)

    def pack_RELEASE_LOCKOWNER4res(self, data):
        if hasattr(self, 'filter_RELEASE_LOCKOWNER4res'):
            data = getattr(self, 'filter_RELEASE_LOCKOWNER4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_ILLEGAL4res(self, data):
        if hasattr(self, 'filter_ILLEGAL4res'):
            data = getattr(self, 'filter_ILLEGAL4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_gsshandle4_t(self, data):
        if hasattr(self, 'filter_gsshandle4_t'):
            data = getattr(self, 'filter_gsshandle4_t')(data)
        self.pack_opaque(data)

    def pack_gss_cb_handles4(self, data):
        if hasattr(self, 'filter_gss_cb_handles4'):
            data = getattr(self, 'filter_gss_cb_handles4')(data)
        if data.gcbp_service is None:
            raise TypeError('data.gcbp_service == None')
        self.pack_rpc_gss_svc_t(data.gcbp_service)
        if data.gcbp_handle_from_server is None:
            raise TypeError('data.gcbp_handle_from_server == None')
        self.pack_gsshandle4_t(data.gcbp_handle_from_server)
        if data.gcbp_handle_from_client is None:
            raise TypeError('data.gcbp_handle_from_client == None')
        self.pack_gsshandle4_t(data.gcbp_handle_from_client)

    def pack_callback_sec_parms4(self, data):
        if hasattr(self, 'filter_callback_sec_parms4'):
            data = getattr(self, 'filter_callback_sec_parms4')(data)
        if data.cb_secflavor is None:
            raise TypeError('data.cb_secflavor == None')
        self.pack_uint32_t(data.cb_secflavor)
        if data.cb_secflavor == const.AUTH_NONE:
            pass
        elif data.cb_secflavor == const.AUTH_SYS:
            if data.cbsp_sys_cred is None:
                raise TypeError('data.cbsp_sys_cred == None')
            self.pack_authsys_parms(data.cbsp_sys_cred)
        elif data.cb_secflavor == const.RPCSEC_GSS:
            if data.cbsp_gss_handles is None:
                raise TypeError('data.cbsp_gss_handles == None')
            self.pack_gss_cb_handles4(data.cbsp_gss_handles)
        else:
            raise XDRError('bad switch=%s' % data.cb_secflavor)

    def pack_BACKCHANNEL_CTL4args(self, data):
        if hasattr(self, 'filter_BACKCHANNEL_CTL4args'):
            data = getattr(self, 'filter_BACKCHANNEL_CTL4args')(data)
        if data.bca_cb_program is None:
            raise TypeError('data.bca_cb_program == None')
        self.pack_uint32_t(data.bca_cb_program)
        if data.bca_sec_parms is None:
            raise TypeError('data.bca_sec_parms == None')
        self.pack_array(data.bca_sec_parms, self.pack_callback_sec_parms4)

    def pack_BACKCHANNEL_CTL4res(self, data):
        if hasattr(self, 'filter_BACKCHANNEL_CTL4res'):
            data = getattr(self, 'filter_BACKCHANNEL_CTL4res')(data)
        if data.bcr_status is None:
            raise TypeError('data.bcr_status == None')
        self.pack_nfsstat4(data.bcr_status)

    def pack_channel_dir_from_client4(self, data):
        if hasattr(self, 'filter_channel_dir_from_client4'):
            data = getattr(self, 'filter_channel_dir_from_client4')(data)
        if self.check_enum and data not in [const.CDFC4_FORE, const.CDFC4_BACK, const.CDFC4_FORE_OR_BOTH, const.CDFC4_BACK_OR_BOTH]:
            raise XDRError('value=%s not in enum channel_dir_from_client4' % data)
        self.pack_int(data)

    def pack_BIND_CONN_TO_SESSION4args(self, data):
        if hasattr(self, 'filter_BIND_CONN_TO_SESSION4args'):
            data = getattr(self, 'filter_BIND_CONN_TO_SESSION4args')(data)
        if data.bctsa_sessid is None:
            raise TypeError('data.bctsa_sessid == None')
        self.pack_sessionid4(data.bctsa_sessid)
        if data.bctsa_dir is None:
            raise TypeError('data.bctsa_dir == None')
        self.pack_channel_dir_from_client4(data.bctsa_dir)
        if data.bctsa_use_conn_in_rdma_mode is None:
            raise TypeError('data.bctsa_use_conn_in_rdma_mode == None')
        self.pack_bool(data.bctsa_use_conn_in_rdma_mode)

    def pack_channel_dir_from_server4(self, data):
        if hasattr(self, 'filter_channel_dir_from_server4'):
            data = getattr(self, 'filter_channel_dir_from_server4')(data)
        if self.check_enum and data not in [const.CDFS4_FORE, const.CDFS4_BACK, const.CDFS4_BOTH]:
            raise XDRError('value=%s not in enum channel_dir_from_server4' % data)
        self.pack_int(data)

    def pack_BIND_CONN_TO_SESSION4resok(self, data):
        if hasattr(self, 'filter_BIND_CONN_TO_SESSION4resok'):
            data = getattr(self, 'filter_BIND_CONN_TO_SESSION4resok')(data)
        if data.bctsr_sessid is None:
            raise TypeError('data.bctsr_sessid == None')
        self.pack_sessionid4(data.bctsr_sessid)
        if data.bctsr_dir is None:
            raise TypeError('data.bctsr_dir == None')
        self.pack_channel_dir_from_server4(data.bctsr_dir)
        if data.bctsr_use_conn_in_rdma_mode is None:
            raise TypeError('data.bctsr_use_conn_in_rdma_mode == None')
        self.pack_bool(data.bctsr_use_conn_in_rdma_mode)

    def pack_BIND_CONN_TO_SESSION4res(self, data):
        if hasattr(self, 'filter_BIND_CONN_TO_SESSION4res'):
            data = getattr(self, 'filter_BIND_CONN_TO_SESSION4res')(data)
        if data.bctsr_status is None:
            raise TypeError('data.bctsr_status == None')
        self.pack_nfsstat4(data.bctsr_status)
        if data.bctsr_status == const.NFS4_OK:
            if data.bctsr_resok4 is None:
                raise TypeError('data.bctsr_resok4 == None')
            self.pack_BIND_CONN_TO_SESSION4resok(data.bctsr_resok4)
        else:
            pass

    def pack_state_protect_ops4(self, data):
        if hasattr(self, 'filter_state_protect_ops4'):
            data = getattr(self, 'filter_state_protect_ops4')(data)
        if data.spo_must_enforce is None:
            raise TypeError('data.spo_must_enforce == None')
        self.pack_bitmap4(data.spo_must_enforce)
        if data.spo_must_allow is None:
            raise TypeError('data.spo_must_allow == None')
        self.pack_bitmap4(data.spo_must_allow)

    def pack_ssv_sp_parms4(self, data):
        if hasattr(self, 'filter_ssv_sp_parms4'):
            data = getattr(self, 'filter_ssv_sp_parms4')(data)
        if data.ssp_ops is None:
            raise TypeError('data.ssp_ops == None')
        self.pack_state_protect_ops4(data.ssp_ops)
        if data.ssp_hash_algs is None:
            raise TypeError('data.ssp_hash_algs == None')
        self.pack_array(data.ssp_hash_algs, self.pack_sec_oid4)
        if data.ssp_encr_algs is None:
            raise TypeError('data.ssp_encr_algs == None')
        self.pack_array(data.ssp_encr_algs, self.pack_sec_oid4)
        if data.ssp_window is None:
            raise TypeError('data.ssp_window == None')
        self.pack_uint32_t(data.ssp_window)
        if data.ssp_num_gss_handles is None:
            raise TypeError('data.ssp_num_gss_handles == None')
        self.pack_uint32_t(data.ssp_num_gss_handles)

    def pack_state_protect_how4(self, data):
        if hasattr(self, 'filter_state_protect_how4'):
            data = getattr(self, 'filter_state_protect_how4')(data)
        if self.check_enum and data not in [const.SP4_NONE, const.SP4_MACH_CRED, const.SP4_SSV]:
            raise XDRError('value=%s not in enum state_protect_how4' % data)
        self.pack_int(data)

    def pack_state_protect4_a(self, data):
        if hasattr(self, 'filter_state_protect4_a'):
            data = getattr(self, 'filter_state_protect4_a')(data)
        if data.spa_how is None:
            raise TypeError('data.spa_how == None')
        self.pack_state_protect_how4(data.spa_how)
        if data.spa_how == const.SP4_NONE:
            pass
        elif data.spa_how == const.SP4_MACH_CRED:
            if data.spa_mach_ops is None:
                raise TypeError('data.spa_mach_ops == None')
            self.pack_state_protect_ops4(data.spa_mach_ops)
        elif data.spa_how == const.SP4_SSV:
            if data.spa_ssv_parms is None:
                raise TypeError('data.spa_ssv_parms == None')
            self.pack_ssv_sp_parms4(data.spa_ssv_parms)
        else:
            raise XDRError('bad switch=%s' % data.spa_how)

    def pack_EXCHANGE_ID4args(self, data):
        if hasattr(self, 'filter_EXCHANGE_ID4args'):
            data = getattr(self, 'filter_EXCHANGE_ID4args')(data)
        if data.eia_clientowner is None:
            raise TypeError('data.eia_clientowner == None')
        self.pack_client_owner4(data.eia_clientowner)
        if data.eia_flags is None:
            raise TypeError('data.eia_flags == None')
        self.pack_uint32_t(data.eia_flags)
        if data.eia_state_protect is None:
            raise TypeError('data.eia_state_protect == None')
        self.pack_state_protect4_a(data.eia_state_protect)
        if data.eia_client_impl_id is None:
            raise TypeError('data.eia_client_impl_id == None')
        if len(data.eia_client_impl_id) > 1 and self.check_array:
            raise XDRError('array length too long for data.eia_client_impl_id')
        self.pack_array(data.eia_client_impl_id, self.pack_nfs_impl_id4)

    def pack_ssv_prot_info4(self, data):
        if hasattr(self, 'filter_ssv_prot_info4'):
            data = getattr(self, 'filter_ssv_prot_info4')(data)
        if data.spi_ops is None:
            raise TypeError('data.spi_ops == None')
        self.pack_state_protect_ops4(data.spi_ops)
        if data.spi_hash_alg is None:
            raise TypeError('data.spi_hash_alg == None')
        self.pack_uint32_t(data.spi_hash_alg)
        if data.spi_encr_alg is None:
            raise TypeError('data.spi_encr_alg == None')
        self.pack_uint32_t(data.spi_encr_alg)
        if data.spi_ssv_len is None:
            raise TypeError('data.spi_ssv_len == None')
        self.pack_uint32_t(data.spi_ssv_len)
        if data.spi_window is None:
            raise TypeError('data.spi_window == None')
        self.pack_uint32_t(data.spi_window)
        if data.spi_handles is None:
            raise TypeError('data.spi_handles == None')
        self.pack_array(data.spi_handles, self.pack_gsshandle4_t)

    def pack_state_protect4_r(self, data):
        if hasattr(self, 'filter_state_protect4_r'):
            data = getattr(self, 'filter_state_protect4_r')(data)
        if data.spr_how is None:
            raise TypeError('data.spr_how == None')
        self.pack_state_protect_how4(data.spr_how)
        if data.spr_how == const.SP4_NONE:
            pass
        elif data.spr_how == const.SP4_MACH_CRED:
            if data.spr_mach_ops is None:
                raise TypeError('data.spr_mach_ops == None')
            self.pack_state_protect_ops4(data.spr_mach_ops)
        elif data.spr_how == const.SP4_SSV:
            if data.spr_ssv_info is None:
                raise TypeError('data.spr_ssv_info == None')
            self.pack_ssv_prot_info4(data.spr_ssv_info)
        else:
            raise XDRError('bad switch=%s' % data.spr_how)

    def pack_EXCHANGE_ID4resok(self, data):
        if hasattr(self, 'filter_EXCHANGE_ID4resok'):
            data = getattr(self, 'filter_EXCHANGE_ID4resok')(data)
        if data.eir_clientid is None:
            raise TypeError('data.eir_clientid == None')
        self.pack_clientid4(data.eir_clientid)
        if data.eir_sequenceid is None:
            raise TypeError('data.eir_sequenceid == None')
        self.pack_sequenceid4(data.eir_sequenceid)
        if data.eir_flags is None:
            raise TypeError('data.eir_flags == None')
        self.pack_uint32_t(data.eir_flags)
        if data.eir_state_protect is None:
            raise TypeError('data.eir_state_protect == None')
        self.pack_state_protect4_r(data.eir_state_protect)
        if data.eir_server_owner is None:
            raise TypeError('data.eir_server_owner == None')
        self.pack_server_owner4(data.eir_server_owner)
        if data.eir_server_scope is None:
            raise TypeError('data.eir_server_scope == None')
        if len(data.eir_server_scope) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.eir_server_scope')
        self.pack_opaque(data.eir_server_scope)
        if data.eir_server_impl_id is None:
            raise TypeError('data.eir_server_impl_id == None')
        if len(data.eir_server_impl_id) > 1 and self.check_array:
            raise XDRError('array length too long for data.eir_server_impl_id')
        self.pack_array(data.eir_server_impl_id, self.pack_nfs_impl_id4)

    def pack_EXCHANGE_ID4res(self, data):
        if hasattr(self, 'filter_EXCHANGE_ID4res'):
            data = getattr(self, 'filter_EXCHANGE_ID4res')(data)
        if data.eir_status is None:
            raise TypeError('data.eir_status == None')
        self.pack_nfsstat4(data.eir_status)
        if data.eir_status == const.NFS4_OK:
            if data.eir_resok4 is None:
                raise TypeError('data.eir_resok4 == None')
            self.pack_EXCHANGE_ID4resok(data.eir_resok4)
        else:
            pass

    def pack_channel_attrs4(self, data):
        if hasattr(self, 'filter_channel_attrs4'):
            data = getattr(self, 'filter_channel_attrs4')(data)
        if data.ca_headerpadsize is None:
            raise TypeError('data.ca_headerpadsize == None')
        self.pack_count4(data.ca_headerpadsize)
        if data.ca_maxrequestsize is None:
            raise TypeError('data.ca_maxrequestsize == None')
        self.pack_count4(data.ca_maxrequestsize)
        if data.ca_maxresponsesize is None:
            raise TypeError('data.ca_maxresponsesize == None')
        self.pack_count4(data.ca_maxresponsesize)
        if data.ca_maxresponsesize_cached is None:
            raise TypeError('data.ca_maxresponsesize_cached == None')
        self.pack_count4(data.ca_maxresponsesize_cached)
        if data.ca_maxoperations is None:
            raise TypeError('data.ca_maxoperations == None')
        self.pack_count4(data.ca_maxoperations)
        if data.ca_maxrequests is None:
            raise TypeError('data.ca_maxrequests == None')
        self.pack_count4(data.ca_maxrequests)
        if data.ca_rdma_ird is None:
            raise TypeError('data.ca_rdma_ird == None')
        if len(data.ca_rdma_ird) > 1 and self.check_array:
            raise XDRError('array length too long for data.ca_rdma_ird')
        self.pack_array(data.ca_rdma_ird, self.pack_uint32_t)

    def pack_CREATE_SESSION4args(self, data):
        if hasattr(self, 'filter_CREATE_SESSION4args'):
            data = getattr(self, 'filter_CREATE_SESSION4args')(data)
        if data.csa_clientid is None:
            raise TypeError('data.csa_clientid == None')
        self.pack_clientid4(data.csa_clientid)
        if data.csa_sequence is None:
            raise TypeError('data.csa_sequence == None')
        self.pack_sequenceid4(data.csa_sequence)
        if data.csa_flags is None:
            raise TypeError('data.csa_flags == None')
        self.pack_uint32_t(data.csa_flags)
        if data.csa_fore_chan_attrs is None:
            raise TypeError('data.csa_fore_chan_attrs == None')
        self.pack_channel_attrs4(data.csa_fore_chan_attrs)
        if data.csa_back_chan_attrs is None:
            raise TypeError('data.csa_back_chan_attrs == None')
        self.pack_channel_attrs4(data.csa_back_chan_attrs)
        if data.csa_cb_program is None:
            raise TypeError('data.csa_cb_program == None')
        self.pack_uint32_t(data.csa_cb_program)
        if data.csa_sec_parms is None:
            raise TypeError('data.csa_sec_parms == None')
        self.pack_array(data.csa_sec_parms, self.pack_callback_sec_parms4)

    def pack_CREATE_SESSION4resok(self, data):
        if hasattr(self, 'filter_CREATE_SESSION4resok'):
            data = getattr(self, 'filter_CREATE_SESSION4resok')(data)
        if data.csr_sessionid is None:
            raise TypeError('data.csr_sessionid == None')
        self.pack_sessionid4(data.csr_sessionid)
        if data.csr_sequence is None:
            raise TypeError('data.csr_sequence == None')
        self.pack_sequenceid4(data.csr_sequence)
        if data.csr_flags is None:
            raise TypeError('data.csr_flags == None')
        self.pack_uint32_t(data.csr_flags)
        if data.csr_fore_chan_attrs is None:
            raise TypeError('data.csr_fore_chan_attrs == None')
        self.pack_channel_attrs4(data.csr_fore_chan_attrs)
        if data.csr_back_chan_attrs is None:
            raise TypeError('data.csr_back_chan_attrs == None')
        self.pack_channel_attrs4(data.csr_back_chan_attrs)

    def pack_CREATE_SESSION4res(self, data):
        if hasattr(self, 'filter_CREATE_SESSION4res'):
            data = getattr(self, 'filter_CREATE_SESSION4res')(data)
        if data.csr_status is None:
            raise TypeError('data.csr_status == None')
        self.pack_nfsstat4(data.csr_status)
        if data.csr_status == const.NFS4_OK:
            if data.csr_resok4 is None:
                raise TypeError('data.csr_resok4 == None')
            self.pack_CREATE_SESSION4resok(data.csr_resok4)
        else:
            pass

    def pack_DESTROY_SESSION4args(self, data):
        if hasattr(self, 'filter_DESTROY_SESSION4args'):
            data = getattr(self, 'filter_DESTROY_SESSION4args')(data)
        if data.dsa_sessionid is None:
            raise TypeError('data.dsa_sessionid == None')
        self.pack_sessionid4(data.dsa_sessionid)

    def pack_DESTROY_SESSION4res(self, data):
        if hasattr(self, 'filter_DESTROY_SESSION4res'):
            data = getattr(self, 'filter_DESTROY_SESSION4res')(data)
        if data.dsr_status is None:
            raise TypeError('data.dsr_status == None')
        self.pack_nfsstat4(data.dsr_status)

    def pack_FREE_STATEID4args(self, data):
        if hasattr(self, 'filter_FREE_STATEID4args'):
            data = getattr(self, 'filter_FREE_STATEID4args')(data)
        if data.fsa_stateid is None:
            raise TypeError('data.fsa_stateid == None')
        self.pack_stateid4(data.fsa_stateid)

    def pack_FREE_STATEID4res(self, data):
        if hasattr(self, 'filter_FREE_STATEID4res'):
            data = getattr(self, 'filter_FREE_STATEID4res')(data)
        if data.fsr_status is None:
            raise TypeError('data.fsr_status == None')
        self.pack_nfsstat4(data.fsr_status)

    pack_attr_notice4 = pack_nfstime4

    def pack_GET_DIR_DELEGATION4args(self, data):
        if hasattr(self, 'filter_GET_DIR_DELEGATION4args'):
            data = getattr(self, 'filter_GET_DIR_DELEGATION4args')(data)
        if data.gdda_signal_deleg_avail is None:
            raise TypeError('data.gdda_signal_deleg_avail == None')
        self.pack_bool(data.gdda_signal_deleg_avail)
        if data.gdda_notification_types is None:
            raise TypeError('data.gdda_notification_types == None')
        self.pack_bitmap4(data.gdda_notification_types)
        if data.gdda_child_attr_delay is None:
            raise TypeError('data.gdda_child_attr_delay == None')
        self.pack_attr_notice4(data.gdda_child_attr_delay)
        if data.gdda_dir_attr_delay is None:
            raise TypeError('data.gdda_dir_attr_delay == None')
        self.pack_attr_notice4(data.gdda_dir_attr_delay)
        if data.gdda_child_attributes is None:
            raise TypeError('data.gdda_child_attributes == None')
        self.pack_bitmap4(data.gdda_child_attributes)
        if data.gdda_dir_attributes is None:
            raise TypeError('data.gdda_dir_attributes == None')
        self.pack_bitmap4(data.gdda_dir_attributes)

    def pack_GET_DIR_DELEGATION4resok(self, data):
        if hasattr(self, 'filter_GET_DIR_DELEGATION4resok'):
            data = getattr(self, 'filter_GET_DIR_DELEGATION4resok')(data)
        if data.gddr_cookieverf is None:
            raise TypeError('data.gddr_cookieverf == None')
        self.pack_verifier4(data.gddr_cookieverf)
        if data.gddr_stateid is None:
            raise TypeError('data.gddr_stateid == None')
        self.pack_stateid4(data.gddr_stateid)
        if data.gddr_notification is None:
            raise TypeError('data.gddr_notification == None')
        self.pack_bitmap4(data.gddr_notification)
        if data.gddr_child_attributes is None:
            raise TypeError('data.gddr_child_attributes == None')
        self.pack_bitmap4(data.gddr_child_attributes)
        if data.gddr_dir_attributes is None:
            raise TypeError('data.gddr_dir_attributes == None')
        self.pack_bitmap4(data.gddr_dir_attributes)

    def pack_gddrnf4_status(self, data):
        if hasattr(self, 'filter_gddrnf4_status'):
            data = getattr(self, 'filter_gddrnf4_status')(data)
        if self.check_enum and data not in [const.GDD4_OK, const.GDD4_UNAVAIL]:
            raise XDRError('value=%s not in enum gddrnf4_status' % data)
        self.pack_int(data)

    def pack_GET_DIR_DELEGATION4res_non_fatal(self, data):
        if hasattr(self, 'filter_GET_DIR_DELEGATION4res_non_fatal'):
            data = getattr(self, 'filter_GET_DIR_DELEGATION4res_non_fatal')(data)
        if data.gddrnf_status is None:
            raise TypeError('data.gddrnf_status == None')
        self.pack_gddrnf4_status(data.gddrnf_status)
        if data.gddrnf_status == const.GDD4_OK:
            if data.gddrnf_resok4 is None:
                raise TypeError('data.gddrnf_resok4 == None')
            self.pack_GET_DIR_DELEGATION4resok(data.gddrnf_resok4)
        elif data.gddrnf_status == const.GDD4_UNAVAIL:
            if data.gddrnf_will_signal_deleg_avail is None:
                raise TypeError('data.gddrnf_will_signal_deleg_avail == None')
            self.pack_bool(data.gddrnf_will_signal_deleg_avail)
        else:
            raise XDRError('bad switch=%s' % data.gddrnf_status)

    def pack_GET_DIR_DELEGATION4res(self, data):
        if hasattr(self, 'filter_GET_DIR_DELEGATION4res'):
            data = getattr(self, 'filter_GET_DIR_DELEGATION4res')(data)
        if data.gddr_status is None:
            raise TypeError('data.gddr_status == None')
        self.pack_nfsstat4(data.gddr_status)
        if data.gddr_status == const.NFS4_OK:
            if data.gddr_res_non_fatal4 is None:
                raise TypeError('data.gddr_res_non_fatal4 == None')
            self.pack_GET_DIR_DELEGATION4res_non_fatal(data.gddr_res_non_fatal4)
        else:
            pass

    def pack_GETDEVICEINFO4args(self, data):
        if hasattr(self, 'filter_GETDEVICEINFO4args'):
            data = getattr(self, 'filter_GETDEVICEINFO4args')(data)
        if data.gdia_device_id is None:
            raise TypeError('data.gdia_device_id == None')
        self.pack_deviceid4(data.gdia_device_id)
        if data.gdia_layout_type is None:
            raise TypeError('data.gdia_layout_type == None')
        self.pack_layouttype4(data.gdia_layout_type)
        if data.gdia_maxcount is None:
            raise TypeError('data.gdia_maxcount == None')
        self.pack_count4(data.gdia_maxcount)
        if data.gdia_notify_types is None:
            raise TypeError('data.gdia_notify_types == None')
        self.pack_bitmap4(data.gdia_notify_types)

    def pack_GETDEVICEINFO4resok(self, data):
        if hasattr(self, 'filter_GETDEVICEINFO4resok'):
            data = getattr(self, 'filter_GETDEVICEINFO4resok')(data)
        if data.gdir_device_addr is None:
            raise TypeError('data.gdir_device_addr == None')
        self.pack_device_addr4(data.gdir_device_addr)
        if data.gdir_notification is None:
            raise TypeError('data.gdir_notification == None')
        self.pack_bitmap4(data.gdir_notification)

    def pack_GETDEVICEINFO4res(self, data):
        if hasattr(self, 'filter_GETDEVICEINFO4res'):
            data = getattr(self, 'filter_GETDEVICEINFO4res')(data)
        if data.gdir_status is None:
            raise TypeError('data.gdir_status == None')
        self.pack_nfsstat4(data.gdir_status)
        if data.gdir_status == const.NFS4_OK:
            if data.gdir_resok4 is None:
                raise TypeError('data.gdir_resok4 == None')
            self.pack_GETDEVICEINFO4resok(data.gdir_resok4)
        elif data.gdir_status == const.NFS4ERR_TOOSMALL:
            if data.gdir_mincount is None:
                raise TypeError('data.gdir_mincount == None')
            self.pack_count4(data.gdir_mincount)
        else:
            pass

    def pack_GETDEVICELIST4args(self, data):
        if hasattr(self, 'filter_GETDEVICELIST4args'):
            data = getattr(self, 'filter_GETDEVICELIST4args')(data)
        if data.gdla_layout_type is None:
            raise TypeError('data.gdla_layout_type == None')
        self.pack_layouttype4(data.gdla_layout_type)
        if data.gdla_maxdevices is None:
            raise TypeError('data.gdla_maxdevices == None')
        self.pack_count4(data.gdla_maxdevices)
        if data.gdla_cookie is None:
            raise TypeError('data.gdla_cookie == None')
        self.pack_nfs_cookie4(data.gdla_cookie)
        if data.gdla_cookieverf is None:
            raise TypeError('data.gdla_cookieverf == None')
        self.pack_verifier4(data.gdla_cookieverf)

    def pack_GETDEVICELIST4resok(self, data):
        if hasattr(self, 'filter_GETDEVICELIST4resok'):
            data = getattr(self, 'filter_GETDEVICELIST4resok')(data)
        if data.gdlr_cookie is None:
            raise TypeError('data.gdlr_cookie == None')
        self.pack_nfs_cookie4(data.gdlr_cookie)
        if data.gdlr_cookieverf is None:
            raise TypeError('data.gdlr_cookieverf == None')
        self.pack_verifier4(data.gdlr_cookieverf)
        if data.gdlr_deviceid_list is None:
            raise TypeError('data.gdlr_deviceid_list == None')
        self.pack_array(data.gdlr_deviceid_list, self.pack_deviceid4)
        if data.gdlr_eof is None:
            raise TypeError('data.gdlr_eof == None')
        self.pack_bool(data.gdlr_eof)

    def pack_GETDEVICELIST4res(self, data):
        if hasattr(self, 'filter_GETDEVICELIST4res'):
            data = getattr(self, 'filter_GETDEVICELIST4res')(data)
        if data.gdlr_status is None:
            raise TypeError('data.gdlr_status == None')
        self.pack_nfsstat4(data.gdlr_status)
        if data.gdlr_status == const.NFS4_OK:
            if data.gdlr_resok4 is None:
                raise TypeError('data.gdlr_resok4 == None')
            self.pack_GETDEVICELIST4resok(data.gdlr_resok4)
        else:
            pass

    def pack_newtime4(self, data):
        if hasattr(self, 'filter_newtime4'):
            data = getattr(self, 'filter_newtime4')(data)
        if data.nt_timechanged is None:
            raise TypeError('data.nt_timechanged == None')
        self.pack_bool(data.nt_timechanged)
        if data.nt_timechanged == const.TRUE:
            if data.nt_time is None:
                raise TypeError('data.nt_time == None')
            self.pack_nfstime4(data.nt_time)
        elif data.nt_timechanged == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.nt_timechanged)

    def pack_newoffset4(self, data):
        if hasattr(self, 'filter_newoffset4'):
            data = getattr(self, 'filter_newoffset4')(data)
        if data.no_newoffset is None:
            raise TypeError('data.no_newoffset == None')
        self.pack_bool(data.no_newoffset)
        if data.no_newoffset == const.TRUE:
            if data.no_offset is None:
                raise TypeError('data.no_offset == None')
            self.pack_offset4(data.no_offset)
        elif data.no_newoffset == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.no_newoffset)

    def pack_LAYOUTCOMMIT4args(self, data):
        if hasattr(self, 'filter_LAYOUTCOMMIT4args'):
            data = getattr(self, 'filter_LAYOUTCOMMIT4args')(data)
        if data.loca_offset is None:
            raise TypeError('data.loca_offset == None')
        self.pack_offset4(data.loca_offset)
        if data.loca_length is None:
            raise TypeError('data.loca_length == None')
        self.pack_length4(data.loca_length)
        if data.loca_reclaim is None:
            raise TypeError('data.loca_reclaim == None')
        self.pack_bool(data.loca_reclaim)
        if data.loca_stateid is None:
            raise TypeError('data.loca_stateid == None')
        self.pack_stateid4(data.loca_stateid)
        if data.loca_last_write_offset is None:
            raise TypeError('data.loca_last_write_offset == None')
        self.pack_newoffset4(data.loca_last_write_offset)
        if data.loca_time_modify is None:
            raise TypeError('data.loca_time_modify == None')
        self.pack_newtime4(data.loca_time_modify)
        if data.loca_layoutupdate is None:
            raise TypeError('data.loca_layoutupdate == None')
        self.pack_layoutupdate4(data.loca_layoutupdate)

    def pack_newsize4(self, data):
        if hasattr(self, 'filter_newsize4'):
            data = getattr(self, 'filter_newsize4')(data)
        if data.ns_sizechanged is None:
            raise TypeError('data.ns_sizechanged == None')
        self.pack_bool(data.ns_sizechanged)
        if data.ns_sizechanged == const.TRUE:
            if data.ns_size is None:
                raise TypeError('data.ns_size == None')
            self.pack_length4(data.ns_size)
        elif data.ns_sizechanged == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.ns_sizechanged)

    def pack_LAYOUTCOMMIT4resok(self, data):
        if hasattr(self, 'filter_LAYOUTCOMMIT4resok'):
            data = getattr(self, 'filter_LAYOUTCOMMIT4resok')(data)
        if data.locr_newsize is None:
            raise TypeError('data.locr_newsize == None')
        self.pack_newsize4(data.locr_newsize)

    def pack_LAYOUTCOMMIT4res(self, data):
        if hasattr(self, 'filter_LAYOUTCOMMIT4res'):
            data = getattr(self, 'filter_LAYOUTCOMMIT4res')(data)
        if data.locr_status is None:
            raise TypeError('data.locr_status == None')
        self.pack_nfsstat4(data.locr_status)
        if data.locr_status == const.NFS4_OK:
            if data.locr_resok4 is None:
                raise TypeError('data.locr_resok4 == None')
            self.pack_LAYOUTCOMMIT4resok(data.locr_resok4)
        else:
            pass

    def pack_LAYOUTGET4args(self, data):
        if hasattr(self, 'filter_LAYOUTGET4args'):
            data = getattr(self, 'filter_LAYOUTGET4args')(data)
        if data.loga_signal_layout_avail is None:
            raise TypeError('data.loga_signal_layout_avail == None')
        self.pack_bool(data.loga_signal_layout_avail)
        if data.loga_layout_type is None:
            raise TypeError('data.loga_layout_type == None')
        self.pack_layouttype4(data.loga_layout_type)
        if data.loga_iomode is None:
            raise TypeError('data.loga_iomode == None')
        self.pack_layoutiomode4(data.loga_iomode)
        if data.loga_offset is None:
            raise TypeError('data.loga_offset == None')
        self.pack_offset4(data.loga_offset)
        if data.loga_length is None:
            raise TypeError('data.loga_length == None')
        self.pack_length4(data.loga_length)
        if data.loga_minlength is None:
            raise TypeError('data.loga_minlength == None')
        self.pack_length4(data.loga_minlength)
        if data.loga_stateid is None:
            raise TypeError('data.loga_stateid == None')
        self.pack_stateid4(data.loga_stateid)
        if data.loga_maxcount is None:
            raise TypeError('data.loga_maxcount == None')
        self.pack_count4(data.loga_maxcount)

    def pack_LAYOUTGET4resok(self, data):
        if hasattr(self, 'filter_LAYOUTGET4resok'):
            data = getattr(self, 'filter_LAYOUTGET4resok')(data)
        if data.logr_return_on_close is None:
            raise TypeError('data.logr_return_on_close == None')
        self.pack_bool(data.logr_return_on_close)
        if data.logr_stateid is None:
            raise TypeError('data.logr_stateid == None')
        self.pack_stateid4(data.logr_stateid)
        if data.logr_layout is None:
            raise TypeError('data.logr_layout == None')
        self.pack_array(data.logr_layout, self.pack_layout4)

    def pack_LAYOUTGET4res(self, data):
        if hasattr(self, 'filter_LAYOUTGET4res'):
            data = getattr(self, 'filter_LAYOUTGET4res')(data)
        if data.logr_status is None:
            raise TypeError('data.logr_status == None')
        self.pack_nfsstat4(data.logr_status)
        if data.logr_status == const.NFS4_OK:
            if data.logr_resok4 is None:
                raise TypeError('data.logr_resok4 == None')
            self.pack_LAYOUTGET4resok(data.logr_resok4)
        elif data.logr_status == const.NFS4ERR_LAYOUTTRYLATER:
            if data.logr_will_signal_layout_avail is None:
                raise TypeError('data.logr_will_signal_layout_avail == None')
            self.pack_bool(data.logr_will_signal_layout_avail)
        else:
            pass

    def pack_LAYOUTRETURN4args(self, data):
        if hasattr(self, 'filter_LAYOUTRETURN4args'):
            data = getattr(self, 'filter_LAYOUTRETURN4args')(data)
        if data.lora_reclaim is None:
            raise TypeError('data.lora_reclaim == None')
        self.pack_bool(data.lora_reclaim)
        if data.lora_layout_type is None:
            raise TypeError('data.lora_layout_type == None')
        self.pack_layouttype4(data.lora_layout_type)
        if data.lora_iomode is None:
            raise TypeError('data.lora_iomode == None')
        self.pack_layoutiomode4(data.lora_iomode)
        if data.lora_layoutreturn is None:
            raise TypeError('data.lora_layoutreturn == None')
        self.pack_layoutreturn4(data.lora_layoutreturn)

    def pack_layoutreturn_stateid(self, data):
        if hasattr(self, 'filter_layoutreturn_stateid'):
            data = getattr(self, 'filter_layoutreturn_stateid')(data)
        if data.lrs_present is None:
            raise TypeError('data.lrs_present == None')
        self.pack_bool(data.lrs_present)
        if data.lrs_present == const.TRUE:
            if data.lrs_stateid is None:
                raise TypeError('data.lrs_stateid == None')
            self.pack_stateid4(data.lrs_stateid)
        elif data.lrs_present == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.lrs_present)

    def pack_LAYOUTRETURN4res(self, data):
        if hasattr(self, 'filter_LAYOUTRETURN4res'):
            data = getattr(self, 'filter_LAYOUTRETURN4res')(data)
        if data.lorr_status is None:
            raise TypeError('data.lorr_status == None')
        self.pack_nfsstat4(data.lorr_status)
        if data.lorr_status == const.NFS4_OK:
            if data.lorr_stateid is None:
                raise TypeError('data.lorr_stateid == None')
            self.pack_layoutreturn_stateid(data.lorr_stateid)
        else:
            pass

    def pack_secinfo_style4(self, data):
        if hasattr(self, 'filter_secinfo_style4'):
            data = getattr(self, 'filter_secinfo_style4')(data)
        if self.check_enum and data not in [const.SECINFO_STYLE4_CURRENT_FH, const.SECINFO_STYLE4_PARENT]:
            raise XDRError('value=%s not in enum secinfo_style4' % data)
        self.pack_int(data)

    pack_SECINFO_NO_NAME4args = pack_secinfo_style4

    pack_SECINFO_NO_NAME4res = pack_SECINFO4res

    def pack_SEQUENCE4args(self, data):
        if hasattr(self, 'filter_SEQUENCE4args'):
            data = getattr(self, 'filter_SEQUENCE4args')(data)
        if data.sa_sessionid is None:
            raise TypeError('data.sa_sessionid == None')
        self.pack_sessionid4(data.sa_sessionid)
        if data.sa_sequenceid is None:
            raise TypeError('data.sa_sequenceid == None')
        self.pack_sequenceid4(data.sa_sequenceid)
        if data.sa_slotid is None:
            raise TypeError('data.sa_slotid == None')
        self.pack_slotid4(data.sa_slotid)
        if data.sa_highest_slotid is None:
            raise TypeError('data.sa_highest_slotid == None')
        self.pack_slotid4(data.sa_highest_slotid)
        if data.sa_cachethis is None:
            raise TypeError('data.sa_cachethis == None')
        self.pack_bool(data.sa_cachethis)

    def pack_SEQUENCE4resok(self, data):
        if hasattr(self, 'filter_SEQUENCE4resok'):
            data = getattr(self, 'filter_SEQUENCE4resok')(data)
        if data.sr_sessionid is None:
            raise TypeError('data.sr_sessionid == None')
        self.pack_sessionid4(data.sr_sessionid)
        if data.sr_sequenceid is None:
            raise TypeError('data.sr_sequenceid == None')
        self.pack_sequenceid4(data.sr_sequenceid)
        if data.sr_slotid is None:
            raise TypeError('data.sr_slotid == None')
        self.pack_slotid4(data.sr_slotid)
        if data.sr_highest_slotid is None:
            raise TypeError('data.sr_highest_slotid == None')
        self.pack_slotid4(data.sr_highest_slotid)
        if data.sr_target_highest_slotid is None:
            raise TypeError('data.sr_target_highest_slotid == None')
        self.pack_slotid4(data.sr_target_highest_slotid)
        if data.sr_status_flags is None:
            raise TypeError('data.sr_status_flags == None')
        self.pack_uint32_t(data.sr_status_flags)

    def pack_SEQUENCE4res(self, data):
        if hasattr(self, 'filter_SEQUENCE4res'):
            data = getattr(self, 'filter_SEQUENCE4res')(data)
        if data.sr_status is None:
            raise TypeError('data.sr_status == None')
        self.pack_nfsstat4(data.sr_status)
        if data.sr_status == const.NFS4_OK:
            if data.sr_resok4 is None:
                raise TypeError('data.sr_resok4 == None')
            self.pack_SEQUENCE4resok(data.sr_resok4)
        else:
            pass

    def pack_ssa_digest_input4(self, data):
        if hasattr(self, 'filter_ssa_digest_input4'):
            data = getattr(self, 'filter_ssa_digest_input4')(data)
        if data.sdi_seqargs is None:
            raise TypeError('data.sdi_seqargs == None')
        self.pack_SEQUENCE4args(data.sdi_seqargs)

    def pack_SET_SSV4args(self, data):
        if hasattr(self, 'filter_SET_SSV4args'):
            data = getattr(self, 'filter_SET_SSV4args')(data)
        if data.ssa_ssv is None:
            raise TypeError('data.ssa_ssv == None')
        self.pack_opaque(data.ssa_ssv)
        if data.ssa_digest is None:
            raise TypeError('data.ssa_digest == None')
        self.pack_opaque(data.ssa_digest)

    def pack_ssr_digest_input4(self, data):
        if hasattr(self, 'filter_ssr_digest_input4'):
            data = getattr(self, 'filter_ssr_digest_input4')(data)
        if data.sdi_seqres is None:
            raise TypeError('data.sdi_seqres == None')
        self.pack_SEQUENCE4res(data.sdi_seqres)

    def pack_SET_SSV4resok(self, data):
        if hasattr(self, 'filter_SET_SSV4resok'):
            data = getattr(self, 'filter_SET_SSV4resok')(data)
        if data.ssr_digest is None:
            raise TypeError('data.ssr_digest == None')
        self.pack_opaque(data.ssr_digest)

    def pack_SET_SSV4res(self, data):
        if hasattr(self, 'filter_SET_SSV4res'):
            data = getattr(self, 'filter_SET_SSV4res')(data)
        if data.ssr_status is None:
            raise TypeError('data.ssr_status == None')
        self.pack_nfsstat4(data.ssr_status)
        if data.ssr_status == const.NFS4_OK:
            if data.ssr_resok4 is None:
                raise TypeError('data.ssr_resok4 == None')
            self.pack_SET_SSV4resok(data.ssr_resok4)
        else:
            pass

    def pack_TEST_STATEID4args(self, data):
        if hasattr(self, 'filter_TEST_STATEID4args'):
            data = getattr(self, 'filter_TEST_STATEID4args')(data)
        if data.ts_stateids is None:
            raise TypeError('data.ts_stateids == None')
        self.pack_array(data.ts_stateids, self.pack_stateid4)

    def pack_TEST_STATEID4resok(self, data):
        if hasattr(self, 'filter_TEST_STATEID4resok'):
            data = getattr(self, 'filter_TEST_STATEID4resok')(data)
        if data.tsr_status_codes is None:
            raise TypeError('data.tsr_status_codes == None')
        self.pack_array(data.tsr_status_codes, self.pack_nfsstat4)

    def pack_TEST_STATEID4res(self, data):
        if hasattr(self, 'filter_TEST_STATEID4res'):
            data = getattr(self, 'filter_TEST_STATEID4res')(data)
        if data.tsr_status is None:
            raise TypeError('data.tsr_status == None')
        self.pack_nfsstat4(data.tsr_status)
        if data.tsr_status == const.NFS4_OK:
            if data.tsr_resok4 is None:
                raise TypeError('data.tsr_resok4 == None')
            self.pack_TEST_STATEID4resok(data.tsr_resok4)
        else:
            pass

    def pack_deleg_claim4(self, data):
        if hasattr(self, 'filter_deleg_claim4'):
            data = getattr(self, 'filter_deleg_claim4')(data)
        if data.dc_claim is None:
            raise TypeError('data.dc_claim == None')
        self.pack_open_claim_type4(data.dc_claim)
        if data.dc_claim == const.CLAIM_FH:
            pass
        elif data.dc_claim == const.CLAIM_DELEG_PREV_FH:
            pass
        elif data.dc_claim == const.CLAIM_PREVIOUS:
            if data.dc_delegate_type is None:
                raise TypeError('data.dc_delegate_type == None')
            self.pack_open_delegation_type4(data.dc_delegate_type)
        else:
            raise XDRError('bad switch=%s' % data.dc_claim)

    def pack_WANT_DELEGATION4args(self, data):
        if hasattr(self, 'filter_WANT_DELEGATION4args'):
            data = getattr(self, 'filter_WANT_DELEGATION4args')(data)
        if data.wda_want is None:
            raise TypeError('data.wda_want == None')
        self.pack_uint32_t(data.wda_want)
        if data.wda_claim is None:
            raise TypeError('data.wda_claim == None')
        self.pack_deleg_claim4(data.wda_claim)

    def pack_WANT_DELEGATION4res(self, data):
        if hasattr(self, 'filter_WANT_DELEGATION4res'):
            data = getattr(self, 'filter_WANT_DELEGATION4res')(data)
        if data.wdr_status is None:
            raise TypeError('data.wdr_status == None')
        self.pack_nfsstat4(data.wdr_status)
        if data.wdr_status == const.NFS4_OK:
            if data.wdr_resok4 is None:
                raise TypeError('data.wdr_resok4 == None')
            self.pack_open_delegation4(data.wdr_resok4)
        else:
            pass

    def pack_DESTROY_CLIENTID4args(self, data):
        if hasattr(self, 'filter_DESTROY_CLIENTID4args'):
            data = getattr(self, 'filter_DESTROY_CLIENTID4args')(data)
        if data.dca_clientid is None:
            raise TypeError('data.dca_clientid == None')
        self.pack_clientid4(data.dca_clientid)

    def pack_DESTROY_CLIENTID4res(self, data):
        if hasattr(self, 'filter_DESTROY_CLIENTID4res'):
            data = getattr(self, 'filter_DESTROY_CLIENTID4res')(data)
        if data.dcr_status is None:
            raise TypeError('data.dcr_status == None')
        self.pack_nfsstat4(data.dcr_status)

    def pack_RECLAIM_COMPLETE4args(self, data):
        if hasattr(self, 'filter_RECLAIM_COMPLETE4args'):
            data = getattr(self, 'filter_RECLAIM_COMPLETE4args')(data)
        if data.rca_one_fs is None:
            raise TypeError('data.rca_one_fs == None')
        self.pack_bool(data.rca_one_fs)

    def pack_RECLAIM_COMPLETE4res(self, data):
        if hasattr(self, 'filter_RECLAIM_COMPLETE4res'):
            data = getattr(self, 'filter_RECLAIM_COMPLETE4res')(data)
        if data.rcr_status is None:
            raise TypeError('data.rcr_status == None')
        self.pack_nfsstat4(data.rcr_status)

    def pack_COPY4args(self, data):
        if hasattr(self, 'filter_COPY4args'):
            data = getattr(self, 'filter_COPY4args')(data)
        if data.ca_src_stateid is None:
            raise TypeError('data.ca_src_stateid == None')
        self.pack_stateid4(data.ca_src_stateid)
        if data.ca_dst_stateid is None:
            raise TypeError('data.ca_dst_stateid == None')
        self.pack_stateid4(data.ca_dst_stateid)
        if data.ca_src_offset is None:
            raise TypeError('data.ca_src_offset == None')
        self.pack_offset4(data.ca_src_offset)
        if data.ca_dst_offset is None:
            raise TypeError('data.ca_dst_offset == None')
        self.pack_offset4(data.ca_dst_offset)
        if data.ca_count is None:
            raise TypeError('data.ca_count == None')
        self.pack_length4(data.ca_count)
        if data.ca_consecutive is None:
            raise TypeError('data.ca_consecutive == None')
        self.pack_bool(data.ca_consecutive)
        if data.ca_synchronous is None:
            raise TypeError('data.ca_synchronous == None')
        self.pack_bool(data.ca_synchronous)
        if data.ca_source_server is None:
            raise TypeError('data.ca_source_server == None')
        self.pack_array(data.ca_source_server, self.pack_netloc4)

    def pack_copy_requirements4(self, data):
        if hasattr(self, 'filter_copy_requirements4'):
            data = getattr(self, 'filter_copy_requirements4')(data)
        if data.cr_consecutive is None:
            raise TypeError('data.cr_consecutive == None')
        self.pack_bool(data.cr_consecutive)
        if data.cr_synchronous is None:
            raise TypeError('data.cr_synchronous == None')
        self.pack_bool(data.cr_synchronous)

    def pack_COPY4resok(self, data):
        if hasattr(self, 'filter_COPY4resok'):
            data = getattr(self, 'filter_COPY4resok')(data)
        if data.cr_response is None:
            raise TypeError('data.cr_response == None')
        self.pack_write_response4(data.cr_response)
        if data.cr_requirements is None:
            raise TypeError('data.cr_requirements == None')
        self.pack_copy_requirements4(data.cr_requirements)

    def pack_COPY4res(self, data):
        if hasattr(self, 'filter_COPY4res'):
            data = getattr(self, 'filter_COPY4res')(data)
        if data.cr_status is None:
            raise TypeError('data.cr_status == None')
        self.pack_nfsstat4(data.cr_status)
        if data.cr_status == const.NFS4_OK:
            if data.cr_resok4 is None:
                raise TypeError('data.cr_resok4 == None')
            self.pack_COPY4resok(data.cr_resok4)
        elif data.cr_status == const.NFS4ERR_OFFLOAD_NO_REQS:
            if data.cr_requirements is None:
                raise TypeError('data.cr_requirements == None')
            self.pack_copy_requirements4(data.cr_requirements)
        else:
            pass

    def pack_COPY_NOTIFY4args(self, data):
        if hasattr(self, 'filter_COPY_NOTIFY4args'):
            data = getattr(self, 'filter_COPY_NOTIFY4args')(data)
        if data.cna_src_stateid is None:
            raise TypeError('data.cna_src_stateid == None')
        self.pack_stateid4(data.cna_src_stateid)
        if data.cna_destination_server is None:
            raise TypeError('data.cna_destination_server == None')
        self.pack_netloc4(data.cna_destination_server)

    def pack_COPY_NOTIFY4resok(self, data):
        if hasattr(self, 'filter_COPY_NOTIFY4resok'):
            data = getattr(self, 'filter_COPY_NOTIFY4resok')(data)
        if data.cnr_lease_time is None:
            raise TypeError('data.cnr_lease_time == None')
        self.pack_nfstime4(data.cnr_lease_time)
        if data.cnr_stateid is None:
            raise TypeError('data.cnr_stateid == None')
        self.pack_stateid4(data.cnr_stateid)
        if data.cnr_source_server is None:
            raise TypeError('data.cnr_source_server == None')
        self.pack_array(data.cnr_source_server, self.pack_netloc4)

    def pack_COPY_NOTIFY4res(self, data):
        if hasattr(self, 'filter_COPY_NOTIFY4res'):
            data = getattr(self, 'filter_COPY_NOTIFY4res')(data)
        if data.cnr_status is None:
            raise TypeError('data.cnr_status == None')
        self.pack_nfsstat4(data.cnr_status)
        if data.cnr_status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_COPY_NOTIFY4resok(data.resok4)
        else:
            pass

    def pack_OFFLOAD_CANCEL4args(self, data):
        if hasattr(self, 'filter_OFFLOAD_CANCEL4args'):
            data = getattr(self, 'filter_OFFLOAD_CANCEL4args')(data)
        if data.oca_stateid is None:
            raise TypeError('data.oca_stateid == None')
        self.pack_stateid4(data.oca_stateid)

    def pack_OFFLOAD_CANCEL4res(self, data):
        if hasattr(self, 'filter_OFFLOAD_CANCEL4res'):
            data = getattr(self, 'filter_OFFLOAD_CANCEL4res')(data)
        if data.ocr_status is None:
            raise TypeError('data.ocr_status == None')
        self.pack_nfsstat4(data.ocr_status)

    def pack_OFFLOAD_STATUS4args(self, data):
        if hasattr(self, 'filter_OFFLOAD_STATUS4args'):
            data = getattr(self, 'filter_OFFLOAD_STATUS4args')(data)
        if data.osa_stateid is None:
            raise TypeError('data.osa_stateid == None')
        self.pack_stateid4(data.osa_stateid)

    def pack_OFFLOAD_STATUS4resok(self, data):
        if hasattr(self, 'filter_OFFLOAD_STATUS4resok'):
            data = getattr(self, 'filter_OFFLOAD_STATUS4resok')(data)
        if data.osr_count is None:
            raise TypeError('data.osr_count == None')
        self.pack_length4(data.osr_count)
        if data.osr_complete is None:
            raise TypeError('data.osr_complete == None')
        if len(data.osr_complete) > 1 and self.check_array:
            raise XDRError('array length too long for data.osr_complete')
        self.pack_array(data.osr_complete, self.pack_nfsstat4)

    def pack_OFFLOAD_STATUS4res(self, data):
        if hasattr(self, 'filter_OFFLOAD_STATUS4res'):
            data = getattr(self, 'filter_OFFLOAD_STATUS4res')(data)
        if data.osr_status is None:
            raise TypeError('data.osr_status == None')
        self.pack_nfsstat4(data.osr_status)
        if data.osr_status == const.NFS4_OK:
            if data.osr_resok4 is None:
                raise TypeError('data.osr_resok4 == None')
            self.pack_OFFLOAD_STATUS4resok(data.osr_resok4)
        else:
            pass

    def pack_ALLOCATE4args(self, data):
        if hasattr(self, 'filter_ALLOCATE4args'):
            data = getattr(self, 'filter_ALLOCATE4args')(data)
        if data.aa_stateid is None:
            raise TypeError('data.aa_stateid == None')
        self.pack_stateid4(data.aa_stateid)
        if data.aa_offset is None:
            raise TypeError('data.aa_offset == None')
        self.pack_offset4(data.aa_offset)
        if data.aa_length is None:
            raise TypeError('data.aa_length == None')
        self.pack_length4(data.aa_length)

    def pack_ALLOCATE4res(self, data):
        if hasattr(self, 'filter_ALLOCATE4res'):
            data = getattr(self, 'filter_ALLOCATE4res')(data)
        if data.ar_status is None:
            raise TypeError('data.ar_status == None')
        self.pack_nfsstat4(data.ar_status)

    def pack_DEALLOCATE4args(self, data):
        if hasattr(self, 'filter_DEALLOCATE4args'):
            data = getattr(self, 'filter_DEALLOCATE4args')(data)
        if data.da_stateid is None:
            raise TypeError('data.da_stateid == None')
        self.pack_stateid4(data.da_stateid)
        if data.da_offset is None:
            raise TypeError('data.da_offset == None')
        self.pack_offset4(data.da_offset)
        if data.da_length is None:
            raise TypeError('data.da_length == None')
        self.pack_length4(data.da_length)

    def pack_DEALLOCATE4res(self, data):
        if hasattr(self, 'filter_DEALLOCATE4res'):
            data = getattr(self, 'filter_DEALLOCATE4res')(data)
        if data.dr_status is None:
            raise TypeError('data.dr_status == None')
        self.pack_nfsstat4(data.dr_status)

    def pack_IO_ADVISE_type4(self, data):
        if hasattr(self, 'filter_IO_ADVISE_type4'):
            data = getattr(self, 'filter_IO_ADVISE_type4')(data)
        if self.check_enum and data not in [const.IO_ADVISE4_NORMAL, const.IO_ADVISE4_SEQUENTIAL, const.IO_ADVISE4_SEQUENTIAL_BACKWARDS, const.IO_ADVISE4_RANDOM, const.IO_ADVISE4_WILLNEED, const.IO_ADVISE4_WILLNEED_OPPORTUNISTIC, const.IO_ADVISE4_DONTNEED, const.IO_ADVISE4_NOREUSE, const.IO_ADVISE4_READ, const.IO_ADVISE4_WRITE, const.IO_ADVISE4_INIT_PROXIMITY]:
            raise XDRError('value=%s not in enum IO_ADVISE_type4' % data)
        self.pack_int(data)

    def pack_IO_ADVISE4args(self, data):
        if hasattr(self, 'filter_IO_ADVISE4args'):
            data = getattr(self, 'filter_IO_ADVISE4args')(data)
        if data.iaa_stateid is None:
            raise TypeError('data.iaa_stateid == None')
        self.pack_stateid4(data.iaa_stateid)
        if data.iaa_offset is None:
            raise TypeError('data.iaa_offset == None')
        self.pack_offset4(data.iaa_offset)
        if data.iaa_count is None:
            raise TypeError('data.iaa_count == None')
        self.pack_length4(data.iaa_count)
        if data.iaa_hints is None:
            raise TypeError('data.iaa_hints == None')
        self.pack_bitmap4(data.iaa_hints)

    def pack_IO_ADVISE4resok(self, data):
        if hasattr(self, 'filter_IO_ADVISE4resok'):
            data = getattr(self, 'filter_IO_ADVISE4resok')(data)
        if data.ior_hints is None:
            raise TypeError('data.ior_hints == None')
        self.pack_bitmap4(data.ior_hints)

    def pack_IO_ADVISE4res(self, data):
        if hasattr(self, 'filter_IO_ADVISE4res'):
            data = getattr(self, 'filter_IO_ADVISE4res')(data)
        if data.ior_status is None:
            raise TypeError('data.ior_status == None')
        self.pack_nfsstat4(data.ior_status)
        if data.ior_status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_IO_ADVISE4resok(data.resok4)
        else:
            pass

    def pack_device_error4(self, data):
        if hasattr(self, 'filter_device_error4'):
            data = getattr(self, 'filter_device_error4')(data)
        if data.de_deviceid is None:
            raise TypeError('data.de_deviceid == None')
        self.pack_deviceid4(data.de_deviceid)
        if data.de_status is None:
            raise TypeError('data.de_status == None')
        self.pack_nfsstat4(data.de_status)
        if data.de_opnum is None:
            raise TypeError('data.de_opnum == None')
        self.pack_nfs_opnum4(data.de_opnum)

    def pack_LAYOUTERROR4args(self, data):
        if hasattr(self, 'filter_LAYOUTERROR4args'):
            data = getattr(self, 'filter_LAYOUTERROR4args')(data)
        if data.lea_offset is None:
            raise TypeError('data.lea_offset == None')
        self.pack_offset4(data.lea_offset)
        if data.lea_length is None:
            raise TypeError('data.lea_length == None')
        self.pack_length4(data.lea_length)
        if data.lea_stateid is None:
            raise TypeError('data.lea_stateid == None')
        self.pack_stateid4(data.lea_stateid)
        if data.lea_errors is None:
            raise TypeError('data.lea_errors == None')
        self.pack_array(data.lea_errors, self.pack_device_error4)

    def pack_LAYOUTERROR4res(self, data):
        if hasattr(self, 'filter_LAYOUTERROR4res'):
            data = getattr(self, 'filter_LAYOUTERROR4res')(data)
        if data.ler_status is None:
            raise TypeError('data.ler_status == None')
        self.pack_nfsstat4(data.ler_status)

    def pack_io_info4(self, data):
        if hasattr(self, 'filter_io_info4'):
            data = getattr(self, 'filter_io_info4')(data)
        if data.ii_count is None:
            raise TypeError('data.ii_count == None')
        self.pack_uint64_t(data.ii_count)
        if data.ii_bytes is None:
            raise TypeError('data.ii_bytes == None')
        self.pack_uint64_t(data.ii_bytes)

    def pack_LAYOUTSTATS4args(self, data):
        if hasattr(self, 'filter_LAYOUTSTATS4args'):
            data = getattr(self, 'filter_LAYOUTSTATS4args')(data)
        if data.lsa_offset is None:
            raise TypeError('data.lsa_offset == None')
        self.pack_offset4(data.lsa_offset)
        if data.lsa_length is None:
            raise TypeError('data.lsa_length == None')
        self.pack_length4(data.lsa_length)
        if data.lsa_stateid is None:
            raise TypeError('data.lsa_stateid == None')
        self.pack_stateid4(data.lsa_stateid)
        if data.lsa_read is None:
            raise TypeError('data.lsa_read == None')
        self.pack_io_info4(data.lsa_read)
        if data.lsa_write is None:
            raise TypeError('data.lsa_write == None')
        self.pack_io_info4(data.lsa_write)
        if data.lsa_deviceid is None:
            raise TypeError('data.lsa_deviceid == None')
        self.pack_deviceid4(data.lsa_deviceid)
        if data.lsa_layoutupdate is None:
            raise TypeError('data.lsa_layoutupdate == None')
        self.pack_layoutupdate4(data.lsa_layoutupdate)

    def pack_LAYOUTSTATS4res(self, data):
        if hasattr(self, 'filter_LAYOUTSTATS4res'):
            data = getattr(self, 'filter_LAYOUTSTATS4res')(data)
        if data.lsr_status is None:
            raise TypeError('data.lsr_status == None')
        self.pack_nfsstat4(data.lsr_status)

    def pack_READ_PLUS4args(self, data):
        if hasattr(self, 'filter_READ_PLUS4args'):
            data = getattr(self, 'filter_READ_PLUS4args')(data)
        if data.rpa_stateid is None:
            raise TypeError('data.rpa_stateid == None')
        self.pack_stateid4(data.rpa_stateid)
        if data.rpa_offset is None:
            raise TypeError('data.rpa_offset == None')
        self.pack_offset4(data.rpa_offset)
        if data.rpa_count is None:
            raise TypeError('data.rpa_count == None')
        self.pack_count4(data.rpa_count)

    def pack_read_plus_content(self, data):
        if hasattr(self, 'filter_read_plus_content'):
            data = getattr(self, 'filter_read_plus_content')(data)
        if data.rpc_content is None:
            raise TypeError('data.rpc_content == None')
        self.pack_data_content4(data.rpc_content)
        if data.rpc_content == const.NFS4_CONTENT_DATA:
            if data.rpc_data is None:
                raise TypeError('data.rpc_data == None')
            self.pack_data4(data.rpc_data)
        elif data.rpc_content == const.NFS4_CONTENT_HOLE:
            if data.rpc_hole is None:
                raise TypeError('data.rpc_hole == None')
            self.pack_data_info4(data.rpc_hole)
        else:
            pass

    def pack_read_plus_res4(self, data):
        if hasattr(self, 'filter_read_plus_res4'):
            data = getattr(self, 'filter_read_plus_res4')(data)
        if data.rpr_eof is None:
            raise TypeError('data.rpr_eof == None')
        self.pack_bool(data.rpr_eof)
        if data.rpr_contents is None:
            raise TypeError('data.rpr_contents == None')
        self.pack_array(data.rpr_contents, self.pack_read_plus_content)

    def pack_READ_PLUS4res(self, data):
        if hasattr(self, 'filter_READ_PLUS4res'):
            data = getattr(self, 'filter_READ_PLUS4res')(data)
        if data.rp_status is None:
            raise TypeError('data.rp_status == None')
        self.pack_nfsstat4(data.rp_status)
        if data.rp_status == const.NFS4_OK:
            if data.rp_resok4 is None:
                raise TypeError('data.rp_resok4 == None')
            self.pack_read_plus_res4(data.rp_resok4)
        else:
            pass

    def pack_SEEK4args(self, data):
        if hasattr(self, 'filter_SEEK4args'):
            data = getattr(self, 'filter_SEEK4args')(data)
        if data.sa_stateid is None:
            raise TypeError('data.sa_stateid == None')
        self.pack_stateid4(data.sa_stateid)
        if data.sa_offset is None:
            raise TypeError('data.sa_offset == None')
        self.pack_offset4(data.sa_offset)
        if data.sa_what is None:
            raise TypeError('data.sa_what == None')
        self.pack_data_content4(data.sa_what)

    def pack_seek_res4(self, data):
        if hasattr(self, 'filter_seek_res4'):
            data = getattr(self, 'filter_seek_res4')(data)
        if data.sr_eof is None:
            raise TypeError('data.sr_eof == None')
        self.pack_bool(data.sr_eof)
        if data.sr_offset is None:
            raise TypeError('data.sr_offset == None')
        self.pack_offset4(data.sr_offset)

    def pack_SEEK4res(self, data):
        if hasattr(self, 'filter_SEEK4res'):
            data = getattr(self, 'filter_SEEK4res')(data)
        if data.sa_status is None:
            raise TypeError('data.sa_status == None')
        self.pack_nfsstat4(data.sa_status)
        if data.sa_status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_seek_res4(data.resok4)
        else:
            pass

    def pack_WRITE_SAME4args(self, data):
        if hasattr(self, 'filter_WRITE_SAME4args'):
            data = getattr(self, 'filter_WRITE_SAME4args')(data)
        if data.wsa_stateid is None:
            raise TypeError('data.wsa_stateid == None')
        self.pack_stateid4(data.wsa_stateid)
        if data.wsa_stable is None:
            raise TypeError('data.wsa_stable == None')
        self.pack_stable_how4(data.wsa_stable)
        if data.wsa_adb is None:
            raise TypeError('data.wsa_adb == None')
        self.pack_app_data_block4(data.wsa_adb)

    def pack_WRITE_SAME4res(self, data):
        if hasattr(self, 'filter_WRITE_SAME4res'):
            data = getattr(self, 'filter_WRITE_SAME4res')(data)
        if data.wsr_status is None:
            raise TypeError('data.wsr_status == None')
        self.pack_nfsstat4(data.wsr_status)
        if data.wsr_status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_write_response4(data.resok4)
        else:
            pass

    def pack_ff_device_versions4(self, data):
        if hasattr(self, 'filter_ff_device_versions4'):
            data = getattr(self, 'filter_ff_device_versions4')(data)
        if data.ffdv_version is None:
            raise TypeError('data.ffdv_version == None')
        self.pack_uint32_t(data.ffdv_version)
        if data.ffdv_minorversion is None:
            raise TypeError('data.ffdv_minorversion == None')
        self.pack_uint32_t(data.ffdv_minorversion)
        if data.ffdv_rsize is None:
            raise TypeError('data.ffdv_rsize == None')
        self.pack_uint32_t(data.ffdv_rsize)
        if data.ffdv_wsize is None:
            raise TypeError('data.ffdv_wsize == None')
        self.pack_uint32_t(data.ffdv_wsize)
        if data.ffdv_tightly_coupled is None:
            raise TypeError('data.ffdv_tightly_coupled == None')
        self.pack_bool(data.ffdv_tightly_coupled)

    def pack_ff_device_addr4(self, data):
        if hasattr(self, 'filter_ff_device_addr4'):
            data = getattr(self, 'filter_ff_device_addr4')(data)
        if data.ffda_netaddrs is None:
            raise TypeError('data.ffda_netaddrs == None')
        self.pack_multipath_list4(data.ffda_netaddrs)
        if data.ffda_versions is None:
            raise TypeError('data.ffda_versions == None')
        self.pack_array(data.ffda_versions, self.pack_ff_device_versions4)

    pack_ff_flags4 = pack_uint32_t

    def pack_ff_data_server4(self, data):
        if hasattr(self, 'filter_ff_data_server4'):
            data = getattr(self, 'filter_ff_data_server4')(data)
        if data.ffds_deviceid is None:
            raise TypeError('data.ffds_deviceid == None')
        self.pack_deviceid4(data.ffds_deviceid)
        if data.ffds_efficiency is None:
            raise TypeError('data.ffds_efficiency == None')
        self.pack_uint32_t(data.ffds_efficiency)
        if data.ffds_stateid is None:
            raise TypeError('data.ffds_stateid == None')
        self.pack_stateid4(data.ffds_stateid)
        if data.ffds_fh_vers is None:
            raise TypeError('data.ffds_fh_vers == None')
        self.pack_array(data.ffds_fh_vers, self.pack_nfs_fh4)
        if data.ffds_user is None:
            raise TypeError('data.ffds_user == None')
        self.pack_fattr4_owner(data.ffds_user)
        if data.ffds_group is None:
            raise TypeError('data.ffds_group == None')
        self.pack_fattr4_owner_group(data.ffds_group)

    def pack_ff_mirror4(self, data):
        if hasattr(self, 'filter_ff_mirror4'):
            data = getattr(self, 'filter_ff_mirror4')(data)
        if data.ffm_data_servers is None:
            raise TypeError('data.ffm_data_servers == None')
        self.pack_array(data.ffm_data_servers, self.pack_ff_data_server4)

    def pack_ff_layout4(self, data):
        if hasattr(self, 'filter_ff_layout4'):
            data = getattr(self, 'filter_ff_layout4')(data)
        if data.ffl_stripe_unit is None:
            raise TypeError('data.ffl_stripe_unit == None')
        self.pack_length4(data.ffl_stripe_unit)
        if data.ffl_mirrors is None:
            raise TypeError('data.ffl_mirrors == None')
        self.pack_array(data.ffl_mirrors, self.pack_ff_mirror4)
        if data.ffl_flags is None:
            raise TypeError('data.ffl_flags == None')
        self.pack_ff_flags4(data.ffl_flags)
        if data.ffl_stats_collect_hint is None:
            raise TypeError('data.ffl_stats_collect_hint == None')
        self.pack_uint32_t(data.ffl_stats_collect_hint)

    def pack_ff_ioerr4(self, data):
        if hasattr(self, 'filter_ff_ioerr4'):
            data = getattr(self, 'filter_ff_ioerr4')(data)
        if data.ffie_offset is None:
            raise TypeError('data.ffie_offset == None')
        self.pack_offset4(data.ffie_offset)
        if data.ffie_length is None:
            raise TypeError('data.ffie_length == None')
        self.pack_length4(data.ffie_length)
        if data.ffie_stateid is None:
            raise TypeError('data.ffie_stateid == None')
        self.pack_stateid4(data.ffie_stateid)
        if data.ffie_errors is None:
            raise TypeError('data.ffie_errors == None')
        self.pack_array(data.ffie_errors, self.pack_device_error4)

    def pack_ff_io_latency4(self, data):
        if hasattr(self, 'filter_ff_io_latency4'):
            data = getattr(self, 'filter_ff_io_latency4')(data)
        if data.ffil_ops_requested is None:
            raise TypeError('data.ffil_ops_requested == None')
        self.pack_uint64_t(data.ffil_ops_requested)
        if data.ffil_bytes_requested is None:
            raise TypeError('data.ffil_bytes_requested == None')
        self.pack_uint64_t(data.ffil_bytes_requested)
        if data.ffil_ops_completed is None:
            raise TypeError('data.ffil_ops_completed == None')
        self.pack_uint64_t(data.ffil_ops_completed)
        if data.ffil_bytes_completed is None:
            raise TypeError('data.ffil_bytes_completed == None')
        self.pack_uint64_t(data.ffil_bytes_completed)
        if data.ffil_bytes_not_delivered is None:
            raise TypeError('data.ffil_bytes_not_delivered == None')
        self.pack_uint64_t(data.ffil_bytes_not_delivered)
        if data.ffil_total_busy_time is None:
            raise TypeError('data.ffil_total_busy_time == None')
        self.pack_nfstime4(data.ffil_total_busy_time)
        if data.ffil_aggregate_completion_time is None:
            raise TypeError('data.ffil_aggregate_completion_time == None')
        self.pack_nfstime4(data.ffil_aggregate_completion_time)

    def pack_ff_layoutupdate4(self, data):
        if hasattr(self, 'filter_ff_layoutupdate4'):
            data = getattr(self, 'filter_ff_layoutupdate4')(data)
        if data.ffl_addr is None:
            raise TypeError('data.ffl_addr == None')
        self.pack_netaddr4(data.ffl_addr)
        if data.ffl_fhandle is None:
            raise TypeError('data.ffl_fhandle == None')
        self.pack_nfs_fh4(data.ffl_fhandle)
        if data.ffl_read is None:
            raise TypeError('data.ffl_read == None')
        self.pack_ff_io_latency4(data.ffl_read)
        if data.ffl_write is None:
            raise TypeError('data.ffl_write == None')
        self.pack_ff_io_latency4(data.ffl_write)
        if data.ffl_duration is None:
            raise TypeError('data.ffl_duration == None')
        self.pack_nfstime4(data.ffl_duration)
        if data.ffl_local is None:
            raise TypeError('data.ffl_local == None')
        self.pack_bool(data.ffl_local)

    def pack_ff_iostats4(self, data):
        if hasattr(self, 'filter_ff_iostats4'):
            data = getattr(self, 'filter_ff_iostats4')(data)
        if data.ffis_offset is None:
            raise TypeError('data.ffis_offset == None')
        self.pack_offset4(data.ffis_offset)
        if data.ffis_length is None:
            raise TypeError('data.ffis_length == None')
        self.pack_length4(data.ffis_length)
        if data.ffis_stateid is None:
            raise TypeError('data.ffis_stateid == None')
        self.pack_stateid4(data.ffis_stateid)
        if data.ffis_read is None:
            raise TypeError('data.ffis_read == None')
        self.pack_io_info4(data.ffis_read)
        if data.ffis_write is None:
            raise TypeError('data.ffis_write == None')
        self.pack_io_info4(data.ffis_write)
        if data.ffis_deviceid is None:
            raise TypeError('data.ffis_deviceid == None')
        self.pack_deviceid4(data.ffis_deviceid)
        if data.ffis_layoutupdate is None:
            raise TypeError('data.ffis_layoutupdate == None')
        self.pack_ff_layoutupdate4(data.ffis_layoutupdate)

    def pack_ff_layoutreturn4(self, data):
        if hasattr(self, 'filter_ff_layoutreturn4'):
            data = getattr(self, 'filter_ff_layoutreturn4')(data)
        if data.fflr_ioerr_report is None:
            raise TypeError('data.fflr_ioerr_report == None')
        self.pack_array(data.fflr_ioerr_report, self.pack_ff_ioerr4)
        if data.fflr_iostats_report is None:
            raise TypeError('data.fflr_iostats_report == None')
        self.pack_array(data.fflr_iostats_report, self.pack_ff_iostats4)

    def pack_ff_mirrors_hint(self, data):
        if hasattr(self, 'filter_ff_mirrors_hint'):
            data = getattr(self, 'filter_ff_mirrors_hint')(data)
        if data.ffmc_valid is None:
            raise TypeError('data.ffmc_valid == None')
        self.pack_bool(data.ffmc_valid)
        if data.ffmc_valid == const.TRUE:
            if data.ffmc_mirrors is None:
                raise TypeError('data.ffmc_mirrors == None')
            self.pack_uint32_t(data.ffmc_mirrors)
        elif data.ffmc_valid == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.ffmc_valid)

    def pack_ff_layouthint4(self, data):
        if hasattr(self, 'filter_ff_layouthint4'):
            data = getattr(self, 'filter_ff_layouthint4')(data)
        if data.fflh_mirrors_hint is None:
            raise TypeError('data.fflh_mirrors_hint == None')
        self.pack_ff_mirrors_hint(data.fflh_mirrors_hint)

    def pack_ff_cb_recall_any_mask(self, data):
        if hasattr(self, 'filter_ff_cb_recall_any_mask'):
            data = getattr(self, 'filter_ff_cb_recall_any_mask')(data)
        if self.check_enum and data not in [const.FF_RCA4_TYPE_MASK_READ, const.FF_RCA4_TYPE_MASK_RW]:
            raise XDRError('value=%s not in enum ff_cb_recall_any_mask' % data)
        self.pack_int(data)

    def pack_GETXATTR4args(self, data):
        if hasattr(self, 'filter_GETXATTR4args'):
            data = getattr(self, 'filter_GETXATTR4args')(data)
        if data.gxa_name is None:
            raise TypeError('data.gxa_name == None')
        self.pack_xattrkey4(data.gxa_name)

    def pack_GETXATTR4res(self, data):
        if hasattr(self, 'filter_GETXATTR4res'):
            data = getattr(self, 'filter_GETXATTR4res')(data)
        if data.gxr_status is None:
            raise TypeError('data.gxr_status == None')
        self.pack_nfsstat4(data.gxr_status)
        if data.gxr_status == const.NFS4_OK:
            if data.gxr_value is None:
                raise TypeError('data.gxr_value == None')
            self.pack_xattrvalue4(data.gxr_value)
        else:
            pass

    def pack_setxattr_option4(self, data):
        if hasattr(self, 'filter_setxattr_option4'):
            data = getattr(self, 'filter_setxattr_option4')(data)
        if self.check_enum and data not in [const.SETXATTR4_EITHER, const.SETXATTR4_CREATE, const.SETXATTR4_REPLACE]:
            raise XDRError('value=%s not in enum setxattr_option4' % data)
        self.pack_int(data)

    def pack_SETXATTR4args(self, data):
        if hasattr(self, 'filter_SETXATTR4args'):
            data = getattr(self, 'filter_SETXATTR4args')(data)
        if data.sxa_option is None:
            raise TypeError('data.sxa_option == None')
        self.pack_setxattr_option4(data.sxa_option)
        if data.sxa_key is None:
            raise TypeError('data.sxa_key == None')
        self.pack_xattrkey4(data.sxa_key)
        if data.sxa_value is None:
            raise TypeError('data.sxa_value == None')
        self.pack_xattrvalue4(data.sxa_value)

    def pack_SETXATTR4res(self, data):
        if hasattr(self, 'filter_SETXATTR4res'):
            data = getattr(self, 'filter_SETXATTR4res')(data)
        if data.sxr_status is None:
            raise TypeError('data.sxr_status == None')
        self.pack_nfsstat4(data.sxr_status)
        if data.sxr_status == const.NFS4_OK:
            if data.sxr_info is None:
                raise TypeError('data.sxr_info == None')
            self.pack_change_info4(data.sxr_info)
        else:
            pass

    def pack_LISTXATTRS4args(self, data):
        if hasattr(self, 'filter_LISTXATTRS4args'):
            data = getattr(self, 'filter_LISTXATTRS4args')(data)
        if data.lxa_cookie is None:
            raise TypeError('data.lxa_cookie == None')
        self.pack_nfs_cookie4(data.lxa_cookie)
        if data.lxa_maxcount is None:
            raise TypeError('data.lxa_maxcount == None')
        self.pack_count4(data.lxa_maxcount)

    def pack_LISTXATTRS4resok(self, data):
        if hasattr(self, 'filter_LISTXATTRS4resok'):
            data = getattr(self, 'filter_LISTXATTRS4resok')(data)
        if data.lxr_cookie is None:
            raise TypeError('data.lxr_cookie == None')
        self.pack_nfs_cookie4(data.lxr_cookie)
        if data.lxr_names is None:
            raise TypeError('data.lxr_names == None')
        self.pack_array(data.lxr_names, self.pack_xattrkey4)
        if data.lxr_eof is None:
            raise TypeError('data.lxr_eof == None')
        self.pack_bool(data.lxr_eof)

    def pack_LISTXATTRS4res(self, data):
        if hasattr(self, 'filter_LISTXATTRS4res'):
            data = getattr(self, 'filter_LISTXATTRS4res')(data)
        if data.lxr_status is None:
            raise TypeError('data.lxr_status == None')
        self.pack_nfsstat4(data.lxr_status)
        if data.lxr_status == const.NFS4_OK:
            if data.lxr_value is None:
                raise TypeError('data.lxr_value == None')
            self.pack_LISTXATTRS4resok(data.lxr_value)
        else:
            pass

    def pack_REMOVEXATTR4args(self, data):
        if hasattr(self, 'filter_REMOVEXATTR4args'):
            data = getattr(self, 'filter_REMOVEXATTR4args')(data)
        if data.rxa_name is None:
            raise TypeError('data.rxa_name == None')
        self.pack_xattrkey4(data.rxa_name)

    def pack_REMOVEXATTR4res(self, data):
        if hasattr(self, 'filter_REMOVEXATTR4res'):
            data = getattr(self, 'filter_REMOVEXATTR4res')(data)
        if data.rxr_status is None:
            raise TypeError('data.rxr_status == None')
        self.pack_nfsstat4(data.rxr_status)
        if data.rxr_status == const.NFS4_OK:
            if data.rxr_info is None:
                raise TypeError('data.rxr_info == None')
            self.pack_change_info4(data.rxr_info)
        else:
            pass

    def pack_nfs_argop4(self, data):
        if hasattr(self, 'filter_nfs_argop4'):
            data = getattr(self, 'filter_nfs_argop4')(data)
        if data.argop is None:
            raise TypeError('data.argop == None')
        self.pack_nfs_opnum4(data.argop)
        if data.argop == const.OP_ACCESS:
            if data.opaccess is None:
                raise TypeError('data.opaccess == None')
            self.pack_ACCESS4args(data.opaccess)
        elif data.argop == const.OP_CLOSE:
            if data.opclose is None:
                raise TypeError('data.opclose == None')
            self.pack_CLOSE4args(data.opclose)
        elif data.argop == const.OP_COMMIT:
            if data.opcommit is None:
                raise TypeError('data.opcommit == None')
            self.pack_COMMIT4args(data.opcommit)
        elif data.argop == const.OP_CREATE:
            if data.opcreate is None:
                raise TypeError('data.opcreate == None')
            self.pack_CREATE4args(data.opcreate)
        elif data.argop == const.OP_DELEGPURGE:
            if data.opdelegpurge is None:
                raise TypeError('data.opdelegpurge == None')
            self.pack_DELEGPURGE4args(data.opdelegpurge)
        elif data.argop == const.OP_DELEGRETURN:
            if data.opdelegreturn is None:
                raise TypeError('data.opdelegreturn == None')
            self.pack_DELEGRETURN4args(data.opdelegreturn)
        elif data.argop == const.OP_GETATTR:
            if data.opgetattr is None:
                raise TypeError('data.opgetattr == None')
            self.pack_GETATTR4args(data.opgetattr)
        elif data.argop == const.OP_GETFH:
            pass
        elif data.argop == const.OP_LINK:
            if data.oplink is None:
                raise TypeError('data.oplink == None')
            self.pack_LINK4args(data.oplink)
        elif data.argop == const.OP_LOCK:
            if data.oplock is None:
                raise TypeError('data.oplock == None')
            self.pack_LOCK4args(data.oplock)
        elif data.argop == const.OP_LOCKT:
            if data.oplockt is None:
                raise TypeError('data.oplockt == None')
            self.pack_LOCKT4args(data.oplockt)
        elif data.argop == const.OP_LOCKU:
            if data.oplocku is None:
                raise TypeError('data.oplocku == None')
            self.pack_LOCKU4args(data.oplocku)
        elif data.argop == const.OP_LOOKUP:
            if data.oplookup is None:
                raise TypeError('data.oplookup == None')
            self.pack_LOOKUP4args(data.oplookup)
        elif data.argop == const.OP_LOOKUPP:
            pass
        elif data.argop == const.OP_NVERIFY:
            if data.opnverify is None:
                raise TypeError('data.opnverify == None')
            self.pack_NVERIFY4args(data.opnverify)
        elif data.argop == const.OP_OPEN:
            if data.opopen is None:
                raise TypeError('data.opopen == None')
            self.pack_OPEN4args(data.opopen)
        elif data.argop == const.OP_OPENATTR:
            if data.opopenattr is None:
                raise TypeError('data.opopenattr == None')
            self.pack_OPENATTR4args(data.opopenattr)
        elif data.argop == const.OP_OPEN_CONFIRM:
            if data.opopen_confirm is None:
                raise TypeError('data.opopen_confirm == None')
            self.pack_OPEN_CONFIRM4args(data.opopen_confirm)
        elif data.argop == const.OP_OPEN_DOWNGRADE:
            if data.opopen_downgrade is None:
                raise TypeError('data.opopen_downgrade == None')
            self.pack_OPEN_DOWNGRADE4args(data.opopen_downgrade)
        elif data.argop == const.OP_PUTFH:
            if data.opputfh is None:
                raise TypeError('data.opputfh == None')
            self.pack_PUTFH4args(data.opputfh)
        elif data.argop == const.OP_PUTPUBFH:
            pass
        elif data.argop == const.OP_PUTROOTFH:
            pass
        elif data.argop == const.OP_READ:
            if data.opread is None:
                raise TypeError('data.opread == None')
            self.pack_READ4args(data.opread)
        elif data.argop == const.OP_READDIR:
            if data.opreaddir is None:
                raise TypeError('data.opreaddir == None')
            self.pack_READDIR4args(data.opreaddir)
        elif data.argop == const.OP_READLINK:
            pass
        elif data.argop == const.OP_REMOVE:
            if data.opremove is None:
                raise TypeError('data.opremove == None')
            self.pack_REMOVE4args(data.opremove)
        elif data.argop == const.OP_RENAME:
            if data.oprename is None:
                raise TypeError('data.oprename == None')
            self.pack_RENAME4args(data.oprename)
        elif data.argop == const.OP_RENEW:
            if data.oprenew is None:
                raise TypeError('data.oprenew == None')
            self.pack_RENEW4args(data.oprenew)
        elif data.argop == const.OP_RESTOREFH:
            pass
        elif data.argop == const.OP_SAVEFH:
            pass
        elif data.argop == const.OP_SECINFO:
            if data.opsecinfo is None:
                raise TypeError('data.opsecinfo == None')
            self.pack_SECINFO4args(data.opsecinfo)
        elif data.argop == const.OP_SETATTR:
            if data.opsetattr is None:
                raise TypeError('data.opsetattr == None')
            self.pack_SETATTR4args(data.opsetattr)
        elif data.argop == const.OP_SETCLIENTID:
            if data.opsetclientid is None:
                raise TypeError('data.opsetclientid == None')
            self.pack_SETCLIENTID4args(data.opsetclientid)
        elif data.argop == const.OP_SETCLIENTID_CONFIRM:
            if data.opsetclientid_confirm is None:
                raise TypeError('data.opsetclientid_confirm == None')
            self.pack_SETCLIENTID_CONFIRM4args(data.opsetclientid_confirm)
        elif data.argop == const.OP_VERIFY:
            if data.opverify is None:
                raise TypeError('data.opverify == None')
            self.pack_VERIFY4args(data.opverify)
        elif data.argop == const.OP_WRITE:
            if data.opwrite is None:
                raise TypeError('data.opwrite == None')
            self.pack_WRITE4args(data.opwrite)
        elif data.argop == const.OP_RELEASE_LOCKOWNER:
            if data.oprelease_lockowner is None:
                raise TypeError('data.oprelease_lockowner == None')
            self.pack_RELEASE_LOCKOWNER4args(data.oprelease_lockowner)
        elif data.argop == const.OP_BACKCHANNEL_CTL:
            if data.opbackchannel_ctl is None:
                raise TypeError('data.opbackchannel_ctl == None')
            self.pack_BACKCHANNEL_CTL4args(data.opbackchannel_ctl)
        elif data.argop == const.OP_BIND_CONN_TO_SESSION:
            if data.opbind_conn_to_session is None:
                raise TypeError('data.opbind_conn_to_session == None')
            self.pack_BIND_CONN_TO_SESSION4args(data.opbind_conn_to_session)
        elif data.argop == const.OP_EXCHANGE_ID:
            if data.opexchange_id is None:
                raise TypeError('data.opexchange_id == None')
            self.pack_EXCHANGE_ID4args(data.opexchange_id)
        elif data.argop == const.OP_CREATE_SESSION:
            if data.opcreate_session is None:
                raise TypeError('data.opcreate_session == None')
            self.pack_CREATE_SESSION4args(data.opcreate_session)
        elif data.argop == const.OP_DESTROY_SESSION:
            if data.opdestroy_session is None:
                raise TypeError('data.opdestroy_session == None')
            self.pack_DESTROY_SESSION4args(data.opdestroy_session)
        elif data.argop == const.OP_FREE_STATEID:
            if data.opfree_stateid is None:
                raise TypeError('data.opfree_stateid == None')
            self.pack_FREE_STATEID4args(data.opfree_stateid)
        elif data.argop == const.OP_GET_DIR_DELEGATION:
            if data.opget_dir_delegation is None:
                raise TypeError('data.opget_dir_delegation == None')
            self.pack_GET_DIR_DELEGATION4args(data.opget_dir_delegation)
        elif data.argop == const.OP_GETDEVICEINFO:
            if data.opgetdeviceinfo is None:
                raise TypeError('data.opgetdeviceinfo == None')
            self.pack_GETDEVICEINFO4args(data.opgetdeviceinfo)
        elif data.argop == const.OP_GETDEVICELIST:
            if data.opgetdevicelist is None:
                raise TypeError('data.opgetdevicelist == None')
            self.pack_GETDEVICELIST4args(data.opgetdevicelist)
        elif data.argop == const.OP_LAYOUTCOMMIT:
            if data.oplayoutcommit is None:
                raise TypeError('data.oplayoutcommit == None')
            self.pack_LAYOUTCOMMIT4args(data.oplayoutcommit)
        elif data.argop == const.OP_LAYOUTGET:
            if data.oplayoutget is None:
                raise TypeError('data.oplayoutget == None')
            self.pack_LAYOUTGET4args(data.oplayoutget)
        elif data.argop == const.OP_LAYOUTRETURN:
            if data.oplayoutreturn is None:
                raise TypeError('data.oplayoutreturn == None')
            self.pack_LAYOUTRETURN4args(data.oplayoutreturn)
        elif data.argop == const.OP_SECINFO_NO_NAME:
            if data.opsecinfo_no_name is None:
                raise TypeError('data.opsecinfo_no_name == None')
            self.pack_SECINFO_NO_NAME4args(data.opsecinfo_no_name)
        elif data.argop == const.OP_SEQUENCE:
            if data.opsequence is None:
                raise TypeError('data.opsequence == None')
            self.pack_SEQUENCE4args(data.opsequence)
        elif data.argop == const.OP_SET_SSV:
            if data.opset_ssv is None:
                raise TypeError('data.opset_ssv == None')
            self.pack_SET_SSV4args(data.opset_ssv)
        elif data.argop == const.OP_TEST_STATEID:
            if data.optest_stateid is None:
                raise TypeError('data.optest_stateid == None')
            self.pack_TEST_STATEID4args(data.optest_stateid)
        elif data.argop == const.OP_WANT_DELEGATION:
            if data.opwant_delegation is None:
                raise TypeError('data.opwant_delegation == None')
            self.pack_WANT_DELEGATION4args(data.opwant_delegation)
        elif data.argop == const.OP_DESTROY_CLIENTID:
            if data.opdestroy_clientid is None:
                raise TypeError('data.opdestroy_clientid == None')
            self.pack_DESTROY_CLIENTID4args(data.opdestroy_clientid)
        elif data.argop == const.OP_RECLAIM_COMPLETE:
            if data.opreclaim_complete is None:
                raise TypeError('data.opreclaim_complete == None')
            self.pack_RECLAIM_COMPLETE4args(data.opreclaim_complete)
        elif data.argop == const.OP_ALLOCATE:
            if data.opallocate is None:
                raise TypeError('data.opallocate == None')
            self.pack_ALLOCATE4args(data.opallocate)
        elif data.argop == const.OP_COPY:
            if data.opcopy is None:
                raise TypeError('data.opcopy == None')
            self.pack_COPY4args(data.opcopy)
        elif data.argop == const.OP_COPY_NOTIFY:
            if data.opoffload_notify is None:
                raise TypeError('data.opoffload_notify == None')
            self.pack_COPY_NOTIFY4args(data.opoffload_notify)
        elif data.argop == const.OP_DEALLOCATE:
            if data.opdeallocate is None:
                raise TypeError('data.opdeallocate == None')
            self.pack_DEALLOCATE4args(data.opdeallocate)
        elif data.argop == const.OP_IO_ADVISE:
            if data.opio_advise is None:
                raise TypeError('data.opio_advise == None')
            self.pack_IO_ADVISE4args(data.opio_advise)
        elif data.argop == const.OP_LAYOUTERROR:
            if data.oplayouterror is None:
                raise TypeError('data.oplayouterror == None')
            self.pack_LAYOUTERROR4args(data.oplayouterror)
        elif data.argop == const.OP_LAYOUTSTATS:
            if data.oplayoutstats is None:
                raise TypeError('data.oplayoutstats == None')
            self.pack_LAYOUTSTATS4args(data.oplayoutstats)
        elif data.argop == const.OP_OFFLOAD_CANCEL:
            if data.opoffload_cancel is None:
                raise TypeError('data.opoffload_cancel == None')
            self.pack_OFFLOAD_CANCEL4args(data.opoffload_cancel)
        elif data.argop == const.OP_OFFLOAD_STATUS:
            if data.opoffload_status is None:
                raise TypeError('data.opoffload_status == None')
            self.pack_OFFLOAD_STATUS4args(data.opoffload_status)
        elif data.argop == const.OP_READ_PLUS:
            if data.opread_plus is None:
                raise TypeError('data.opread_plus == None')
            self.pack_READ_PLUS4args(data.opread_plus)
        elif data.argop == const.OP_SEEK:
            if data.opseek is None:
                raise TypeError('data.opseek == None')
            self.pack_SEEK4args(data.opseek)
        elif data.argop == const.OP_WRITE_SAME:
            if data.opwrite_same is None:
                raise TypeError('data.opwrite_same == None')
            self.pack_WRITE_SAME4args(data.opwrite_same)
        elif data.argop == const.OP_CLONE:
            if data.opclone is None:
                raise TypeError('data.opclone == None')
            self.pack_CLONE4args(data.opclone)
        elif data.argop == const.OP_GETXATTR:
            if data.opgetxattr is None:
                raise TypeError('data.opgetxattr == None')
            self.pack_GETXATTR4args(data.opgetxattr)
        elif data.argop == const.OP_SETXATTR:
            if data.opsetxattr is None:
                raise TypeError('data.opsetxattr == None')
            self.pack_SETXATTR4args(data.opsetxattr)
        elif data.argop == const.OP_LISTXATTRS:
            if data.oplistxattrs is None:
                raise TypeError('data.oplistxattrs == None')
            self.pack_LISTXATTRS4args(data.oplistxattrs)
        elif data.argop == const.OP_REMOVEXATTR:
            if data.opremovexattr is None:
                raise TypeError('data.opremovexattr == None')
            self.pack_REMOVEXATTR4args(data.opremovexattr)
        elif data.argop == const.OP_ILLEGAL:
            pass
        else:
            raise XDRError('bad switch=%s' % data.argop)

    def pack_nfs_resop4(self, data):
        if hasattr(self, 'filter_nfs_resop4'):
            data = getattr(self, 'filter_nfs_resop4')(data)
        if data.resop is None:
            raise TypeError('data.resop == None')
        self.pack_nfs_opnum4(data.resop)
        if data.resop == const.OP_ACCESS:
            if data.opaccess is None:
                raise TypeError('data.opaccess == None')
            self.pack_ACCESS4res(data.opaccess)
        elif data.resop == const.OP_CLOSE:
            if data.opclose is None:
                raise TypeError('data.opclose == None')
            self.pack_CLOSE4res(data.opclose)
        elif data.resop == const.OP_COMMIT:
            if data.opcommit is None:
                raise TypeError('data.opcommit == None')
            self.pack_COMMIT4res(data.opcommit)
        elif data.resop == const.OP_CREATE:
            if data.opcreate is None:
                raise TypeError('data.opcreate == None')
            self.pack_CREATE4res(data.opcreate)
        elif data.resop == const.OP_DELEGPURGE:
            if data.opdelegpurge is None:
                raise TypeError('data.opdelegpurge == None')
            self.pack_DELEGPURGE4res(data.opdelegpurge)
        elif data.resop == const.OP_DELEGRETURN:
            if data.opdelegreturn is None:
                raise TypeError('data.opdelegreturn == None')
            self.pack_DELEGRETURN4res(data.opdelegreturn)
        elif data.resop == const.OP_GETATTR:
            if data.opgetattr is None:
                raise TypeError('data.opgetattr == None')
            self.pack_GETATTR4res(data.opgetattr)
        elif data.resop == const.OP_GETFH:
            if data.opgetfh is None:
                raise TypeError('data.opgetfh == None')
            self.pack_GETFH4res(data.opgetfh)
        elif data.resop == const.OP_LINK:
            if data.oplink is None:
                raise TypeError('data.oplink == None')
            self.pack_LINK4res(data.oplink)
        elif data.resop == const.OP_LOCK:
            if data.oplock is None:
                raise TypeError('data.oplock == None')
            self.pack_LOCK4res(data.oplock)
        elif data.resop == const.OP_LOCKT:
            if data.oplockt is None:
                raise TypeError('data.oplockt == None')
            self.pack_LOCKT4res(data.oplockt)
        elif data.resop == const.OP_LOCKU:
            if data.oplocku is None:
                raise TypeError('data.oplocku == None')
            self.pack_LOCKU4res(data.oplocku)
        elif data.resop == const.OP_LOOKUP:
            if data.oplookup is None:
                raise TypeError('data.oplookup == None')
            self.pack_LOOKUP4res(data.oplookup)
        elif data.resop == const.OP_LOOKUPP:
            if data.oplookupp is None:
                raise TypeError('data.oplookupp == None')
            self.pack_LOOKUPP4res(data.oplookupp)
        elif data.resop == const.OP_NVERIFY:
            if data.opnverify is None:
                raise TypeError('data.opnverify == None')
            self.pack_NVERIFY4res(data.opnverify)
        elif data.resop == const.OP_OPEN:
            if data.opopen is None:
                raise TypeError('data.opopen == None')
            self.pack_OPEN4res(data.opopen)
        elif data.resop == const.OP_OPENATTR:
            if data.opopenattr is None:
                raise TypeError('data.opopenattr == None')
            self.pack_OPENATTR4res(data.opopenattr)
        elif data.resop == const.OP_OPEN_CONFIRM:
            if data.opopen_confirm is None:
                raise TypeError('data.opopen_confirm == None')
            self.pack_OPEN_CONFIRM4res(data.opopen_confirm)
        elif data.resop == const.OP_OPEN_DOWNGRADE:
            if data.opopen_downgrade is None:
                raise TypeError('data.opopen_downgrade == None')
            self.pack_OPEN_DOWNGRADE4res(data.opopen_downgrade)
        elif data.resop == const.OP_PUTFH:
            if data.opputfh is None:
                raise TypeError('data.opputfh == None')
            self.pack_PUTFH4res(data.opputfh)
        elif data.resop == const.OP_PUTPUBFH:
            if data.opputpubfh is None:
                raise TypeError('data.opputpubfh == None')
            self.pack_PUTPUBFH4res(data.opputpubfh)
        elif data.resop == const.OP_PUTROOTFH:
            if data.opputrootfh is None:
                raise TypeError('data.opputrootfh == None')
            self.pack_PUTROOTFH4res(data.opputrootfh)
        elif data.resop == const.OP_READ:
            if data.opread is None:
                raise TypeError('data.opread == None')
            self.pack_READ4res(data.opread)
        elif data.resop == const.OP_READDIR:
            if data.opreaddir is None:
                raise TypeError('data.opreaddir == None')
            self.pack_READDIR4res(data.opreaddir)
        elif data.resop == const.OP_READLINK:
            if data.opreadlink is None:
                raise TypeError('data.opreadlink == None')
            self.pack_READLINK4res(data.opreadlink)
        elif data.resop == const.OP_REMOVE:
            if data.opremove is None:
                raise TypeError('data.opremove == None')
            self.pack_REMOVE4res(data.opremove)
        elif data.resop == const.OP_RENAME:
            if data.oprename is None:
                raise TypeError('data.oprename == None')
            self.pack_RENAME4res(data.oprename)
        elif data.resop == const.OP_RENEW:
            if data.oprenew is None:
                raise TypeError('data.oprenew == None')
            self.pack_RENEW4res(data.oprenew)
        elif data.resop == const.OP_RESTOREFH:
            if data.oprestorefh is None:
                raise TypeError('data.oprestorefh == None')
            self.pack_RESTOREFH4res(data.oprestorefh)
        elif data.resop == const.OP_SAVEFH:
            if data.opsavefh is None:
                raise TypeError('data.opsavefh == None')
            self.pack_SAVEFH4res(data.opsavefh)
        elif data.resop == const.OP_SECINFO:
            if data.opsecinfo is None:
                raise TypeError('data.opsecinfo == None')
            self.pack_SECINFO4res(data.opsecinfo)
        elif data.resop == const.OP_SETATTR:
            if data.opsetattr is None:
                raise TypeError('data.opsetattr == None')
            self.pack_SETATTR4res(data.opsetattr)
        elif data.resop == const.OP_SETCLIENTID:
            if data.opsetclientid is None:
                raise TypeError('data.opsetclientid == None')
            self.pack_SETCLIENTID4res(data.opsetclientid)
        elif data.resop == const.OP_SETCLIENTID_CONFIRM:
            if data.opsetclientid_confirm is None:
                raise TypeError('data.opsetclientid_confirm == None')
            self.pack_SETCLIENTID_CONFIRM4res(data.opsetclientid_confirm)
        elif data.resop == const.OP_VERIFY:
            if data.opverify is None:
                raise TypeError('data.opverify == None')
            self.pack_VERIFY4res(data.opverify)
        elif data.resop == const.OP_WRITE:
            if data.opwrite is None:
                raise TypeError('data.opwrite == None')
            self.pack_WRITE4res(data.opwrite)
        elif data.resop == const.OP_RELEASE_LOCKOWNER:
            if data.oprelease_lockowner is None:
                raise TypeError('data.oprelease_lockowner == None')
            self.pack_RELEASE_LOCKOWNER4res(data.oprelease_lockowner)
        elif data.resop == const.OP_BACKCHANNEL_CTL:
            if data.opbackchannel_ctl is None:
                raise TypeError('data.opbackchannel_ctl == None')
            self.pack_BACKCHANNEL_CTL4res(data.opbackchannel_ctl)
        elif data.resop == const.OP_BIND_CONN_TO_SESSION:
            if data.opbind_conn_to_session is None:
                raise TypeError('data.opbind_conn_to_session == None')
            self.pack_BIND_CONN_TO_SESSION4res(data.opbind_conn_to_session)
        elif data.resop == const.OP_EXCHANGE_ID:
            if data.opexchange_id is None:
                raise TypeError('data.opexchange_id == None')
            self.pack_EXCHANGE_ID4res(data.opexchange_id)
        elif data.resop == const.OP_CREATE_SESSION:
            if data.opcreate_session is None:
                raise TypeError('data.opcreate_session == None')
            self.pack_CREATE_SESSION4res(data.opcreate_session)
        elif data.resop == const.OP_DESTROY_SESSION:
            if data.opdestroy_session is None:
                raise TypeError('data.opdestroy_session == None')
            self.pack_DESTROY_SESSION4res(data.opdestroy_session)
        elif data.resop == const.OP_FREE_STATEID:
            if data.opfree_stateid is None:
                raise TypeError('data.opfree_stateid == None')
            self.pack_FREE_STATEID4res(data.opfree_stateid)
        elif data.resop == const.OP_GET_DIR_DELEGATION:
            if data.opget_dir_delegation is None:
                raise TypeError('data.opget_dir_delegation == None')
            self.pack_GET_DIR_DELEGATION4res(data.opget_dir_delegation)
        elif data.resop == const.OP_GETDEVICEINFO:
            if data.opgetdeviceinfo is None:
                raise TypeError('data.opgetdeviceinfo == None')
            self.pack_GETDEVICEINFO4res(data.opgetdeviceinfo)
        elif data.resop == const.OP_GETDEVICELIST:
            if data.opgetdevicelist is None:
                raise TypeError('data.opgetdevicelist == None')
            self.pack_GETDEVICELIST4res(data.opgetdevicelist)
        elif data.resop == const.OP_LAYOUTCOMMIT:
            if data.oplayoutcommit is None:
                raise TypeError('data.oplayoutcommit == None')
            self.pack_LAYOUTCOMMIT4res(data.oplayoutcommit)
        elif data.resop == const.OP_LAYOUTGET:
            if data.oplayoutget is None:
                raise TypeError('data.oplayoutget == None')
            self.pack_LAYOUTGET4res(data.oplayoutget)
        elif data.resop == const.OP_LAYOUTRETURN:
            if data.oplayoutreturn is None:
                raise TypeError('data.oplayoutreturn == None')
            self.pack_LAYOUTRETURN4res(data.oplayoutreturn)
        elif data.resop == const.OP_SECINFO_NO_NAME:
            if data.opsecinfo_no_name is None:
                raise TypeError('data.opsecinfo_no_name == None')
            self.pack_SECINFO_NO_NAME4res(data.opsecinfo_no_name)
        elif data.resop == const.OP_SEQUENCE:
            if data.opsequence is None:
                raise TypeError('data.opsequence == None')
            self.pack_SEQUENCE4res(data.opsequence)
        elif data.resop == const.OP_SET_SSV:
            if data.opset_ssv is None:
                raise TypeError('data.opset_ssv == None')
            self.pack_SET_SSV4res(data.opset_ssv)
        elif data.resop == const.OP_TEST_STATEID:
            if data.optest_stateid is None:
                raise TypeError('data.optest_stateid == None')
            self.pack_TEST_STATEID4res(data.optest_stateid)
        elif data.resop == const.OP_WANT_DELEGATION:
            if data.opwant_delegation is None:
                raise TypeError('data.opwant_delegation == None')
            self.pack_WANT_DELEGATION4res(data.opwant_delegation)
        elif data.resop == const.OP_DESTROY_CLIENTID:
            if data.opdestroy_clientid is None:
                raise TypeError('data.opdestroy_clientid == None')
            self.pack_DESTROY_CLIENTID4res(data.opdestroy_clientid)
        elif data.resop == const.OP_RECLAIM_COMPLETE:
            if data.opreclaim_complete is None:
                raise TypeError('data.opreclaim_complete == None')
            self.pack_RECLAIM_COMPLETE4res(data.opreclaim_complete)
        elif data.resop == const.OP_ALLOCATE:
            if data.opallocate is None:
                raise TypeError('data.opallocate == None')
            self.pack_ALLOCATE4res(data.opallocate)
        elif data.resop == const.OP_COPY:
            if data.opcopy is None:
                raise TypeError('data.opcopy == None')
            self.pack_COPY4res(data.opcopy)
        elif data.resop == const.OP_COPY_NOTIFY:
            if data.opcopy_notify is None:
                raise TypeError('data.opcopy_notify == None')
            self.pack_COPY_NOTIFY4res(data.opcopy_notify)
        elif data.resop == const.OP_DEALLOCATE:
            if data.opdeallocate is None:
                raise TypeError('data.opdeallocate == None')
            self.pack_DEALLOCATE4res(data.opdeallocate)
        elif data.resop == const.OP_IO_ADVISE:
            if data.opio_advise is None:
                raise TypeError('data.opio_advise == None')
            self.pack_IO_ADVISE4res(data.opio_advise)
        elif data.resop == const.OP_LAYOUTERROR:
            if data.oplayouterror is None:
                raise TypeError('data.oplayouterror == None')
            self.pack_LAYOUTERROR4res(data.oplayouterror)
        elif data.resop == const.OP_LAYOUTSTATS:
            if data.oplayputstats is None:
                raise TypeError('data.oplayputstats == None')
            self.pack_LAYOUTSTATS4res(data.oplayputstats)
        elif data.resop == const.OP_OFFLOAD_CANCEL:
            if data.opoffload_cancel is None:
                raise TypeError('data.opoffload_cancel == None')
            self.pack_OFFLOAD_CANCEL4res(data.opoffload_cancel)
        elif data.resop == const.OP_OFFLOAD_STATUS:
            if data.opoffload_status is None:
                raise TypeError('data.opoffload_status == None')
            self.pack_OFFLOAD_STATUS4res(data.opoffload_status)
        elif data.resop == const.OP_READ_PLUS:
            if data.opread_plus is None:
                raise TypeError('data.opread_plus == None')
            self.pack_READ_PLUS4res(data.opread_plus)
        elif data.resop == const.OP_SEEK:
            if data.opseek is None:
                raise TypeError('data.opseek == None')
            self.pack_SEEK4res(data.opseek)
        elif data.resop == const.OP_WRITE_SAME:
            if data.opwrite_same is None:
                raise TypeError('data.opwrite_same == None')
            self.pack_WRITE_SAME4res(data.opwrite_same)
        elif data.resop == const.OP_CLONE:
            if data.opclone is None:
                raise TypeError('data.opclone == None')
            self.pack_CLONE4res(data.opclone)
        elif data.resop == const.OP_GETXATTR:
            if data.opgetxattr is None:
                raise TypeError('data.opgetxattr == None')
            self.pack_GETXATTR4res(data.opgetxattr)
        elif data.resop == const.OP_SETXATTR:
            if data.opsetxattr is None:
                raise TypeError('data.opsetxattr == None')
            self.pack_SETXATTR4res(data.opsetxattr)
        elif data.resop == const.OP_LISTXATTRS:
            if data.oplistxattrs is None:
                raise TypeError('data.oplistxattrs == None')
            self.pack_LISTXATTRS4res(data.oplistxattrs)
        elif data.resop == const.OP_REMOVEXATTR:
            if data.opremovexattr is None:
                raise TypeError('data.opremovexattr == None')
            self.pack_REMOVEXATTR4res(data.opremovexattr)
        elif data.resop == const.OP_ILLEGAL:
            if data.opillegal is None:
                raise TypeError('data.opillegal == None')
            self.pack_ILLEGAL4res(data.opillegal)
        else:
            raise XDRError('bad switch=%s' % data.resop)

    def pack_COMPOUND4args(self, data):
        if hasattr(self, 'filter_COMPOUND4args'):
            data = getattr(self, 'filter_COMPOUND4args')(data)
        if data.tag is None:
            raise TypeError('data.tag == None')
        self.pack_utf8str_cs(data.tag)
        if data.minorversion is None:
            raise TypeError('data.minorversion == None')
        self.pack_uint32_t(data.minorversion)
        if data.argarray is None:
            raise TypeError('data.argarray == None')
        self.pack_array(data.argarray, self.pack_nfs_argop4)

    def pack_COMPOUND4res(self, data):
        if hasattr(self, 'filter_COMPOUND4res'):
            data = getattr(self, 'filter_COMPOUND4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.tag is None:
            raise TypeError('data.tag == None')
        self.pack_utf8str_cs(data.tag)
        if data.resarray is None:
            raise TypeError('data.resarray == None')
        self.pack_array(data.resarray, self.pack_nfs_resop4)

    def pack_CB_GETATTR4args(self, data):
        if hasattr(self, 'filter_CB_GETATTR4args'):
            data = getattr(self, 'filter_CB_GETATTR4args')(data)
        if data.fh is None:
            raise TypeError('data.fh == None')
        self.pack_nfs_fh4(data.fh)
        if data.attr_request is None:
            raise TypeError('data.attr_request == None')
        self.pack_bitmap4(data.attr_request)

    def pack_CB_GETATTR4resok(self, data):
        if hasattr(self, 'filter_CB_GETATTR4resok'):
            data = getattr(self, 'filter_CB_GETATTR4resok')(data)
        if data.obj_attributes is None:
            raise TypeError('data.obj_attributes == None')
        self.pack_fattr4(data.obj_attributes)

    def pack_CB_GETATTR4res(self, data):
        if hasattr(self, 'filter_CB_GETATTR4res'):
            data = getattr(self, 'filter_CB_GETATTR4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.status == const.NFS4_OK:
            if data.resok4 is None:
                raise TypeError('data.resok4 == None')
            self.pack_CB_GETATTR4resok(data.resok4)
        else:
            pass

    def pack_CB_RECALL4args(self, data):
        if hasattr(self, 'filter_CB_RECALL4args'):
            data = getattr(self, 'filter_CB_RECALL4args')(data)
        if data.stateid is None:
            raise TypeError('data.stateid == None')
        self.pack_stateid4(data.stateid)
        if data.truncate is None:
            raise TypeError('data.truncate == None')
        self.pack_bool(data.truncate)
        if data.fh is None:
            raise TypeError('data.fh == None')
        self.pack_nfs_fh4(data.fh)

    def pack_CB_RECALL4res(self, data):
        if hasattr(self, 'filter_CB_RECALL4res'):
            data = getattr(self, 'filter_CB_RECALL4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_CB_ILLEGAL4res(self, data):
        if hasattr(self, 'filter_CB_ILLEGAL4res'):
            data = getattr(self, 'filter_CB_ILLEGAL4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)

    def pack_layoutrecall_type4(self, data):
        if hasattr(self, 'filter_layoutrecall_type4'):
            data = getattr(self, 'filter_layoutrecall_type4')(data)
        if self.check_enum and data not in [const.LAYOUTRECALL4_FILE, const.LAYOUTRECALL4_FSID, const.LAYOUTRECALL4_ALL]:
            raise XDRError('value=%s not in enum layoutrecall_type4' % data)
        self.pack_int(data)

    def pack_layoutrecall_file4(self, data):
        if hasattr(self, 'filter_layoutrecall_file4'):
            data = getattr(self, 'filter_layoutrecall_file4')(data)
        if data.lor_fh is None:
            raise TypeError('data.lor_fh == None')
        self.pack_nfs_fh4(data.lor_fh)
        if data.lor_offset is None:
            raise TypeError('data.lor_offset == None')
        self.pack_offset4(data.lor_offset)
        if data.lor_length is None:
            raise TypeError('data.lor_length == None')
        self.pack_length4(data.lor_length)
        if data.lor_stateid is None:
            raise TypeError('data.lor_stateid == None')
        self.pack_stateid4(data.lor_stateid)

    def pack_layoutrecall4(self, data):
        if hasattr(self, 'filter_layoutrecall4'):
            data = getattr(self, 'filter_layoutrecall4')(data)
        if data.lor_recalltype is None:
            raise TypeError('data.lor_recalltype == None')
        self.pack_layoutrecall_type4(data.lor_recalltype)
        if data.lor_recalltype == const.LAYOUTRECALL4_FILE:
            if data.lor_layout is None:
                raise TypeError('data.lor_layout == None')
            self.pack_layoutrecall_file4(data.lor_layout)
        elif data.lor_recalltype == const.LAYOUTRECALL4_FSID:
            if data.lor_fsid is None:
                raise TypeError('data.lor_fsid == None')
            self.pack_fsid4(data.lor_fsid)
        elif data.lor_recalltype == const.LAYOUTRECALL4_ALL:
            pass
        else:
            raise XDRError('bad switch=%s' % data.lor_recalltype)

    def pack_CB_LAYOUTRECALL4args(self, data):
        if hasattr(self, 'filter_CB_LAYOUTRECALL4args'):
            data = getattr(self, 'filter_CB_LAYOUTRECALL4args')(data)
        if data.clora_type is None:
            raise TypeError('data.clora_type == None')
        self.pack_layouttype4(data.clora_type)
        if data.clora_iomode is None:
            raise TypeError('data.clora_iomode == None')
        self.pack_layoutiomode4(data.clora_iomode)
        if data.clora_changed is None:
            raise TypeError('data.clora_changed == None')
        self.pack_bool(data.clora_changed)
        if data.clora_recall is None:
            raise TypeError('data.clora_recall == None')
        self.pack_layoutrecall4(data.clora_recall)

    def pack_CB_LAYOUTRECALL4res(self, data):
        if hasattr(self, 'filter_CB_LAYOUTRECALL4res'):
            data = getattr(self, 'filter_CB_LAYOUTRECALL4res')(data)
        if data.clorr_status is None:
            raise TypeError('data.clorr_status == None')
        self.pack_nfsstat4(data.clorr_status)

    def pack_notify_type4(self, data):
        if hasattr(self, 'filter_notify_type4'):
            data = getattr(self, 'filter_notify_type4')(data)
        if self.check_enum and data not in [const.NOTIFY4_CHANGE_CHILD_ATTRS, const.NOTIFY4_CHANGE_DIR_ATTRS, const.NOTIFY4_REMOVE_ENTRY, const.NOTIFY4_ADD_ENTRY, const.NOTIFY4_RENAME_ENTRY, const.NOTIFY4_CHANGE_COOKIE_VERIFIER]:
            raise XDRError('value=%s not in enum notify_type4' % data)
        self.pack_int(data)

    def pack_notify_entry4(self, data):
        if hasattr(self, 'filter_notify_entry4'):
            data = getattr(self, 'filter_notify_entry4')(data)
        if data.ne_file is None:
            raise TypeError('data.ne_file == None')
        self.pack_component4(data.ne_file)
        if data.ne_attrs is None:
            raise TypeError('data.ne_attrs == None')
        self.pack_fattr4(data.ne_attrs)

    def pack_prev_entry4(self, data):
        if hasattr(self, 'filter_prev_entry4'):
            data = getattr(self, 'filter_prev_entry4')(data)
        if data.pe_prev_entry is None:
            raise TypeError('data.pe_prev_entry == None')
        self.pack_notify_entry4(data.pe_prev_entry)
        if data.pe_prev_entry_cookie is None:
            raise TypeError('data.pe_prev_entry_cookie == None')
        self.pack_nfs_cookie4(data.pe_prev_entry_cookie)

    def pack_notify_remove4(self, data):
        if hasattr(self, 'filter_notify_remove4'):
            data = getattr(self, 'filter_notify_remove4')(data)
        if data.nrm_old_entry is None:
            raise TypeError('data.nrm_old_entry == None')
        self.pack_notify_entry4(data.nrm_old_entry)
        if data.nrm_old_entry_cookie is None:
            raise TypeError('data.nrm_old_entry_cookie == None')
        self.pack_nfs_cookie4(data.nrm_old_entry_cookie)

    def pack_notify_add4(self, data):
        if hasattr(self, 'filter_notify_add4'):
            data = getattr(self, 'filter_notify_add4')(data)
        if data.nad_old_entry is None:
            raise TypeError('data.nad_old_entry == None')
        if len(data.nad_old_entry) > 1 and self.check_array:
            raise XDRError('array length too long for data.nad_old_entry')
        self.pack_array(data.nad_old_entry, self.pack_notify_remove4)
        if data.nad_new_entry is None:
            raise TypeError('data.nad_new_entry == None')
        self.pack_notify_entry4(data.nad_new_entry)
        if data.nad_new_entry_cookie is None:
            raise TypeError('data.nad_new_entry_cookie == None')
        if len(data.nad_new_entry_cookie) > 1 and self.check_array:
            raise XDRError('array length too long for data.nad_new_entry_cookie')
        self.pack_array(data.nad_new_entry_cookie, self.pack_nfs_cookie4)
        if data.nad_prev_entry is None:
            raise TypeError('data.nad_prev_entry == None')
        if len(data.nad_prev_entry) > 1 and self.check_array:
            raise XDRError('array length too long for data.nad_prev_entry')
        self.pack_array(data.nad_prev_entry, self.pack_prev_entry4)
        if data.nad_last_entry is None:
            raise TypeError('data.nad_last_entry == None')
        self.pack_bool(data.nad_last_entry)

    def pack_notify_attr4(self, data):
        if hasattr(self, 'filter_notify_attr4'):
            data = getattr(self, 'filter_notify_attr4')(data)
        if data.na_changed_entry is None:
            raise TypeError('data.na_changed_entry == None')
        self.pack_notify_entry4(data.na_changed_entry)

    def pack_notify_rename4(self, data):
        if hasattr(self, 'filter_notify_rename4'):
            data = getattr(self, 'filter_notify_rename4')(data)
        if data.nrn_old_entry is None:
            raise TypeError('data.nrn_old_entry == None')
        self.pack_notify_remove4(data.nrn_old_entry)
        if data.nrn_new_entry is None:
            raise TypeError('data.nrn_new_entry == None')
        self.pack_notify_add4(data.nrn_new_entry)

    def pack_notify_verifier4(self, data):
        if hasattr(self, 'filter_notify_verifier4'):
            data = getattr(self, 'filter_notify_verifier4')(data)
        if data.nv_old_cookieverf is None:
            raise TypeError('data.nv_old_cookieverf == None')
        self.pack_verifier4(data.nv_old_cookieverf)
        if data.nv_new_cookieverf is None:
            raise TypeError('data.nv_new_cookieverf == None')
        self.pack_verifier4(data.nv_new_cookieverf)

    def pack_notifylist4(self, data):
        if hasattr(self, 'filter_notifylist4'):
            data = getattr(self, 'filter_notifylist4')(data)
        self.pack_opaque(data)

    def pack_notify4(self, data):
        if hasattr(self, 'filter_notify4'):
            data = getattr(self, 'filter_notify4')(data)
        if data.notify_mask is None:
            raise TypeError('data.notify_mask == None')
        self.pack_bitmap4(data.notify_mask)
        if data.notify_vals is None:
            raise TypeError('data.notify_vals == None')
        self.pack_notifylist4(data.notify_vals)

    def pack_CB_NOTIFY4args(self, data):
        if hasattr(self, 'filter_CB_NOTIFY4args'):
            data = getattr(self, 'filter_CB_NOTIFY4args')(data)
        if data.cna_stateid is None:
            raise TypeError('data.cna_stateid == None')
        self.pack_stateid4(data.cna_stateid)
        if data.cna_fh is None:
            raise TypeError('data.cna_fh == None')
        self.pack_nfs_fh4(data.cna_fh)
        if data.cna_changes is None:
            raise TypeError('data.cna_changes == None')
        self.pack_array(data.cna_changes, self.pack_notify4)

    def pack_CB_NOTIFY4res(self, data):
        if hasattr(self, 'filter_CB_NOTIFY4res'):
            data = getattr(self, 'filter_CB_NOTIFY4res')(data)
        if data.cnr_status is None:
            raise TypeError('data.cnr_status == None')
        self.pack_nfsstat4(data.cnr_status)

    def pack_CB_PUSH_DELEG4args(self, data):
        if hasattr(self, 'filter_CB_PUSH_DELEG4args'):
            data = getattr(self, 'filter_CB_PUSH_DELEG4args')(data)
        if data.cpda_fh is None:
            raise TypeError('data.cpda_fh == None')
        self.pack_nfs_fh4(data.cpda_fh)
        if data.cpda_delegation is None:
            raise TypeError('data.cpda_delegation == None')
        self.pack_open_delegation4(data.cpda_delegation)

    def pack_CB_PUSH_DELEG4res(self, data):
        if hasattr(self, 'filter_CB_PUSH_DELEG4res'):
            data = getattr(self, 'filter_CB_PUSH_DELEG4res')(data)
        if data.cpdr_status is None:
            raise TypeError('data.cpdr_status == None')
        self.pack_nfsstat4(data.cpdr_status)

    def pack_CB_RECALL_ANY4args(self, data):
        if hasattr(self, 'filter_CB_RECALL_ANY4args'):
            data = getattr(self, 'filter_CB_RECALL_ANY4args')(data)
        if data.craa_objects_to_keep is None:
            raise TypeError('data.craa_objects_to_keep == None')
        self.pack_uint32_t(data.craa_objects_to_keep)
        if data.craa_type_mask is None:
            raise TypeError('data.craa_type_mask == None')
        self.pack_bitmap4(data.craa_type_mask)

    def pack_CB_RECALL_ANY4res(self, data):
        if hasattr(self, 'filter_CB_RECALL_ANY4res'):
            data = getattr(self, 'filter_CB_RECALL_ANY4res')(data)
        if data.crar_status is None:
            raise TypeError('data.crar_status == None')
        self.pack_nfsstat4(data.crar_status)

    pack_CB_RECALLABLE_OBJ_AVAIL4args = pack_CB_RECALL_ANY4args

    def pack_CB_RECALLABLE_OBJ_AVAIL4res(self, data):
        if hasattr(self, 'filter_CB_RECALLABLE_OBJ_AVAIL4res'):
            data = getattr(self, 'filter_CB_RECALLABLE_OBJ_AVAIL4res')(data)
        if data.croa_status is None:
            raise TypeError('data.croa_status == None')
        self.pack_nfsstat4(data.croa_status)

    def pack_CB_RECALL_SLOT4args(self, data):
        if hasattr(self, 'filter_CB_RECALL_SLOT4args'):
            data = getattr(self, 'filter_CB_RECALL_SLOT4args')(data)
        if data.rsa_target_highest_slotid is None:
            raise TypeError('data.rsa_target_highest_slotid == None')
        self.pack_slotid4(data.rsa_target_highest_slotid)

    def pack_CB_RECALL_SLOT4res(self, data):
        if hasattr(self, 'filter_CB_RECALL_SLOT4res'):
            data = getattr(self, 'filter_CB_RECALL_SLOT4res')(data)
        if data.rsr_status is None:
            raise TypeError('data.rsr_status == None')
        self.pack_nfsstat4(data.rsr_status)

    def pack_referring_call4(self, data):
        if hasattr(self, 'filter_referring_call4'):
            data = getattr(self, 'filter_referring_call4')(data)
        if data.rc_sequenceid is None:
            raise TypeError('data.rc_sequenceid == None')
        self.pack_sequenceid4(data.rc_sequenceid)
        if data.rc_slotid is None:
            raise TypeError('data.rc_slotid == None')
        self.pack_slotid4(data.rc_slotid)

    def pack_referring_call_list4(self, data):
        if hasattr(self, 'filter_referring_call_list4'):
            data = getattr(self, 'filter_referring_call_list4')(data)
        if data.rcl_sessionid is None:
            raise TypeError('data.rcl_sessionid == None')
        self.pack_sessionid4(data.rcl_sessionid)
        if data.rcl_referring_calls is None:
            raise TypeError('data.rcl_referring_calls == None')
        self.pack_array(data.rcl_referring_calls, self.pack_referring_call4)

    def pack_CB_SEQUENCE4args(self, data):
        if hasattr(self, 'filter_CB_SEQUENCE4args'):
            data = getattr(self, 'filter_CB_SEQUENCE4args')(data)
        if data.csa_sessionid is None:
            raise TypeError('data.csa_sessionid == None')
        self.pack_sessionid4(data.csa_sessionid)
        if data.csa_sequenceid is None:
            raise TypeError('data.csa_sequenceid == None')
        self.pack_sequenceid4(data.csa_sequenceid)
        if data.csa_slotid is None:
            raise TypeError('data.csa_slotid == None')
        self.pack_slotid4(data.csa_slotid)
        if data.csa_highest_slotid is None:
            raise TypeError('data.csa_highest_slotid == None')
        self.pack_slotid4(data.csa_highest_slotid)
        if data.csa_cachethis is None:
            raise TypeError('data.csa_cachethis == None')
        self.pack_bool(data.csa_cachethis)
        if data.csa_referring_call_lists is None:
            raise TypeError('data.csa_referring_call_lists == None')
        self.pack_array(data.csa_referring_call_lists, self.pack_referring_call_list4)

    def pack_CB_SEQUENCE4resok(self, data):
        if hasattr(self, 'filter_CB_SEQUENCE4resok'):
            data = getattr(self, 'filter_CB_SEQUENCE4resok')(data)
        if data.csr_sessionid is None:
            raise TypeError('data.csr_sessionid == None')
        self.pack_sessionid4(data.csr_sessionid)
        if data.csr_sequenceid is None:
            raise TypeError('data.csr_sequenceid == None')
        self.pack_sequenceid4(data.csr_sequenceid)
        if data.csr_slotid is None:
            raise TypeError('data.csr_slotid == None')
        self.pack_slotid4(data.csr_slotid)
        if data.csr_highest_slotid is None:
            raise TypeError('data.csr_highest_slotid == None')
        self.pack_slotid4(data.csr_highest_slotid)
        if data.csr_target_highest_slotid is None:
            raise TypeError('data.csr_target_highest_slotid == None')
        self.pack_slotid4(data.csr_target_highest_slotid)

    def pack_CB_SEQUENCE4res(self, data):
        if hasattr(self, 'filter_CB_SEQUENCE4res'):
            data = getattr(self, 'filter_CB_SEQUENCE4res')(data)
        if data.csr_status is None:
            raise TypeError('data.csr_status == None')
        self.pack_nfsstat4(data.csr_status)
        if data.csr_status == const.NFS4_OK:
            if data.csr_resok4 is None:
                raise TypeError('data.csr_resok4 == None')
            self.pack_CB_SEQUENCE4resok(data.csr_resok4)
        else:
            pass

    def pack_CB_WANTS_CANCELLED4args(self, data):
        if hasattr(self, 'filter_CB_WANTS_CANCELLED4args'):
            data = getattr(self, 'filter_CB_WANTS_CANCELLED4args')(data)
        if data.cwca_contended_wants_cancelled is None:
            raise TypeError('data.cwca_contended_wants_cancelled == None')
        self.pack_bool(data.cwca_contended_wants_cancelled)
        if data.cwca_resourced_wants_cancelled is None:
            raise TypeError('data.cwca_resourced_wants_cancelled == None')
        self.pack_bool(data.cwca_resourced_wants_cancelled)

    def pack_CB_WANTS_CANCELLED4res(self, data):
        if hasattr(self, 'filter_CB_WANTS_CANCELLED4res'):
            data = getattr(self, 'filter_CB_WANTS_CANCELLED4res')(data)
        if data.cwcr_status is None:
            raise TypeError('data.cwcr_status == None')
        self.pack_nfsstat4(data.cwcr_status)

    def pack_CB_NOTIFY_LOCK4args(self, data):
        if hasattr(self, 'filter_CB_NOTIFY_LOCK4args'):
            data = getattr(self, 'filter_CB_NOTIFY_LOCK4args')(data)
        if data.cnla_fh is None:
            raise TypeError('data.cnla_fh == None')
        self.pack_nfs_fh4(data.cnla_fh)
        if data.cnla_lock_owner is None:
            raise TypeError('data.cnla_lock_owner == None')
        self.pack_lock_owner4(data.cnla_lock_owner)

    def pack_CB_NOTIFY_LOCK4res(self, data):
        if hasattr(self, 'filter_CB_NOTIFY_LOCK4res'):
            data = getattr(self, 'filter_CB_NOTIFY_LOCK4res')(data)
        if data.cnlr_status is None:
            raise TypeError('data.cnlr_status == None')
        self.pack_nfsstat4(data.cnlr_status)

    def pack_notify_deviceid_type4(self, data):
        if hasattr(self, 'filter_notify_deviceid_type4'):
            data = getattr(self, 'filter_notify_deviceid_type4')(data)
        if self.check_enum and data not in [const.NOTIFY_DEVICEID4_CHANGE, const.NOTIFY_DEVICEID4_DELETE]:
            raise XDRError('value=%s not in enum notify_deviceid_type4' % data)
        self.pack_int(data)

    def pack_notify_deviceid_delete4(self, data):
        if hasattr(self, 'filter_notify_deviceid_delete4'):
            data = getattr(self, 'filter_notify_deviceid_delete4')(data)
        if data.ndd_layouttype is None:
            raise TypeError('data.ndd_layouttype == None')
        self.pack_layouttype4(data.ndd_layouttype)
        if data.ndd_deviceid is None:
            raise TypeError('data.ndd_deviceid == None')
        self.pack_deviceid4(data.ndd_deviceid)

    def pack_notify_deviceid_change4(self, data):
        if hasattr(self, 'filter_notify_deviceid_change4'):
            data = getattr(self, 'filter_notify_deviceid_change4')(data)
        if data.ndc_layouttype is None:
            raise TypeError('data.ndc_layouttype == None')
        self.pack_layouttype4(data.ndc_layouttype)
        if data.ndc_deviceid is None:
            raise TypeError('data.ndc_deviceid == None')
        self.pack_deviceid4(data.ndc_deviceid)
        if data.ndc_immediate is None:
            raise TypeError('data.ndc_immediate == None')
        self.pack_bool(data.ndc_immediate)

    def pack_CB_NOTIFY_DEVICEID4args(self, data):
        if hasattr(self, 'filter_CB_NOTIFY_DEVICEID4args'):
            data = getattr(self, 'filter_CB_NOTIFY_DEVICEID4args')(data)
        if data.cnda_changes is None:
            raise TypeError('data.cnda_changes == None')
        self.pack_array(data.cnda_changes, self.pack_notify4)

    def pack_CB_NOTIFY_DEVICEID4res(self, data):
        if hasattr(self, 'filter_CB_NOTIFY_DEVICEID4res'):
            data = getattr(self, 'filter_CB_NOTIFY_DEVICEID4res')(data)
        if data.cndr_status is None:
            raise TypeError('data.cndr_status == None')
        self.pack_nfsstat4(data.cndr_status)

    def pack_offload_info4(self, data):
        if hasattr(self, 'filter_offload_info4'):
            data = getattr(self, 'filter_offload_info4')(data)
        if data.coa_status is None:
            raise TypeError('data.coa_status == None')
        self.pack_nfsstat4(data.coa_status)
        if data.coa_status == const.NFS4_OK:
            if data.coa_resok4 is None:
                raise TypeError('data.coa_resok4 == None')
            self.pack_write_response4(data.coa_resok4)
        else:
            if data.coa_bytes_copied is None:
                raise TypeError('data.coa_bytes_copied == None')
            self.pack_length4(data.coa_bytes_copied)

    def pack_CB_OFFLOAD4args(self, data):
        if hasattr(self, 'filter_CB_OFFLOAD4args'):
            data = getattr(self, 'filter_CB_OFFLOAD4args')(data)
        if data.coa_fh is None:
            raise TypeError('data.coa_fh == None')
        self.pack_nfs_fh4(data.coa_fh)
        if data.coa_stateid is None:
            raise TypeError('data.coa_stateid == None')
        self.pack_stateid4(data.coa_stateid)
        if data.coa_offload_info is None:
            raise TypeError('data.coa_offload_info == None')
        self.pack_offload_info4(data.coa_offload_info)

    def pack_CB_OFFLOAD4res(self, data):
        if hasattr(self, 'filter_CB_OFFLOAD4res'):
            data = getattr(self, 'filter_CB_OFFLOAD4res')(data)
        if data.cor_status is None:
            raise TypeError('data.cor_status == None')
        self.pack_nfsstat4(data.cor_status)

    def pack_nfs_cb_opnum4(self, data):
        if hasattr(self, 'filter_nfs_cb_opnum4'):
            data = getattr(self, 'filter_nfs_cb_opnum4')(data)
        if self.check_enum and data not in [const.OP_CB_GETATTR, const.OP_CB_RECALL, const.OP_CB_LAYOUTRECALL, const.OP_CB_NOTIFY, const.OP_CB_PUSH_DELEG, const.OP_CB_RECALL_ANY, const.OP_CB_RECALLABLE_OBJ_AVAIL, const.OP_CB_RECALL_SLOT, const.OP_CB_SEQUENCE, const.OP_CB_WANTS_CANCELLED, const.OP_CB_NOTIFY_LOCK, const.OP_CB_NOTIFY_DEVICEID, const.OP_CB_OFFLOAD, const.OP_CB_ILLEGAL]:
            raise XDRError('value=%s not in enum nfs_cb_opnum4' % data)
        self.pack_int(data)

    def pack_nfs_cb_argop4(self, data):
        if hasattr(self, 'filter_nfs_cb_argop4'):
            data = getattr(self, 'filter_nfs_cb_argop4')(data)
        if data.argop is None:
            raise TypeError('data.argop == None')
        self.pack_unsigned(data.argop)
        if data.argop == const.OP_CB_GETATTR:
            if data.opcbgetattr is None:
                raise TypeError('data.opcbgetattr == None')
            self.pack_CB_GETATTR4args(data.opcbgetattr)
        elif data.argop == const.OP_CB_RECALL:
            if data.opcbrecall is None:
                raise TypeError('data.opcbrecall == None')
            self.pack_CB_RECALL4args(data.opcbrecall)
        elif data.argop == const.OP_CB_LAYOUTRECALL:
            if data.opcblayoutrecall is None:
                raise TypeError('data.opcblayoutrecall == None')
            self.pack_CB_LAYOUTRECALL4args(data.opcblayoutrecall)
        elif data.argop == const.OP_CB_NOTIFY:
            if data.opcbnotify is None:
                raise TypeError('data.opcbnotify == None')
            self.pack_CB_NOTIFY4args(data.opcbnotify)
        elif data.argop == const.OP_CB_PUSH_DELEG:
            if data.opcbpush_deleg is None:
                raise TypeError('data.opcbpush_deleg == None')
            self.pack_CB_PUSH_DELEG4args(data.opcbpush_deleg)
        elif data.argop == const.OP_CB_RECALL_ANY:
            if data.opcbrecall_any is None:
                raise TypeError('data.opcbrecall_any == None')
            self.pack_CB_RECALL_ANY4args(data.opcbrecall_any)
        elif data.argop == const.OP_CB_RECALLABLE_OBJ_AVAIL:
            if data.opcbrecallable_obj_avail is None:
                raise TypeError('data.opcbrecallable_obj_avail == None')
            self.pack_CB_RECALLABLE_OBJ_AVAIL4args(data.opcbrecallable_obj_avail)
        elif data.argop == const.OP_CB_RECALL_SLOT:
            if data.opcbrecall_slot is None:
                raise TypeError('data.opcbrecall_slot == None')
            self.pack_CB_RECALL_SLOT4args(data.opcbrecall_slot)
        elif data.argop == const.OP_CB_SEQUENCE:
            if data.opcbsequence is None:
                raise TypeError('data.opcbsequence == None')
            self.pack_CB_SEQUENCE4args(data.opcbsequence)
        elif data.argop == const.OP_CB_WANTS_CANCELLED:
            if data.opcbwants_cancelled is None:
                raise TypeError('data.opcbwants_cancelled == None')
            self.pack_CB_WANTS_CANCELLED4args(data.opcbwants_cancelled)
        elif data.argop == const.OP_CB_NOTIFY_LOCK:
            if data.opcbnotify_lock is None:
                raise TypeError('data.opcbnotify_lock == None')
            self.pack_CB_NOTIFY_LOCK4args(data.opcbnotify_lock)
        elif data.argop == const.OP_CB_NOTIFY_DEVICEID:
            if data.opcbnotify_deviceid is None:
                raise TypeError('data.opcbnotify_deviceid == None')
            self.pack_CB_NOTIFY_DEVICEID4args(data.opcbnotify_deviceid)
        elif data.argop == const.OP_CB_OFFLOAD:
            if data.opcboffload is None:
                raise TypeError('data.opcboffload == None')
            self.pack_CB_OFFLOAD4args(data.opcboffload)
        elif data.argop == const.OP_CB_ILLEGAL:
            pass
        else:
            raise XDRError('bad switch=%s' % data.argop)

    def pack_nfs_cb_resop4(self, data):
        if hasattr(self, 'filter_nfs_cb_resop4'):
            data = getattr(self, 'filter_nfs_cb_resop4')(data)
        if data.resop is None:
            raise TypeError('data.resop == None')
        self.pack_unsigned(data.resop)
        if data.resop == const.OP_CB_GETATTR:
            if data.opcbgetattr is None:
                raise TypeError('data.opcbgetattr == None')
            self.pack_CB_GETATTR4res(data.opcbgetattr)
        elif data.resop == const.OP_CB_RECALL:
            if data.opcbrecall is None:
                raise TypeError('data.opcbrecall == None')
            self.pack_CB_RECALL4res(data.opcbrecall)
        elif data.resop == const.OP_CB_LAYOUTRECALL:
            if data.opcblayoutrecall is None:
                raise TypeError('data.opcblayoutrecall == None')
            self.pack_CB_LAYOUTRECALL4res(data.opcblayoutrecall)
        elif data.resop == const.OP_CB_NOTIFY:
            if data.opcbnotify is None:
                raise TypeError('data.opcbnotify == None')
            self.pack_CB_NOTIFY4res(data.opcbnotify)
        elif data.resop == const.OP_CB_PUSH_DELEG:
            if data.opcbpush_deleg is None:
                raise TypeError('data.opcbpush_deleg == None')
            self.pack_CB_PUSH_DELEG4res(data.opcbpush_deleg)
        elif data.resop == const.OP_CB_RECALL_ANY:
            if data.opcbrecall_any is None:
                raise TypeError('data.opcbrecall_any == None')
            self.pack_CB_RECALL_ANY4res(data.opcbrecall_any)
        elif data.resop == const.OP_CB_RECALLABLE_OBJ_AVAIL:
            if data.opcbrecallable_obj_avail is None:
                raise TypeError('data.opcbrecallable_obj_avail == None')
            self.pack_CB_RECALLABLE_OBJ_AVAIL4res(data.opcbrecallable_obj_avail)
        elif data.resop == const.OP_CB_RECALL_SLOT:
            if data.opcbrecall_slot is None:
                raise TypeError('data.opcbrecall_slot == None')
            self.pack_CB_RECALL_SLOT4res(data.opcbrecall_slot)
        elif data.resop == const.OP_CB_SEQUENCE:
            if data.opcbsequence is None:
                raise TypeError('data.opcbsequence == None')
            self.pack_CB_SEQUENCE4res(data.opcbsequence)
        elif data.resop == const.OP_CB_WANTS_CANCELLED:
            if data.opcbwants_cancelled is None:
                raise TypeError('data.opcbwants_cancelled == None')
            self.pack_CB_WANTS_CANCELLED4res(data.opcbwants_cancelled)
        elif data.resop == const.OP_CB_NOTIFY_LOCK:
            if data.opcbnotify_lock is None:
                raise TypeError('data.opcbnotify_lock == None')
            self.pack_CB_NOTIFY_LOCK4res(data.opcbnotify_lock)
        elif data.resop == const.OP_CB_NOTIFY_DEVICEID:
            if data.opcbnotify_deviceid is None:
                raise TypeError('data.opcbnotify_deviceid == None')
            self.pack_CB_NOTIFY_DEVICEID4res(data.opcbnotify_deviceid)
        elif data.resop == const.OP_CB_OFFLOAD:
            if data.opcboffload is None:
                raise TypeError('data.opcboffload == None')
            self.pack_CB_OFFLOAD4res(data.opcboffload)
        elif data.resop == const.OP_CB_ILLEGAL:
            if data.opcbillegal is None:
                raise TypeError('data.opcbillegal == None')
            self.pack_CB_ILLEGAL4res(data.opcbillegal)
        else:
            raise XDRError('bad switch=%s' % data.resop)

    def pack_CB_COMPOUND4args(self, data):
        if hasattr(self, 'filter_CB_COMPOUND4args'):
            data = getattr(self, 'filter_CB_COMPOUND4args')(data)
        if data.tag is None:
            raise TypeError('data.tag == None')
        self.pack_utf8str_cs(data.tag)
        if data.minorversion is None:
            raise TypeError('data.minorversion == None')
        self.pack_uint32_t(data.minorversion)
        if data.callback_ident is None:
            raise TypeError('data.callback_ident == None')
        self.pack_uint32_t(data.callback_ident)
        if data.argarray is None:
            raise TypeError('data.argarray == None')
        self.pack_array(data.argarray, self.pack_nfs_cb_argop4)

    def pack_CB_COMPOUND4res(self, data):
        if hasattr(self, 'filter_CB_COMPOUND4res'):
            data = getattr(self, 'filter_CB_COMPOUND4res')(data)
        if data.status is None:
            raise TypeError('data.status == None')
        self.pack_nfsstat4(data.status)
        if data.tag is None:
            raise TypeError('data.tag == None')
        self.pack_utf8str_cs(data.tag)
        if data.resarray is None:
            raise TypeError('data.resarray == None')
        self.pack_array(data.resarray, self.pack_nfs_cb_resop4)

    pack_fattr4_offline = pack_bool

    def pack_open_arguments4(self, data):
        if hasattr(self, 'filter_open_arguments4'):
            data = getattr(self, 'filter_open_arguments4')(data)
        if data.oa_share_access is None:
            raise TypeError('data.oa_share_access == None')
        self.pack_bitmap4(data.oa_share_access)
        if data.oa_share_deny is None:
            raise TypeError('data.oa_share_deny == None')
        self.pack_bitmap4(data.oa_share_deny)
        if data.oa_share_access_want is None:
            raise TypeError('data.oa_share_access_want == None')
        self.pack_bitmap4(data.oa_share_access_want)
        if data.oa_open_claim is None:
            raise TypeError('data.oa_open_claim == None')
        self.pack_bitmap4(data.oa_open_claim)
        if data.oa_create_mode is None:
            raise TypeError('data.oa_create_mode == None')
        self.pack_bitmap4(data.oa_create_mode)

    def pack_open_args_share_access4(self, data):
        if hasattr(self, 'filter_open_args_share_access4'):
            data = getattr(self, 'filter_open_args_share_access4')(data)
        if self.check_enum and data not in [const.OPEN_ARGS_SHARE_ACCESS_READ, const.OPEN_ARGS_SHARE_ACCESS_WRITE, const.OPEN_ARGS_SHARE_ACCESS_BOTH]:
            raise XDRError('value=%s not in enum open_args_share_access4' % data)
        self.pack_int(data)

    def pack_open_args_share_deny4(self, data):
        if hasattr(self, 'filter_open_args_share_deny4'):
            data = getattr(self, 'filter_open_args_share_deny4')(data)
        if self.check_enum and data not in [const.OPEN_ARGS_SHARE_DENY_NONE, const.OPEN_ARGS_SHARE_DENY_READ, const.OPEN_ARGS_SHARE_DENY_WRITE, const.OPEN_ARGS_SHARE_DENY_BOTH]:
            raise XDRError('value=%s not in enum open_args_share_deny4' % data)
        self.pack_int(data)

    def pack_open_args_share_access_want4(self, data):
        if hasattr(self, 'filter_open_args_share_access_want4'):
            data = getattr(self, 'filter_open_args_share_access_want4')(data)
        if self.check_enum and data not in [const.OPEN_ARGS_SHARE_ACCESS_WANT_ANY_DELEG, const.OPEN_ARGS_SHARE_ACCESS_WANT_NO_DELEG, const.OPEN_ARGS_SHARE_ACCESS_WANT_CANCEL, const.OPEN_ARGS_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL, const.OPEN_ARGS_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED, const.OPEN_ARGS_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS, const.OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION]:
            raise XDRError('value=%s not in enum open_args_share_access_want4' % data)
        self.pack_int(data)

    def pack_open_args_open_claim4(self, data):
        if hasattr(self, 'filter_open_args_open_claim4'):
            data = getattr(self, 'filter_open_args_open_claim4')(data)
        if self.check_enum and data not in [const.OPEN_ARGS_OPEN_CLAIM_NULL, const.OPEN_ARGS_OPEN_CLAIM_PREVIOUS, const.OPEN_ARGS_OPEN_CLAIM_DELEGATE_CUR, const.OPEN_ARGS_OPEN_CLAIM_DELEGATE_PREV, const.OPEN_ARGS_OPEN_CLAIM_FH, const.OPEN_ARGS_OPEN_CLAIM_DELEG_CUR_FH, const.OPEN_ARGS_OPEN_CLAIM_DELEG_PREV_FH]:
            raise XDRError('value=%s not in enum open_args_open_claim4' % data)
        self.pack_int(data)

    def pack_open_args_createmode4(self, data):
        if hasattr(self, 'filter_open_args_createmode4'):
            data = getattr(self, 'filter_open_args_createmode4')(data)
        if self.check_enum and data not in [const.OPEN_ARGS_CREATEMODE_UNCHECKED4, const.OPEN_ARGS_CREATE_MODE_GUARDED, const.OPEN_ARGS_CREATEMODE_EXCLUSIVE4, const.OPEN_ARGS_CREATE_MODE_EXCLUSIVE4_1]:
            raise XDRError('value=%s not in enum open_args_createmode4' % data)
        self.pack_int(data)

    pack_fattr4_open_arguments = pack_open_arguments4

    pack_fattr4_time_deleg_access = pack_nfstime4

    pack_fattr4_time_deleg_modify = pack_nfstime4

class NFS4Unpacker(xdrlib.Unpacker):
    def __init__(self, data, check_enum=True, check_array=True):
        xdrlib.Unpacker.__init__(self, data)
        self.check_enum = check_enum
        self.check_array = check_array

    unpack_int = xdrlib.Unpacker.unpack_int
    unpack_uint = xdrlib.Unpacker.unpack_uint
    unpack_unsigned = xdrlib.Unpacker.unpack_uint
    unpack_hyper = xdrlib.Unpacker.unpack_hyper
    unpack_uhyper = xdrlib.Unpacker.unpack_uhyper
    unpack_float = xdrlib.Unpacker.unpack_float
    unpack_double = xdrlib.Unpacker.unpack_double
    unpack_quadruple = xdrlib.Unpacker.unpack_double
    unpack_bool = xdrlib.Unpacker.unpack_bool
    unpack_opaque = xdrlib.Unpacker.unpack_opaque
    unpack_string = xdrlib.Unpacker.unpack_string
    def unpack_authsys_parms(self):
        data = types.authsys_parms()
        data.stamp = self.unpack_uint()
        data.machinename = self.unpack_string()
        if len(data.machinename) > 255 and self.check_array:
            raise XDRError('array length too long for data.machinename')
        data.uid = self.unpack_uint()
        data.gid = self.unpack_uint()
        data.gids = self.unpack_array(self.unpack_uint)
        if len(data.gids) > 16 and self.check_array:
            raise XDRError('array length too long for data.gids')
        if hasattr(self, 'filter_authsys_parms'):
            data = getattr(self, 'filter_authsys_parms')(data)
        return data

    unpack_int32_t = unpack_int

    unpack_uint32_t = unpack_uint

    unpack_int64_t = unpack_hyper

    unpack_uint64_t = unpack_uhyper

    def unpack_nfs_ftype4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NF4REG, const.NF4DIR, const.NF4BLK, const.NF4CHR, const.NF4LNK, const.NF4SOCK, const.NF4FIFO, const.NF4ATTRDIR, const.NF4NAMEDATTR]:
            raise XDRError('value=%s not in enum nfs_ftype4' % data)
        if hasattr(self, 'filter_nfs_ftype4'):
            data = getattr(self, 'filter_nfs_ftype4')(data)
        return data

    def unpack_nfsstat4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NFS4_OK, const.NFS4ERR_PERM, const.NFS4ERR_NOENT, const.NFS4ERR_IO, const.NFS4ERR_NXIO, const.NFS4ERR_ACCESS, const.NFS4ERR_EXIST, const.NFS4ERR_XDEV, const.NFS4ERR_NOTDIR, const.NFS4ERR_ISDIR, const.NFS4ERR_INVAL, const.NFS4ERR_FBIG, const.NFS4ERR_NOSPC, const.NFS4ERR_ROFS, const.NFS4ERR_MLINK, const.NFS4ERR_NAMETOOLONG, const.NFS4ERR_NOTEMPTY, const.NFS4ERR_DQUOT, const.NFS4ERR_STALE, const.NFS4ERR_BADHANDLE, const.NFS4ERR_BAD_COOKIE, const.NFS4ERR_NOTSUPP, const.NFS4ERR_TOOSMALL, const.NFS4ERR_SERVERFAULT, const.NFS4ERR_BADTYPE, const.NFS4ERR_DELAY, const.NFS4ERR_SAME, const.NFS4ERR_DENIED, const.NFS4ERR_EXPIRED, const.NFS4ERR_LOCKED, const.NFS4ERR_GRACE, const.NFS4ERR_FHEXPIRED, const.NFS4ERR_SHARE_DENIED, const.NFS4ERR_WRONGSEC, const.NFS4ERR_CLID_INUSE, const.NFS4ERR_RESOURCE, const.NFS4ERR_MOVED, const.NFS4ERR_NOFILEHANDLE, const.NFS4ERR_MINOR_VERS_MISMATCH, const.NFS4ERR_STALE_CLIENTID, const.NFS4ERR_STALE_STATEID, const.NFS4ERR_OLD_STATEID, const.NFS4ERR_BAD_STATEID, const.NFS4ERR_BAD_SEQID, const.NFS4ERR_NOT_SAME, const.NFS4ERR_LOCK_RANGE, const.NFS4ERR_SYMLINK, const.NFS4ERR_RESTOREFH, const.NFS4ERR_LEASE_MOVED, const.NFS4ERR_ATTRNOTSUPP, const.NFS4ERR_NO_GRACE, const.NFS4ERR_RECLAIM_BAD, const.NFS4ERR_RECLAIM_CONFLICT, const.NFS4ERR_BADXDR, const.NFS4ERR_LOCKS_HELD, const.NFS4ERR_OPENMODE, const.NFS4ERR_BADOWNER, const.NFS4ERR_BADCHAR, const.NFS4ERR_BADNAME, const.NFS4ERR_BAD_RANGE, const.NFS4ERR_LOCK_NOTSUPP, const.NFS4ERR_OP_ILLEGAL, const.NFS4ERR_DEADLOCK, const.NFS4ERR_FILE_OPEN, const.NFS4ERR_ADMIN_REVOKED, const.NFS4ERR_CB_PATH_DOWN, const.NFS4ERR_BADIOMODE, const.NFS4ERR_BADLAYOUT, const.NFS4ERR_BAD_SESSION_DIGEST, const.NFS4ERR_BADSESSION, const.NFS4ERR_BADSLOT, const.NFS4ERR_COMPLETE_ALREADY, const.NFS4ERR_CONN_NOT_BOUND_TO_SESSION, const.NFS4ERR_DELEG_ALREADY_WANTED, const.NFS4ERR_BACK_CHAN_BUSY, const.NFS4ERR_LAYOUTTRYLATER, const.NFS4ERR_LAYOUTUNAVAILABLE, const.NFS4ERR_NOMATCHING_LAYOUT, const.NFS4ERR_RECALLCONFLICT, const.NFS4ERR_UNKNOWN_LAYOUTTYPE, const.NFS4ERR_SEQ_MISORDERED, const.NFS4ERR_SEQUENCE_POS, const.NFS4ERR_REQ_TOO_BIG, const.NFS4ERR_REP_TOO_BIG, const.NFS4ERR_REP_TOO_BIG_TO_CACHE, const.NFS4ERR_RETRY_UNCACHED_REP, const.NFS4ERR_UNSAFE_COMPOUND, const.NFS4ERR_TOO_MANY_OPS, const.NFS4ERR_OP_NOT_IN_SESSION, const.NFS4ERR_HASH_ALG_UNSUPP, const.NFS4ERR_CLIENTID_BUSY, const.NFS4ERR_PNFS_IO_HOLE, const.NFS4ERR_SEQ_FALSE_RETRY, const.NFS4ERR_BAD_HIGH_SLOT, const.NFS4ERR_DEADSESSION, const.NFS4ERR_ENCR_ALG_UNSUPP, const.NFS4ERR_PNFS_NO_LAYOUT, const.NFS4ERR_NOT_ONLY_OP, const.NFS4ERR_WRONG_CRED, const.NFS4ERR_WRONG_TYPE, const.NFS4ERR_DIRDELEG_UNAVAIL, const.NFS4ERR_REJECT_DELEG, const.NFS4ERR_RETURNCONFLICT, const.NFS4ERR_DELEG_REVOKED, const.NFS4ERR_PARTNER_NOTSUPP, const.NFS4ERR_PARTNER_NO_AUTH, const.NFS4ERR_UNION_NOTSUPP, const.NFS4ERR_OFFLOAD_DENIED, const.NFS4ERR_WRONG_LFS, const.NFS4ERR_BADLABEL, const.NFS4ERR_OFFLOAD_NO_REQS, const.NFS4ERR_NOXATTR, const.NFS4ERR_XATTR2BIG]:
            raise XDRError('value=%s not in enum nfsstat4' % data)
        if hasattr(self, 'filter_nfsstat4'):
            data = getattr(self, 'filter_nfsstat4')(data)
        return data

    def unpack_attrlist4(self):
        data = self.unpack_opaque()
        if hasattr(self, 'filter_attrlist4'):
            data = getattr(self, 'filter_attrlist4')(data)
        return data

    def unpack_bitmap4(self):
        data = self.unpack_array(self.unpack_uint32_t)
        if hasattr(self, 'filter_bitmap4'):
            data = getattr(self, 'filter_bitmap4')(data)
        return data

    unpack_changeid4 = unpack_uint64_t

    unpack_clientid4 = unpack_uint64_t

    unpack_count4 = unpack_uint32_t

    unpack_length4 = unpack_uint64_t

    unpack_mode4 = unpack_uint32_t

    unpack_nfs_cookie4 = unpack_uint64_t

    def unpack_nfs_fh4(self):
        data = self.unpack_opaque()
        if len(data) > const.NFS4_FHSIZE and self.check_array:
            raise XDRError('array length too long for data')
        if hasattr(self, 'filter_nfs_fh4'):
            data = getattr(self, 'filter_nfs_fh4')(data)
        return data

    unpack_offset4 = unpack_uint64_t

    unpack_qop4 = unpack_uint32_t

    def unpack_sec_oid4(self):
        data = self.unpack_opaque()
        if hasattr(self, 'filter_sec_oid4'):
            data = getattr(self, 'filter_sec_oid4')(data)
        return data

    unpack_sequenceid4 = unpack_uint32_t

    unpack_seqid4 = unpack_uint32_t

    def unpack_sessionid4(self):
        data = self.unpack_fopaque(const.NFS4_SESSIONID_SIZE)
        if hasattr(self, 'filter_sessionid4'):
            data = getattr(self, 'filter_sessionid4')(data)
        return data

    unpack_slotid4 = unpack_uint32_t

    def unpack_utf8string(self):
        data = self.unpack_opaque()
        if hasattr(self, 'filter_utf8string'):
            data = getattr(self, 'filter_utf8string')(data)
        return data

    unpack_utf8str_cis = unpack_utf8string

    unpack_utf8str_cs = unpack_utf8string

    unpack_utf8str_mixed = unpack_utf8string

    unpack_component4 = unpack_utf8str_cs

    def unpack_linktext4(self):
        data = self.unpack_opaque()
        if hasattr(self, 'filter_linktext4'):
            data = getattr(self, 'filter_linktext4')(data)
        return data

    unpack_ascii_REQUIRED4 = unpack_utf8string

    def unpack_pathname4(self):
        data = self.unpack_array(self.unpack_component4)
        if hasattr(self, 'filter_pathname4'):
            data = getattr(self, 'filter_pathname4')(data)
        return data

    def unpack_verifier4(self):
        data = self.unpack_fopaque(const.NFS4_VERIFIER_SIZE)
        if hasattr(self, 'filter_verifier4'):
            data = getattr(self, 'filter_verifier4')(data)
        return data

    def unpack_secret4(self):
        data = self.unpack_string()
        if hasattr(self, 'filter_secret4'):
            data = getattr(self, 'filter_secret4')(data)
        return data

    unpack_policy4 = unpack_uint32_t

    def unpack_nfstime4(self):
        data = types.nfstime4()
        data.seconds = self.unpack_int64_t()
        data.nseconds = self.unpack_uint32_t()
        if hasattr(self, 'filter_nfstime4'):
            data = getattr(self, 'filter_nfstime4')(data)
        return data

    def unpack_time_how4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.SET_TO_SERVER_TIME4, const.SET_TO_CLIENT_TIME4]:
            raise XDRError('value=%s not in enum time_how4' % data)
        if hasattr(self, 'filter_time_how4'):
            data = getattr(self, 'filter_time_how4')(data)
        return data

    def unpack_settime4(self):
        data = types.settime4()
        data.set_it = self.unpack_time_how4()
        if data.set_it == const.SET_TO_CLIENT_TIME4:
            data.time = self.unpack_nfstime4()
        else:
            pass
        if hasattr(self, 'filter_settime4'):
            data = getattr(self, 'filter_settime4')(data)
        return data

    unpack_nfs_lease4 = unpack_uint32_t

    def unpack_fsid4(self):
        data = types.fsid4()
        data.major = self.unpack_uint64_t()
        data.minor = self.unpack_uint64_t()
        if hasattr(self, 'filter_fsid4'):
            data = getattr(self, 'filter_fsid4')(data)
        return data

    def unpack_change_policy4(self):
        data = types.change_policy4()
        data.cp_major = self.unpack_uint64_t()
        data.cp_minor = self.unpack_uint64_t()
        if hasattr(self, 'filter_change_policy4'):
            data = getattr(self, 'filter_change_policy4')(data)
        return data

    def unpack_fs_location4(self):
        data = types.fs_location4()
        data.server = self.unpack_array(self.unpack_utf8str_cis)
        data.rootpath = self.unpack_pathname4()
        if hasattr(self, 'filter_fs_location4'):
            data = getattr(self, 'filter_fs_location4')(data)
        return data

    def unpack_fs_locations4(self):
        data = types.fs_locations4()
        data.fs_root = self.unpack_pathname4()
        data.locations = self.unpack_array(self.unpack_fs_location4)
        if hasattr(self, 'filter_fs_locations4'):
            data = getattr(self, 'filter_fs_locations4')(data)
        return data

    unpack_acetype4 = unpack_uint32_t

    unpack_aceflag4 = unpack_uint32_t

    unpack_acemask4 = unpack_uint32_t

    def unpack_nfsace4(self):
        data = types.nfsace4()
        data.type = self.unpack_acetype4()
        data.flag = self.unpack_aceflag4()
        data.access_mask = self.unpack_acemask4()
        data.who = self.unpack_utf8str_mixed()
        if hasattr(self, 'filter_nfsace4'):
            data = getattr(self, 'filter_nfsace4')(data)
        return data

    unpack_aclflag4 = unpack_uint32_t

    def unpack_nfsacl41(self):
        data = types.nfsacl41()
        data.na41_flag = self.unpack_aclflag4()
        data.na41_aces = self.unpack_array(self.unpack_nfsace4)
        if hasattr(self, 'filter_nfsacl41'):
            data = getattr(self, 'filter_nfsacl41')(data)
        return data

    def unpack_mode_masked4(self):
        data = types.mode_masked4()
        data.mm_value_to_set = self.unpack_mode4()
        data.mm_mask_bits = self.unpack_mode4()
        if hasattr(self, 'filter_mode_masked4'):
            data = getattr(self, 'filter_mode_masked4')(data)
        return data

    def unpack_specdata4(self):
        data = types.specdata4()
        data.specdata1 = self.unpack_uint32_t()
        data.specdata2 = self.unpack_uint32_t()
        if hasattr(self, 'filter_specdata4'):
            data = getattr(self, 'filter_specdata4')(data)
        return data

    def unpack_netaddr4(self):
        data = types.netaddr4()
        data.na_r_netid = self.unpack_string()
        data.na_r_addr = self.unpack_string()
        if hasattr(self, 'filter_netaddr4'):
            data = getattr(self, 'filter_netaddr4')(data)
        return data

    def unpack_nfs_impl_id4(self):
        data = types.nfs_impl_id4()
        data.nii_domain = self.unpack_utf8str_cis()
        data.nii_name = self.unpack_utf8str_cs()
        data.nii_date = self.unpack_nfstime4()
        if hasattr(self, 'filter_nfs_impl_id4'):
            data = getattr(self, 'filter_nfs_impl_id4')(data)
        return data

    def unpack_stateid4(self):
        data = types.stateid4()
        data.seqid = self.unpack_uint32_t()
        data.other = self.unpack_fopaque(const.NFS4_OTHER_SIZE)
        if hasattr(self, 'filter_stateid4'):
            data = getattr(self, 'filter_stateid4')(data)
        return data

    def unpack_layouttype4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.LAYOUT4_NFSV4_1_FILES, const.LAYOUT4_OSD2_OBJECTS, const.LAYOUT4_BLOCK_VOLUME, const.LAYOUT4_FLEX_FILES]:
            raise XDRError('value=%s not in enum layouttype4' % data)
        if hasattr(self, 'filter_layouttype4'):
            data = getattr(self, 'filter_layouttype4')(data)
        return data

    def unpack_layout_content4(self):
        data = types.layout_content4()
        data.loc_type = self.unpack_layouttype4()
        data.loc_body = self.unpack_opaque()
        if hasattr(self, 'filter_layout_content4'):
            data = getattr(self, 'filter_layout_content4')(data)
        return data

    def unpack_layouthint4(self):
        data = types.layouthint4()
        data.loh_type = self.unpack_layouttype4()
        data.loh_body = self.unpack_opaque()
        if hasattr(self, 'filter_layouthint4'):
            data = getattr(self, 'filter_layouthint4')(data)
        return data

    def unpack_layoutiomode4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.LAYOUTIOMODE4_READ, const.LAYOUTIOMODE4_RW, const.LAYOUTIOMODE4_ANY]:
            raise XDRError('value=%s not in enum layoutiomode4' % data)
        if hasattr(self, 'filter_layoutiomode4'):
            data = getattr(self, 'filter_layoutiomode4')(data)
        return data

    def unpack_layout4(self):
        data = types.layout4()
        data.lo_offset = self.unpack_offset4()
        data.lo_length = self.unpack_length4()
        data.lo_iomode = self.unpack_layoutiomode4()
        data.lo_content = self.unpack_layout_content4()
        if hasattr(self, 'filter_layout4'):
            data = getattr(self, 'filter_layout4')(data)
        return data

    def unpack_deviceid4(self):
        data = self.unpack_fopaque(const.NFS4_DEVICEID4_SIZE)
        if hasattr(self, 'filter_deviceid4'):
            data = getattr(self, 'filter_deviceid4')(data)
        return data

    def unpack_device_addr4(self):
        data = types.device_addr4()
        data.da_layout_type = self.unpack_layouttype4()
        data.da_addr_body = self.unpack_opaque()
        if hasattr(self, 'filter_device_addr4'):
            data = getattr(self, 'filter_device_addr4')(data)
        return data

    def unpack_layoutupdate4(self):
        data = types.layoutupdate4()
        data.lou_type = self.unpack_layouttype4()
        data.lou_body = self.unpack_opaque()
        if hasattr(self, 'filter_layoutupdate4'):
            data = getattr(self, 'filter_layoutupdate4')(data)
        return data

    def unpack_layoutreturn_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.LAYOUTRETURN4_FILE, const.LAYOUTRETURN4_FSID, const.LAYOUTRETURN4_ALL]:
            raise XDRError('value=%s not in enum layoutreturn_type4' % data)
        if hasattr(self, 'filter_layoutreturn_type4'):
            data = getattr(self, 'filter_layoutreturn_type4')(data)
        return data

    def unpack_layoutreturn_file4(self):
        data = types.layoutreturn_file4()
        data.lrf_offset = self.unpack_offset4()
        data.lrf_length = self.unpack_length4()
        data.lrf_stateid = self.unpack_stateid4()
        data.lrf_body = self.unpack_opaque()
        if hasattr(self, 'filter_layoutreturn_file4'):
            data = getattr(self, 'filter_layoutreturn_file4')(data)
        return data

    def unpack_layoutreturn4(self):
        data = types.layoutreturn4()
        data.lr_returntype = self.unpack_layoutreturn_type4()
        if data.lr_returntype == const.LAYOUTRETURN4_FILE:
            data.lr_layout = self.unpack_layoutreturn_file4()
        else:
            pass
        if hasattr(self, 'filter_layoutreturn4'):
            data = getattr(self, 'filter_layoutreturn4')(data)
        return data

    def unpack_fs4_status_type(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.STATUS4_FIXED, const.STATUS4_UPDATED, const.STATUS4_VERSIONED, const.STATUS4_WRITABLE, const.STATUS4_REFERRAL]:
            raise XDRError('value=%s not in enum fs4_status_type' % data)
        if hasattr(self, 'filter_fs4_status_type'):
            data = getattr(self, 'filter_fs4_status_type')(data)
        return data

    def unpack_fs4_status(self):
        data = types.fs4_status()
        data.fss_absent = self.unpack_bool()
        data.fss_type = self.unpack_fs4_status_type()
        data.fss_source = self.unpack_utf8str_cs()
        data.fss_current = self.unpack_utf8str_cs()
        data.fss_age = self.unpack_int32_t()
        data.fss_version = self.unpack_nfstime4()
        if hasattr(self, 'filter_fs4_status'):
            data = getattr(self, 'filter_fs4_status')(data)
        return data

    unpack_threshold4_read_size = unpack_length4

    unpack_threshold4_write_size = unpack_length4

    unpack_threshold4_read_iosize = unpack_length4

    unpack_threshold4_write_iosize = unpack_length4

    def unpack_threshold_item4(self):
        data = types.threshold_item4()
        data.thi_layout_type = self.unpack_layouttype4()
        data.thi_hintset = self.unpack_bitmap4()
        data.thi_hintlist = self.unpack_opaque()
        if hasattr(self, 'filter_threshold_item4'):
            data = getattr(self, 'filter_threshold_item4')(data)
        return data

    def unpack_mdsthreshold4(self):
        data = types.mdsthreshold4()
        data.mth_hints = self.unpack_array(self.unpack_threshold_item4)
        if hasattr(self, 'filter_mdsthreshold4'):
            data = getattr(self, 'filter_mdsthreshold4')(data)
        return data

    def unpack_retention_get4(self):
        data = types.retention_get4()
        data.rg_duration = self.unpack_uint64_t()
        data.rg_begin_time = self.unpack_array(self.unpack_nfstime4)
        if len(data.rg_begin_time) > 1 and self.check_array:
            raise XDRError('array length too long for data.rg_begin_time')
        if hasattr(self, 'filter_retention_get4'):
            data = getattr(self, 'filter_retention_get4')(data)
        return data

    def unpack_retention_set4(self):
        data = types.retention_set4()
        data.rs_enable = self.unpack_bool()
        data.rs_duration = self.unpack_array(self.unpack_uint64_t)
        if len(data.rs_duration) > 1 and self.check_array:
            raise XDRError('array length too long for data.rs_duration')
        if hasattr(self, 'filter_retention_set4'):
            data = getattr(self, 'filter_retention_set4')(data)
        return data

    unpack_fs_charset_cap4 = unpack_uint32_t

    def unpack_netloc_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NL4_NAME, const.NL4_URL, const.NL4_NETADDR]:
            raise XDRError('value=%s not in enum netloc_type4' % data)
        if hasattr(self, 'filter_netloc_type4'):
            data = getattr(self, 'filter_netloc_type4')(data)
        return data

    def unpack_netloc4(self):
        data = types.netloc4()
        data.nl_type = self.unpack_netloc_type4()
        if data.nl_type == const.NL4_NAME:
            data.nl_name = self.unpack_utf8str_cis()
        elif data.nl_type == const.NL4_URL:
            data.nl_url = self.unpack_utf8str_cis()
        elif data.nl_type == const.NL4_NETADDR:
            data.nl_addr = self.unpack_netaddr4()
        else:
            raise XDRError('bad switch=%s' % data.nl_type)
        if hasattr(self, 'filter_netloc4'):
            data = getattr(self, 'filter_netloc4')(data)
        return data

    def unpack_change_attr_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR, const.NFS4_CHANGE_TYPE_IS_VERSION_COUNTER, const.NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS, const.NFS4_CHANGE_TYPE_IS_TIME_METADATA, const.NFS4_CHANGE_TYPE_IS_UNDEFINED]:
            raise XDRError('value=%s not in enum change_attr_type4' % data)
        if hasattr(self, 'filter_change_attr_type4'):
            data = getattr(self, 'filter_change_attr_type4')(data)
        return data

    def unpack_labelformat_spec4(self):
        data = types.labelformat_spec4()
        data.lfs_lfs = self.unpack_policy4()
        data.lfs_pi = self.unpack_policy4()
        if hasattr(self, 'filter_labelformat_spec4'):
            data = getattr(self, 'filter_labelformat_spec4')(data)
        return data

    def unpack_sec_label4(self):
        data = types.sec_label4()
        data.slai_lfs = self.unpack_labelformat_spec4()
        data.slai_data = self.unpack_opaque()
        if hasattr(self, 'filter_sec_label4'):
            data = getattr(self, 'filter_sec_label4')(data)
        return data

    def unpack_copy_from_auth_priv(self):
        data = types.copy_from_auth_priv()
        data.cfap_shared_secret = self.unpack_secret4()
        data.cfap_destination = self.unpack_netloc4()
        data.cfap_username = self.unpack_utf8str_mixed()
        if hasattr(self, 'filter_copy_from_auth_priv'):
            data = getattr(self, 'filter_copy_from_auth_priv')(data)
        return data

    def unpack_copy_to_auth_priv(self):
        data = types.copy_to_auth_priv()
        data.ctap_shared_secret = self.unpack_secret4()
        data.ctap_source = self.unpack_array(self.unpack_netloc4)
        data.ctap_username = self.unpack_utf8str_mixed()
        if hasattr(self, 'filter_copy_to_auth_priv'):
            data = getattr(self, 'filter_copy_to_auth_priv')(data)
        return data

    def unpack_copy_confirm_auth_priv(self):
        data = types.copy_confirm_auth_priv()
        data.ccap_shared_secret_mic = self.unpack_opaque()
        data.ccap_username = self.unpack_utf8str_mixed()
        if hasattr(self, 'filter_copy_confirm_auth_priv'):
            data = getattr(self, 'filter_copy_confirm_auth_priv')(data)
        return data

    def unpack_app_data_block4(self):
        data = types.app_data_block4()
        data.adb_offset = self.unpack_offset4()
        data.adb_block_size = self.unpack_length4()
        data.adb_block_count = self.unpack_length4()
        data.adb_reloff_blocknum = self.unpack_length4()
        data.adb_block_num = self.unpack_count4()
        data.adb_reloff_pattern = self.unpack_length4()
        data.adb_pattern = self.unpack_opaque()
        if hasattr(self, 'filter_app_data_block4'):
            data = getattr(self, 'filter_app_data_block4')(data)
        return data

    def unpack_data4(self):
        data = types.data4()
        data.d_offset = self.unpack_offset4()
        data.d_data = self.unpack_opaque()
        if hasattr(self, 'filter_data4'):
            data = getattr(self, 'filter_data4')(data)
        return data

    def unpack_data_info4(self):
        data = types.data_info4()
        data.di_offset = self.unpack_offset4()
        data.di_length = self.unpack_length4()
        if hasattr(self, 'filter_data_info4'):
            data = getattr(self, 'filter_data_info4')(data)
        return data

    def unpack_data_content4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NFS4_CONTENT_DATA, const.NFS4_CONTENT_HOLE]:
            raise XDRError('value=%s not in enum data_content4' % data)
        if hasattr(self, 'filter_data_content4'):
            data = getattr(self, 'filter_data_content4')(data)
        return data

    def unpack_stable_how4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.UNSTABLE4, const.DATA_SYNC4, const.FILE_SYNC4]:
            raise XDRError('value=%s not in enum stable_how4' % data)
        if hasattr(self, 'filter_stable_how4'):
            data = getattr(self, 'filter_stable_how4')(data)
        return data

    def unpack_write_response4(self):
        data = types.write_response4()
        data.wr_callback_id = self.unpack_array(self.unpack_stateid4)
        if len(data.wr_callback_id) > 1 and self.check_array:
            raise XDRError('array length too long for data.wr_callback_id')
        data.wr_count = self.unpack_length4()
        data.wr_committed = self.unpack_stable_how4()
        data.wr_writeverf = self.unpack_verifier4()
        if hasattr(self, 'filter_write_response4'):
            data = getattr(self, 'filter_write_response4')(data)
        return data

    unpack_xattrkey4 = unpack_component4

    def unpack_xattrvalue4(self):
        data = self.unpack_opaque()
        if hasattr(self, 'filter_xattrvalue4'):
            data = getattr(self, 'filter_xattrvalue4')(data)
        return data

    unpack_fattr4_supported_attrs = unpack_bitmap4

    unpack_fattr4_type = unpack_nfs_ftype4

    unpack_fattr4_fh_expire_type = unpack_uint32_t

    unpack_fattr4_change = unpack_changeid4

    unpack_fattr4_size = unpack_uint64_t

    unpack_fattr4_link_support = unpack_bool

    unpack_fattr4_symlink_support = unpack_bool

    unpack_fattr4_named_attr = unpack_bool

    unpack_fattr4_fsid = unpack_fsid4

    unpack_fattr4_unique_handles = unpack_bool

    unpack_fattr4_lease_time = unpack_nfs_lease4

    unpack_fattr4_rdattr_error = unpack_nfsstat4

    def unpack_fattr4_acl(self):
        data = self.unpack_array(self.unpack_nfsace4)
        if hasattr(self, 'filter_fattr4_acl'):
            data = getattr(self, 'filter_fattr4_acl')(data)
        return data

    unpack_fattr4_aclsupport = unpack_uint32_t

    unpack_fattr4_archive = unpack_bool

    unpack_fattr4_cansettime = unpack_bool

    unpack_fattr4_case_insensitive = unpack_bool

    unpack_fattr4_case_preserving = unpack_bool

    unpack_fattr4_chown_restricted = unpack_bool

    unpack_fattr4_fileid = unpack_uint64_t

    unpack_fattr4_files_avail = unpack_uint64_t

    unpack_fattr4_filehandle = unpack_nfs_fh4

    unpack_fattr4_files_free = unpack_uint64_t

    unpack_fattr4_files_total = unpack_uint64_t

    unpack_fattr4_fs_locations = unpack_fs_locations4

    unpack_fattr4_hidden = unpack_bool

    unpack_fattr4_homogeneous = unpack_bool

    unpack_fattr4_maxfilesize = unpack_uint64_t

    unpack_fattr4_maxlink = unpack_uint32_t

    unpack_fattr4_maxname = unpack_uint32_t

    unpack_fattr4_maxread = unpack_uint64_t

    unpack_fattr4_maxwrite = unpack_uint64_t

    unpack_fattr4_mimetype = unpack_ascii_REQUIRED4

    unpack_fattr4_mode = unpack_mode4

    unpack_fattr4_mode_set_masked = unpack_mode_masked4

    unpack_fattr4_mounted_on_fileid = unpack_uint64_t

    unpack_fattr4_no_trunc = unpack_bool

    unpack_fattr4_numlinks = unpack_uint32_t

    unpack_fattr4_owner = unpack_utf8str_mixed

    unpack_fattr4_owner_group = unpack_utf8str_mixed

    unpack_fattr4_quota_avail_hard = unpack_uint64_t

    unpack_fattr4_quota_avail_soft = unpack_uint64_t

    unpack_fattr4_quota_used = unpack_uint64_t

    unpack_fattr4_rawdev = unpack_specdata4

    unpack_fattr4_space_avail = unpack_uint64_t

    unpack_fattr4_space_free = unpack_uint64_t

    unpack_fattr4_space_total = unpack_uint64_t

    unpack_fattr4_space_used = unpack_uint64_t

    unpack_fattr4_system = unpack_bool

    unpack_fattr4_time_access = unpack_nfstime4

    unpack_fattr4_time_access_set = unpack_settime4

    unpack_fattr4_time_backup = unpack_nfstime4

    unpack_fattr4_time_create = unpack_nfstime4

    unpack_fattr4_time_delta = unpack_nfstime4

    unpack_fattr4_time_metadata = unpack_nfstime4

    unpack_fattr4_time_modify = unpack_nfstime4

    unpack_fattr4_time_modify_set = unpack_settime4

    unpack_fattr4_suppattr_exclcreat = unpack_bitmap4

    unpack_fattr4_dir_notif_delay = unpack_nfstime4

    unpack_fattr4_dirent_notif_delay = unpack_nfstime4

    def unpack_fattr4_fs_layout_types(self):
        data = self.unpack_array(self.unpack_layouttype4)
        if hasattr(self, 'filter_fattr4_fs_layout_types'):
            data = getattr(self, 'filter_fattr4_fs_layout_types')(data)
        return data

    unpack_fattr4_fs_status = unpack_fs4_status

    unpack_fattr4_fs_charset_cap = unpack_fs_charset_cap4

    unpack_fattr4_layout_alignment = unpack_uint32_t

    unpack_fattr4_layout_blksize = unpack_uint32_t

    unpack_fattr4_layout_hint = unpack_layouthint4

    def unpack_fattr4_layout_types(self):
        data = self.unpack_array(self.unpack_layouttype4)
        if hasattr(self, 'filter_fattr4_layout_types'):
            data = getattr(self, 'filter_fattr4_layout_types')(data)
        return data

    unpack_fattr4_mdsthreshold = unpack_mdsthreshold4

    unpack_fattr4_retention_get = unpack_retention_get4

    unpack_fattr4_retention_set = unpack_retention_set4

    unpack_fattr4_retentevt_get = unpack_retention_get4

    unpack_fattr4_retentevt_set = unpack_retention_set4

    unpack_fattr4_retention_hold = unpack_uint64_t

    unpack_fattr4_dacl = unpack_nfsacl41

    unpack_fattr4_sacl = unpack_nfsacl41

    unpack_fattr4_change_policy = unpack_change_policy4

    unpack_fattr4_space_freed = unpack_uint64_t

    unpack_fattr4_change_attr_type = unpack_change_attr_type4

    unpack_fattr4_sec_label = unpack_sec_label4

    unpack_fattr4_clone_blksize = unpack_uint32_t

    unpack_fattr4_xattr_support = unpack_bool

    def unpack_fattr4(self):
        data = types.fattr4()
        data.attrmask = self.unpack_bitmap4()
        data.attr_vals = self.unpack_attrlist4()
        if hasattr(self, 'filter_fattr4'):
            data = getattr(self, 'filter_fattr4')(data)
        return data

    def unpack_change_info4(self):
        data = types.change_info4()
        data.atomic = self.unpack_bool()
        data.before = self.unpack_changeid4()
        data.after = self.unpack_changeid4()
        if hasattr(self, 'filter_change_info4'):
            data = getattr(self, 'filter_change_info4')(data)
        return data

    unpack_clientaddr4 = unpack_netaddr4

    def unpack_cb_client4(self):
        data = types.cb_client4()
        data.cb_program = self.unpack_uint32_t()
        data.cb_location = self.unpack_netaddr4()
        if hasattr(self, 'filter_cb_client4'):
            data = getattr(self, 'filter_cb_client4')(data)
        return data

    def unpack_nfs_client_id4(self):
        data = types.nfs_client_id4()
        data.verifier = self.unpack_verifier4()
        data.id = self.unpack_opaque()
        if len(data.id) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.id')
        if hasattr(self, 'filter_nfs_client_id4'):
            data = getattr(self, 'filter_nfs_client_id4')(data)
        return data

    def unpack_client_owner4(self):
        data = types.client_owner4()
        data.co_verifier = self.unpack_verifier4()
        data.co_ownerid = self.unpack_opaque()
        if len(data.co_ownerid) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.co_ownerid')
        if hasattr(self, 'filter_client_owner4'):
            data = getattr(self, 'filter_client_owner4')(data)
        return data

    def unpack_server_owner4(self):
        data = types.server_owner4()
        data.so_minor_id = self.unpack_uint64_t()
        data.so_major_id = self.unpack_opaque()
        if len(data.so_major_id) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.so_major_id')
        if hasattr(self, 'filter_server_owner4'):
            data = getattr(self, 'filter_server_owner4')(data)
        return data

    def unpack_state_owner4(self):
        data = types.state_owner4()
        data.clientid = self.unpack_clientid4()
        data.owner = self.unpack_opaque()
        if len(data.owner) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.owner')
        if hasattr(self, 'filter_state_owner4'):
            data = getattr(self, 'filter_state_owner4')(data)
        return data

    unpack_open_owner4 = unpack_state_owner4

    unpack_lock_owner4 = unpack_state_owner4

    def unpack_nfs_lock_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.READ_LT, const.WRITE_LT, const.READW_LT, const.WRITEW_LT]:
            raise XDRError('value=%s not in enum nfs_lock_type4' % data)
        if hasattr(self, 'filter_nfs_lock_type4'):
            data = getattr(self, 'filter_nfs_lock_type4')(data)
        return data

    def unpack_ssv_subkey4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.SSV4_SUBKEY_MIC_I2T, const.SSV4_SUBKEY_MIC_T2I, const.SSV4_SUBKEY_SEAL_I2T, const.SSV4_SUBKEY_SEAL_T2I]:
            raise XDRError('value=%s not in enum ssv_subkey4' % data)
        if hasattr(self, 'filter_ssv_subkey4'):
            data = getattr(self, 'filter_ssv_subkey4')(data)
        return data

    def unpack_ssv_mic_plain_tkn4(self):
        data = types.ssv_mic_plain_tkn4()
        data.smpt_ssv_seq = self.unpack_uint32_t()
        data.smpt_orig_plain = self.unpack_opaque()
        if hasattr(self, 'filter_ssv_mic_plain_tkn4'):
            data = getattr(self, 'filter_ssv_mic_plain_tkn4')(data)
        return data

    def unpack_ssv_mic_tkn4(self):
        data = types.ssv_mic_tkn4()
        data.smt_ssv_seq = self.unpack_uint32_t()
        data.smt_hmac = self.unpack_opaque()
        if hasattr(self, 'filter_ssv_mic_tkn4'):
            data = getattr(self, 'filter_ssv_mic_tkn4')(data)
        return data

    def unpack_ssv_seal_plain_tkn4(self):
        data = types.ssv_seal_plain_tkn4()
        data.sspt_confounder = self.unpack_opaque()
        data.sspt_ssv_seq = self.unpack_uint32_t()
        data.sspt_orig_plain = self.unpack_opaque()
        data.sspt_pad = self.unpack_opaque()
        if hasattr(self, 'filter_ssv_seal_plain_tkn4'):
            data = getattr(self, 'filter_ssv_seal_plain_tkn4')(data)
        return data

    def unpack_ssv_seal_cipher_tkn4(self):
        data = types.ssv_seal_cipher_tkn4()
        data.ssct_ssv_seq = self.unpack_uint32_t()
        data.ssct_iv = self.unpack_opaque()
        data.ssct_encr_data = self.unpack_opaque()
        data.ssct_hmac = self.unpack_opaque()
        if hasattr(self, 'filter_ssv_seal_cipher_tkn4'):
            data = getattr(self, 'filter_ssv_seal_cipher_tkn4')(data)
        return data

    def unpack_fs_locations_server4(self):
        data = types.fs_locations_server4()
        data.fls_currency = self.unpack_int32_t()
        data.fls_info = self.unpack_opaque()
        data.fls_server = self.unpack_utf8str_cis()
        if hasattr(self, 'filter_fs_locations_server4'):
            data = getattr(self, 'filter_fs_locations_server4')(data)
        return data

    def unpack_fs_locations_item4(self):
        data = types.fs_locations_item4()
        data.fli_entries = self.unpack_array(self.unpack_fs_locations_server4)
        data.fli_rootpath = self.unpack_pathname4()
        if hasattr(self, 'filter_fs_locations_item4'):
            data = getattr(self, 'filter_fs_locations_item4')(data)
        return data

    def unpack_fs_locations_info4(self):
        data = types.fs_locations_info4()
        data.fli_flags = self.unpack_uint32_t()
        data.fli_valid_for = self.unpack_int32_t()
        data.fli_fs_root = self.unpack_pathname4()
        data.fli_items = self.unpack_array(self.unpack_fs_locations_item4)
        if hasattr(self, 'filter_fs_locations_info4'):
            data = getattr(self, 'filter_fs_locations_info4')(data)
        return data

    unpack_fattr4_fs_locations_info = unpack_fs_locations_info4

    unpack_nfl_util4 = unpack_uint32_t

    def unpack_filelayout_hint_care4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NFLH4_CARE_DENSE, const.NFLH4_CARE_COMMIT_THRU_MDS, const.NFL42_CARE_IO_ADVISE_THRU_MDS, const.NFLH4_CARE_STRIPE_UNIT_SIZE, const.NFLH4_CARE_STRIPE_COUNT]:
            raise XDRError('value=%s not in enum filelayout_hint_care4' % data)
        if hasattr(self, 'filter_filelayout_hint_care4'):
            data = getattr(self, 'filter_filelayout_hint_care4')(data)
        return data

    def unpack_nfsv4_1_file_layouthint4(self):
        data = types.nfsv4_1_file_layouthint4()
        data.nflh_care = self.unpack_uint32_t()
        data.nflh_util = self.unpack_nfl_util4()
        data.nflh_stripe_count = self.unpack_count4()
        if hasattr(self, 'filter_nfsv4_1_file_layouthint4'):
            data = getattr(self, 'filter_nfsv4_1_file_layouthint4')(data)
        return data

    def unpack_multipath_list4(self):
        data = self.unpack_array(self.unpack_netaddr4)
        if hasattr(self, 'filter_multipath_list4'):
            data = getattr(self, 'filter_multipath_list4')(data)
        return data

    def unpack_nfsv4_1_file_layout_ds_addr4(self):
        data = types.nfsv4_1_file_layout_ds_addr4()
        data.nflda_stripe_indices = self.unpack_array(self.unpack_uint32_t)
        data.nflda_multipath_ds_list = self.unpack_array(self.unpack_multipath_list4)
        if hasattr(self, 'filter_nfsv4_1_file_layout_ds_addr4'):
            data = getattr(self, 'filter_nfsv4_1_file_layout_ds_addr4')(data)
        return data

    def unpack_nfsv4_1_file_layout4(self):
        data = types.nfsv4_1_file_layout4()
        data.nfl_deviceid = self.unpack_deviceid4()
        data.nfl_util = self.unpack_nfl_util4()
        data.nfl_first_stripe_index = self.unpack_uint32_t()
        data.nfl_pattern_offset = self.unpack_offset4()
        data.nfl_fh_list = self.unpack_array(self.unpack_nfs_fh4)
        if hasattr(self, 'filter_nfsv4_1_file_layout4'):
            data = getattr(self, 'filter_nfsv4_1_file_layout4')(data)
        return data

    def unpack_nfs_opnum4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OP_ACCESS, const.OP_CLOSE, const.OP_COMMIT, const.OP_CREATE, const.OP_DELEGPURGE, const.OP_DELEGRETURN, const.OP_GETATTR, const.OP_GETFH, const.OP_LINK, const.OP_LOCK, const.OP_LOCKT, const.OP_LOCKU, const.OP_LOOKUP, const.OP_LOOKUPP, const.OP_NVERIFY, const.OP_OPEN, const.OP_OPENATTR, const.OP_OPEN_CONFIRM, const.OP_OPEN_DOWNGRADE, const.OP_PUTFH, const.OP_PUTPUBFH, const.OP_PUTROOTFH, const.OP_READ, const.OP_READDIR, const.OP_READLINK, const.OP_REMOVE, const.OP_RENAME, const.OP_RENEW, const.OP_RESTOREFH, const.OP_SAVEFH, const.OP_SECINFO, const.OP_SETATTR, const.OP_SETCLIENTID, const.OP_SETCLIENTID_CONFIRM, const.OP_VERIFY, const.OP_WRITE, const.OP_RELEASE_LOCKOWNER, const.OP_BACKCHANNEL_CTL, const.OP_BIND_CONN_TO_SESSION, const.OP_EXCHANGE_ID, const.OP_CREATE_SESSION, const.OP_DESTROY_SESSION, const.OP_FREE_STATEID, const.OP_GET_DIR_DELEGATION, const.OP_GETDEVICEINFO, const.OP_GETDEVICELIST, const.OP_LAYOUTCOMMIT, const.OP_LAYOUTGET, const.OP_LAYOUTRETURN, const.OP_SECINFO_NO_NAME, const.OP_SEQUENCE, const.OP_SET_SSV, const.OP_TEST_STATEID, const.OP_WANT_DELEGATION, const.OP_DESTROY_CLIENTID, const.OP_RECLAIM_COMPLETE, const.OP_ALLOCATE, const.OP_COPY, const.OP_COPY_NOTIFY, const.OP_DEALLOCATE, const.OP_IO_ADVISE, const.OP_LAYOUTERROR, const.OP_LAYOUTSTATS, const.OP_OFFLOAD_CANCEL, const.OP_OFFLOAD_STATUS, const.OP_READ_PLUS, const.OP_SEEK, const.OP_WRITE_SAME, const.OP_CLONE, const.OP_GETXATTR, const.OP_SETXATTR, const.OP_LISTXATTRS, const.OP_REMOVEXATTR, const.OP_ILLEGAL]:
            raise XDRError('value=%s not in enum nfs_opnum4' % data)
        if hasattr(self, 'filter_nfs_opnum4'):
            data = getattr(self, 'filter_nfs_opnum4')(data)
        return data

    def unpack_ACCESS4args(self):
        data = types.ACCESS4args()
        data.access = self.unpack_uint32_t()
        if hasattr(self, 'filter_ACCESS4args'):
            data = getattr(self, 'filter_ACCESS4args')(data)
        return data

    def unpack_ACCESS4resok(self):
        data = types.ACCESS4resok()
        data.supported = self.unpack_uint32_t()
        data.access = self.unpack_uint32_t()
        if hasattr(self, 'filter_ACCESS4resok'):
            data = getattr(self, 'filter_ACCESS4resok')(data)
        return data

    def unpack_ACCESS4res(self):
        data = types.ACCESS4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_ACCESS4resok()
        else:
            pass
        if hasattr(self, 'filter_ACCESS4res'):
            data = getattr(self, 'filter_ACCESS4res')(data)
        return data

    def unpack_CLONE4args(self):
        data = types.CLONE4args()
        data.cl_src_stateid = self.unpack_stateid4()
        data.cl_dst_stateid = self.unpack_stateid4()
        data.cl_src_offset = self.unpack_offset4()
        data.cl_dst_offset = self.unpack_offset4()
        data.cl_count = self.unpack_length4()
        if hasattr(self, 'filter_CLONE4args'):
            data = getattr(self, 'filter_CLONE4args')(data)
        return data

    def unpack_CLONE4res(self):
        data = types.CLONE4res()
        data.cl_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CLONE4res'):
            data = getattr(self, 'filter_CLONE4res')(data)
        return data

    def unpack_CLOSE4args(self):
        data = types.CLOSE4args()
        data.seqid = self.unpack_seqid4()
        data.open_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_CLOSE4args'):
            data = getattr(self, 'filter_CLOSE4args')(data)
        return data

    def unpack_CLOSE4res(self):
        data = types.CLOSE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.open_stateid = self.unpack_stateid4()
        else:
            pass
        if hasattr(self, 'filter_CLOSE4res'):
            data = getattr(self, 'filter_CLOSE4res')(data)
        return data

    def unpack_COMMIT4args(self):
        data = types.COMMIT4args()
        data.offset = self.unpack_offset4()
        data.count = self.unpack_count4()
        if hasattr(self, 'filter_COMMIT4args'):
            data = getattr(self, 'filter_COMMIT4args')(data)
        return data

    def unpack_COMMIT4resok(self):
        data = types.COMMIT4resok()
        data.writeverf = self.unpack_verifier4()
        if hasattr(self, 'filter_COMMIT4resok'):
            data = getattr(self, 'filter_COMMIT4resok')(data)
        return data

    def unpack_COMMIT4res(self):
        data = types.COMMIT4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_COMMIT4resok()
        else:
            pass
        if hasattr(self, 'filter_COMMIT4res'):
            data = getattr(self, 'filter_COMMIT4res')(data)
        return data

    def unpack_createtype4(self):
        data = types.createtype4()
        data.type = self.unpack_nfs_ftype4()
        if data.type == const.NF4LNK:
            data.linkdata = self.unpack_linktext4()
        elif data.type == const.NF4BLK or data.type == const.NF4CHR:
            data.devdata = self.unpack_specdata4()
        elif data.type == const.NF4SOCK or data.type == const.NF4FIFO or data.type == const.NF4DIR:
            pass
        else:
            pass
        if hasattr(self, 'filter_createtype4'):
            data = getattr(self, 'filter_createtype4')(data)
        return data

    def unpack_CREATE4args(self):
        data = types.CREATE4args()
        data.objtype = self.unpack_createtype4()
        data.objname = self.unpack_component4()
        data.createattrs = self.unpack_fattr4()
        if hasattr(self, 'filter_CREATE4args'):
            data = getattr(self, 'filter_CREATE4args')(data)
        return data

    def unpack_CREATE4resok(self):
        data = types.CREATE4resok()
        data.cinfo = self.unpack_change_info4()
        data.attrset = self.unpack_bitmap4()
        if hasattr(self, 'filter_CREATE4resok'):
            data = getattr(self, 'filter_CREATE4resok')(data)
        return data

    def unpack_CREATE4res(self):
        data = types.CREATE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_CREATE4resok()
        else:
            pass
        if hasattr(self, 'filter_CREATE4res'):
            data = getattr(self, 'filter_CREATE4res')(data)
        return data

    def unpack_DELEGPURGE4args(self):
        data = types.DELEGPURGE4args()
        data.clientid = self.unpack_clientid4()
        if hasattr(self, 'filter_DELEGPURGE4args'):
            data = getattr(self, 'filter_DELEGPURGE4args')(data)
        return data

    def unpack_DELEGPURGE4res(self):
        data = types.DELEGPURGE4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_DELEGPURGE4res'):
            data = getattr(self, 'filter_DELEGPURGE4res')(data)
        return data

    def unpack_DELEGRETURN4args(self):
        data = types.DELEGRETURN4args()
        data.deleg_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_DELEGRETURN4args'):
            data = getattr(self, 'filter_DELEGRETURN4args')(data)
        return data

    def unpack_DELEGRETURN4res(self):
        data = types.DELEGRETURN4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_DELEGRETURN4res'):
            data = getattr(self, 'filter_DELEGRETURN4res')(data)
        return data

    def unpack_GETATTR4args(self):
        data = types.GETATTR4args()
        data.attr_request = self.unpack_bitmap4()
        if hasattr(self, 'filter_GETATTR4args'):
            data = getattr(self, 'filter_GETATTR4args')(data)
        return data

    def unpack_GETATTR4resok(self):
        data = types.GETATTR4resok()
        data.obj_attributes = self.unpack_fattr4()
        if hasattr(self, 'filter_GETATTR4resok'):
            data = getattr(self, 'filter_GETATTR4resok')(data)
        return data

    def unpack_GETATTR4res(self):
        data = types.GETATTR4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_GETATTR4resok()
        else:
            pass
        if hasattr(self, 'filter_GETATTR4res'):
            data = getattr(self, 'filter_GETATTR4res')(data)
        return data

    def unpack_GETFH4resok(self):
        data = types.GETFH4resok()
        data.object = self.unpack_nfs_fh4()
        if hasattr(self, 'filter_GETFH4resok'):
            data = getattr(self, 'filter_GETFH4resok')(data)
        return data

    def unpack_GETFH4res(self):
        data = types.GETFH4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_GETFH4resok()
        else:
            pass
        if hasattr(self, 'filter_GETFH4res'):
            data = getattr(self, 'filter_GETFH4res')(data)
        return data

    def unpack_LINK4args(self):
        data = types.LINK4args()
        data.newname = self.unpack_component4()
        if hasattr(self, 'filter_LINK4args'):
            data = getattr(self, 'filter_LINK4args')(data)
        return data

    def unpack_LINK4resok(self):
        data = types.LINK4resok()
        data.cinfo = self.unpack_change_info4()
        if hasattr(self, 'filter_LINK4resok'):
            data = getattr(self, 'filter_LINK4resok')(data)
        return data

    def unpack_LINK4res(self):
        data = types.LINK4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_LINK4resok()
        else:
            pass
        if hasattr(self, 'filter_LINK4res'):
            data = getattr(self, 'filter_LINK4res')(data)
        return data

    def unpack_open_to_lock_owner4(self):
        data = types.open_to_lock_owner4()
        data.open_seqid = self.unpack_seqid4()
        data.open_stateid = self.unpack_stateid4()
        data.lock_seqid = self.unpack_seqid4()
        data.lock_owner = self.unpack_lock_owner4()
        if hasattr(self, 'filter_open_to_lock_owner4'):
            data = getattr(self, 'filter_open_to_lock_owner4')(data)
        return data

    def unpack_exist_lock_owner4(self):
        data = types.exist_lock_owner4()
        data.lock_stateid = self.unpack_stateid4()
        data.lock_seqid = self.unpack_seqid4()
        if hasattr(self, 'filter_exist_lock_owner4'):
            data = getattr(self, 'filter_exist_lock_owner4')(data)
        return data

    def unpack_locker4(self):
        data = types.locker4()
        data.new_lock_owner = self.unpack_bool()
        if data.new_lock_owner == const.TRUE:
            data.open_owner = self.unpack_open_to_lock_owner4()
        elif data.new_lock_owner == const.FALSE:
            data.lock_owner = self.unpack_exist_lock_owner4()
        else:
            raise XDRError('bad switch=%s' % data.new_lock_owner)
        if hasattr(self, 'filter_locker4'):
            data = getattr(self, 'filter_locker4')(data)
        return data

    def unpack_LOCK4args(self):
        data = types.LOCK4args()
        data.locktype = self.unpack_nfs_lock_type4()
        data.reclaim = self.unpack_bool()
        data.offset = self.unpack_offset4()
        data.length = self.unpack_length4()
        data.locker = self.unpack_locker4()
        if hasattr(self, 'filter_LOCK4args'):
            data = getattr(self, 'filter_LOCK4args')(data)
        return data

    def unpack_LOCK4denied(self):
        data = types.LOCK4denied()
        data.offset = self.unpack_offset4()
        data.length = self.unpack_length4()
        data.locktype = self.unpack_nfs_lock_type4()
        data.owner = self.unpack_lock_owner4()
        if hasattr(self, 'filter_LOCK4denied'):
            data = getattr(self, 'filter_LOCK4denied')(data)
        return data

    def unpack_LOCK4resok(self):
        data = types.LOCK4resok()
        data.lock_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_LOCK4resok'):
            data = getattr(self, 'filter_LOCK4resok')(data)
        return data

    def unpack_LOCK4res(self):
        data = types.LOCK4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_LOCK4resok()
        elif data.status == const.NFS4ERR_DENIED:
            data.denied = self.unpack_LOCK4denied()
        else:
            pass
        if hasattr(self, 'filter_LOCK4res'):
            data = getattr(self, 'filter_LOCK4res')(data)
        return data

    def unpack_LOCKT4args(self):
        data = types.LOCKT4args()
        data.locktype = self.unpack_nfs_lock_type4()
        data.offset = self.unpack_offset4()
        data.length = self.unpack_length4()
        data.owner = self.unpack_lock_owner4()
        if hasattr(self, 'filter_LOCKT4args'):
            data = getattr(self, 'filter_LOCKT4args')(data)
        return data

    def unpack_LOCKT4res(self):
        data = types.LOCKT4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4ERR_DENIED:
            data.denied = self.unpack_LOCK4denied()
        elif data.status == const.NFS4_OK:
            pass
        else:
            pass
        if hasattr(self, 'filter_LOCKT4res'):
            data = getattr(self, 'filter_LOCKT4res')(data)
        return data

    def unpack_LOCKU4args(self):
        data = types.LOCKU4args()
        data.locktype = self.unpack_nfs_lock_type4()
        data.seqid = self.unpack_seqid4()
        data.lock_stateid = self.unpack_stateid4()
        data.offset = self.unpack_offset4()
        data.length = self.unpack_length4()
        if hasattr(self, 'filter_LOCKU4args'):
            data = getattr(self, 'filter_LOCKU4args')(data)
        return data

    def unpack_LOCKU4res(self):
        data = types.LOCKU4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.lock_stateid = self.unpack_stateid4()
        else:
            pass
        if hasattr(self, 'filter_LOCKU4res'):
            data = getattr(self, 'filter_LOCKU4res')(data)
        return data

    def unpack_LOOKUP4args(self):
        data = types.LOOKUP4args()
        data.objname = self.unpack_component4()
        if hasattr(self, 'filter_LOOKUP4args'):
            data = getattr(self, 'filter_LOOKUP4args')(data)
        return data

    def unpack_LOOKUP4res(self):
        data = types.LOOKUP4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_LOOKUP4res'):
            data = getattr(self, 'filter_LOOKUP4res')(data)
        return data

    def unpack_LOOKUPP4res(self):
        data = types.LOOKUPP4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_LOOKUPP4res'):
            data = getattr(self, 'filter_LOOKUPP4res')(data)
        return data

    def unpack_NVERIFY4args(self):
        data = types.NVERIFY4args()
        data.obj_attributes = self.unpack_fattr4()
        if hasattr(self, 'filter_NVERIFY4args'):
            data = getattr(self, 'filter_NVERIFY4args')(data)
        return data

    def unpack_NVERIFY4res(self):
        data = types.NVERIFY4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_NVERIFY4res'):
            data = getattr(self, 'filter_NVERIFY4res')(data)
        return data

    def unpack_createmode4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.UNCHECKED4, const.GUARDED4, const.EXCLUSIVE4, const.EXCLUSIVE4_1]:
            raise XDRError('value=%s not in enum createmode4' % data)
        if hasattr(self, 'filter_createmode4'):
            data = getattr(self, 'filter_createmode4')(data)
        return data

    def unpack_creatverfattr(self):
        data = types.creatverfattr()
        data.cva_verf = self.unpack_verifier4()
        data.cva_attrs = self.unpack_fattr4()
        if hasattr(self, 'filter_creatverfattr'):
            data = getattr(self, 'filter_creatverfattr')(data)
        return data

    def unpack_createhow4(self):
        data = types.createhow4()
        data.mode = self.unpack_createmode4()
        if data.mode == const.UNCHECKED4 or data.mode == const.GUARDED4:
            data.createattrs = self.unpack_fattr4()
        elif data.mode == const.EXCLUSIVE4:
            data.createverf = self.unpack_verifier4()
        elif data.mode == const.EXCLUSIVE4_1:
            data.ch_createboth = self.unpack_creatverfattr()
        else:
            raise XDRError('bad switch=%s' % data.mode)
        if hasattr(self, 'filter_createhow4'):
            data = getattr(self, 'filter_createhow4')(data)
        return data

    def unpack_opentype4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OPEN4_NOCREATE, const.OPEN4_CREATE]:
            raise XDRError('value=%s not in enum opentype4' % data)
        if hasattr(self, 'filter_opentype4'):
            data = getattr(self, 'filter_opentype4')(data)
        return data

    def unpack_openflag4(self):
        data = types.openflag4()
        data.opentype = self.unpack_opentype4()
        if data.opentype == const.OPEN4_CREATE:
            data.how = self.unpack_createhow4()
        else:
            pass
        if hasattr(self, 'filter_openflag4'):
            data = getattr(self, 'filter_openflag4')(data)
        return data

    def unpack_limit_by4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NFS_LIMIT_SIZE, const.NFS_LIMIT_BLOCKS]:
            raise XDRError('value=%s not in enum limit_by4' % data)
        if hasattr(self, 'filter_limit_by4'):
            data = getattr(self, 'filter_limit_by4')(data)
        return data

    def unpack_nfs_modified_limit4(self):
        data = types.nfs_modified_limit4()
        data.num_blocks = self.unpack_uint32_t()
        data.bytes_per_block = self.unpack_uint32_t()
        if hasattr(self, 'filter_nfs_modified_limit4'):
            data = getattr(self, 'filter_nfs_modified_limit4')(data)
        return data

    def unpack_nfs_space_limit4(self):
        data = types.nfs_space_limit4()
        data.limitby = self.unpack_limit_by4()
        if data.limitby == const.NFS_LIMIT_SIZE:
            data.filesize = self.unpack_uint64_t()
        elif data.limitby == const.NFS_LIMIT_BLOCKS:
            data.mod_blocks = self.unpack_nfs_modified_limit4()
        else:
            raise XDRError('bad switch=%s' % data.limitby)
        if hasattr(self, 'filter_nfs_space_limit4'):
            data = getattr(self, 'filter_nfs_space_limit4')(data)
        return data

    def unpack_open_delegation_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OPEN_DELEGATE_NONE, const.OPEN_DELEGATE_READ, const.OPEN_DELEGATE_WRITE, const.OPEN_DELEGATE_NONE_EXT, const.OPEN_DELEGATE_READ_ATTRS_DELEG, const.OPEN_DELEGATE_WRITE_ATTRS_DELEG]:
            raise XDRError('value=%s not in enum open_delegation_type4' % data)
        if hasattr(self, 'filter_open_delegation_type4'):
            data = getattr(self, 'filter_open_delegation_type4')(data)
        return data

    def unpack_open_claim_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.CLAIM_NULL, const.CLAIM_PREVIOUS, const.CLAIM_DELEGATE_CUR, const.CLAIM_DELEGATE_PREV, const.CLAIM_FH, const.CLAIM_DELEG_CUR_FH, const.CLAIM_DELEG_PREV_FH]:
            raise XDRError('value=%s not in enum open_claim_type4' % data)
        if hasattr(self, 'filter_open_claim_type4'):
            data = getattr(self, 'filter_open_claim_type4')(data)
        return data

    def unpack_open_claim_delegate_cur4(self):
        data = types.open_claim_delegate_cur4()
        data.delegate_stateid = self.unpack_stateid4()
        data.file = self.unpack_component4()
        if hasattr(self, 'filter_open_claim_delegate_cur4'):
            data = getattr(self, 'filter_open_claim_delegate_cur4')(data)
        return data

    def unpack_open_claim4(self):
        data = types.open_claim4()
        data.claim = self.unpack_open_claim_type4()
        if data.claim == const.CLAIM_NULL:
            data.file = self.unpack_component4()
        elif data.claim == const.CLAIM_PREVIOUS:
            data.delegate_type = self.unpack_open_delegation_type4()
        elif data.claim == const.CLAIM_DELEGATE_CUR:
            data.delegate_cur_info = self.unpack_open_claim_delegate_cur4()
        elif data.claim == const.CLAIM_DELEGATE_PREV:
            data.file_delegate_prev = self.unpack_component4()
        elif data.claim == const.CLAIM_FH:
            pass
        elif data.claim == const.CLAIM_DELEG_PREV_FH:
            pass
        elif data.claim == const.CLAIM_DELEG_CUR_FH:
            data.oc_delegate_stateid = self.unpack_stateid4()
        else:
            raise XDRError('bad switch=%s' % data.claim)
        if hasattr(self, 'filter_open_claim4'):
            data = getattr(self, 'filter_open_claim4')(data)
        return data

    def unpack_OPEN4args(self):
        data = types.OPEN4args()
        data.seqid = self.unpack_seqid4()
        data.share_access = self.unpack_uint32_t()
        data.share_deny = self.unpack_uint32_t()
        data.owner = self.unpack_open_owner4()
        data.openhow = self.unpack_openflag4()
        data.claim = self.unpack_open_claim4()
        if hasattr(self, 'filter_OPEN4args'):
            data = getattr(self, 'filter_OPEN4args')(data)
        return data

    def unpack_open_read_delegation4(self):
        data = types.open_read_delegation4()
        data.stateid = self.unpack_stateid4()
        data.recall = self.unpack_bool()
        data.permissions = self.unpack_nfsace4()
        if hasattr(self, 'filter_open_read_delegation4'):
            data = getattr(self, 'filter_open_read_delegation4')(data)
        return data

    def unpack_open_write_delegation4(self):
        data = types.open_write_delegation4()
        data.stateid = self.unpack_stateid4()
        data.recall = self.unpack_bool()
        data.space_limit = self.unpack_nfs_space_limit4()
        data.permissions = self.unpack_nfsace4()
        if hasattr(self, 'filter_open_write_delegation4'):
            data = getattr(self, 'filter_open_write_delegation4')(data)
        return data

    def unpack_why_no_delegation4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.WND4_NOT_WANTED, const.WND4_CONTENTION, const.WND4_RESOURCE, const.WND4_NOT_SUPP_FTYPE, const.WND4_WRITE_DELEG_NOT_SUPP_FTYPE, const.WND4_NOT_SUPP_UPGRADE, const.WND4_NOT_SUPP_DOWNGRADE, const.WND4_CANCELLED, const.WND4_IS_DIR]:
            raise XDRError('value=%s not in enum why_no_delegation4' % data)
        if hasattr(self, 'filter_why_no_delegation4'):
            data = getattr(self, 'filter_why_no_delegation4')(data)
        return data

    def unpack_open_none_delegation4(self):
        data = types.open_none_delegation4()
        data.ond_why = self.unpack_why_no_delegation4()
        if data.ond_why == const.WND4_CONTENTION:
            data.ond_server_will_push_deleg = self.unpack_bool()
        elif data.ond_why == const.WND4_RESOURCE:
            data.ond_server_will_signal_avail = self.unpack_bool()
        else:
            pass
        if hasattr(self, 'filter_open_none_delegation4'):
            data = getattr(self, 'filter_open_none_delegation4')(data)
        return data

    def unpack_open_delegation4(self):
        data = types.open_delegation4()
        data.delegation_type = self.unpack_open_delegation_type4()
        if data.delegation_type == const.OPEN_DELEGATE_NONE:
            pass
        elif data.delegation_type == const.OPEN_DELEGATE_READ or data.delegation_type == const.OPEN_DELEGATE_READ_ATTRS_DELEG:
            data.read = self.unpack_open_read_delegation4()
        elif data.delegation_type == const.OPEN_DELEGATE_WRITE or data.delegation_type == const.OPEN_DELEGATE_WRITE_ATTRS_DELEG:
            data.write = self.unpack_open_write_delegation4()
        elif data.delegation_type == const.OPEN_DELEGATE_NONE_EXT:
            data.od_whynone = self.unpack_open_none_delegation4()
        else:
            raise XDRError('bad switch=%s' % data.delegation_type)
        if hasattr(self, 'filter_open_delegation4'):
            data = getattr(self, 'filter_open_delegation4')(data)
        return data

    def unpack_OPEN4resok(self):
        data = types.OPEN4resok()
        data.stateid = self.unpack_stateid4()
        data.cinfo = self.unpack_change_info4()
        data.rflags = self.unpack_uint32_t()
        data.attrset = self.unpack_bitmap4()
        data.delegation = self.unpack_open_delegation4()
        if hasattr(self, 'filter_OPEN4resok'):
            data = getattr(self, 'filter_OPEN4resok')(data)
        return data

    def unpack_OPEN4res(self):
        data = types.OPEN4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_OPEN4resok()
        else:
            pass
        if hasattr(self, 'filter_OPEN4res'):
            data = getattr(self, 'filter_OPEN4res')(data)
        return data

    def unpack_OPENATTR4args(self):
        data = types.OPENATTR4args()
        data.createdir = self.unpack_bool()
        if hasattr(self, 'filter_OPENATTR4args'):
            data = getattr(self, 'filter_OPENATTR4args')(data)
        return data

    def unpack_OPENATTR4res(self):
        data = types.OPENATTR4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_OPENATTR4res'):
            data = getattr(self, 'filter_OPENATTR4res')(data)
        return data

    def unpack_OPEN_CONFIRM4args(self):
        data = types.OPEN_CONFIRM4args()
        data.open_stateid = self.unpack_stateid4()
        data.seqid = self.unpack_seqid4()
        if hasattr(self, 'filter_OPEN_CONFIRM4args'):
            data = getattr(self, 'filter_OPEN_CONFIRM4args')(data)
        return data

    def unpack_OPEN_CONFIRM4resok(self):
        data = types.OPEN_CONFIRM4resok()
        data.open_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_OPEN_CONFIRM4resok'):
            data = getattr(self, 'filter_OPEN_CONFIRM4resok')(data)
        return data

    def unpack_OPEN_CONFIRM4res(self):
        data = types.OPEN_CONFIRM4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_OPEN_CONFIRM4resok()
        else:
            pass
        if hasattr(self, 'filter_OPEN_CONFIRM4res'):
            data = getattr(self, 'filter_OPEN_CONFIRM4res')(data)
        return data

    def unpack_OPEN_DOWNGRADE4args(self):
        data = types.OPEN_DOWNGRADE4args()
        data.open_stateid = self.unpack_stateid4()
        data.seqid = self.unpack_seqid4()
        data.share_access = self.unpack_uint32_t()
        data.share_deny = self.unpack_uint32_t()
        if hasattr(self, 'filter_OPEN_DOWNGRADE4args'):
            data = getattr(self, 'filter_OPEN_DOWNGRADE4args')(data)
        return data

    def unpack_OPEN_DOWNGRADE4resok(self):
        data = types.OPEN_DOWNGRADE4resok()
        data.open_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_OPEN_DOWNGRADE4resok'):
            data = getattr(self, 'filter_OPEN_DOWNGRADE4resok')(data)
        return data

    def unpack_OPEN_DOWNGRADE4res(self):
        data = types.OPEN_DOWNGRADE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_OPEN_DOWNGRADE4resok()
        else:
            pass
        if hasattr(self, 'filter_OPEN_DOWNGRADE4res'):
            data = getattr(self, 'filter_OPEN_DOWNGRADE4res')(data)
        return data

    def unpack_PUTFH4args(self):
        data = types.PUTFH4args()
        data.object = self.unpack_nfs_fh4()
        if hasattr(self, 'filter_PUTFH4args'):
            data = getattr(self, 'filter_PUTFH4args')(data)
        return data

    def unpack_PUTFH4res(self):
        data = types.PUTFH4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_PUTFH4res'):
            data = getattr(self, 'filter_PUTFH4res')(data)
        return data

    def unpack_PUTPUBFH4res(self):
        data = types.PUTPUBFH4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_PUTPUBFH4res'):
            data = getattr(self, 'filter_PUTPUBFH4res')(data)
        return data

    def unpack_PUTROOTFH4res(self):
        data = types.PUTROOTFH4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_PUTROOTFH4res'):
            data = getattr(self, 'filter_PUTROOTFH4res')(data)
        return data

    def unpack_READ4args(self):
        data = types.READ4args()
        data.stateid = self.unpack_stateid4()
        data.offset = self.unpack_offset4()
        data.count = self.unpack_count4()
        if hasattr(self, 'filter_READ4args'):
            data = getattr(self, 'filter_READ4args')(data)
        return data

    def unpack_READ4resok(self):
        data = types.READ4resok()
        data.eof = self.unpack_bool()
        data.data = self.unpack_opaque()
        if hasattr(self, 'filter_READ4resok'):
            data = getattr(self, 'filter_READ4resok')(data)
        return data

    def unpack_READ4res(self):
        data = types.READ4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_READ4resok()
        else:
            pass
        if hasattr(self, 'filter_READ4res'):
            data = getattr(self, 'filter_READ4res')(data)
        return data

    def unpack_READDIR4args(self):
        data = types.READDIR4args()
        data.cookie = self.unpack_nfs_cookie4()
        data.cookieverf = self.unpack_verifier4()
        data.dircount = self.unpack_count4()
        data.maxcount = self.unpack_count4()
        data.attr_request = self.unpack_bitmap4()
        if hasattr(self, 'filter_READDIR4args'):
            data = getattr(self, 'filter_READDIR4args')(data)
        return data

    def unpack_entry4(self):
        data = types.entry4()
        data.cookie = self.unpack_nfs_cookie4()
        data.name = self.unpack_component4()
        data.attrs = self.unpack_fattr4()
        data.nextentry = self.unpack_array(self.unpack_entry4)
        if len(data.nextentry) > 1 and self.check_array:
            raise XDRError('array length too long for data.nextentry')
        if hasattr(self, 'filter_entry4'):
            data = getattr(self, 'filter_entry4')(data)
        return data

    def unpack_dirlist4(self):
        data = types.dirlist4()
        data.entries = self.unpack_array(self.unpack_entry4)
        if len(data.entries) > 1 and self.check_array:
            raise XDRError('array length too long for data.entries')
        data.eof = self.unpack_bool()
        if hasattr(self, 'filter_dirlist4'):
            data = getattr(self, 'filter_dirlist4')(data)
        return data

    def unpack_READDIR4resok(self):
        data = types.READDIR4resok()
        data.cookieverf = self.unpack_verifier4()
        data.reply = self.unpack_dirlist4()
        if hasattr(self, 'filter_READDIR4resok'):
            data = getattr(self, 'filter_READDIR4resok')(data)
        return data

    def unpack_READDIR4res(self):
        data = types.READDIR4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_READDIR4resok()
        else:
            pass
        if hasattr(self, 'filter_READDIR4res'):
            data = getattr(self, 'filter_READDIR4res')(data)
        return data

    def unpack_READLINK4resok(self):
        data = types.READLINK4resok()
        data.link = self.unpack_linktext4()
        if hasattr(self, 'filter_READLINK4resok'):
            data = getattr(self, 'filter_READLINK4resok')(data)
        return data

    def unpack_READLINK4res(self):
        data = types.READLINK4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_READLINK4resok()
        else:
            pass
        if hasattr(self, 'filter_READLINK4res'):
            data = getattr(self, 'filter_READLINK4res')(data)
        return data

    def unpack_REMOVE4args(self):
        data = types.REMOVE4args()
        data.target = self.unpack_component4()
        if hasattr(self, 'filter_REMOVE4args'):
            data = getattr(self, 'filter_REMOVE4args')(data)
        return data

    def unpack_REMOVE4resok(self):
        data = types.REMOVE4resok()
        data.cinfo = self.unpack_change_info4()
        if hasattr(self, 'filter_REMOVE4resok'):
            data = getattr(self, 'filter_REMOVE4resok')(data)
        return data

    def unpack_REMOVE4res(self):
        data = types.REMOVE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_REMOVE4resok()
        else:
            pass
        if hasattr(self, 'filter_REMOVE4res'):
            data = getattr(self, 'filter_REMOVE4res')(data)
        return data

    def unpack_RENAME4args(self):
        data = types.RENAME4args()
        data.oldname = self.unpack_component4()
        data.newname = self.unpack_component4()
        if hasattr(self, 'filter_RENAME4args'):
            data = getattr(self, 'filter_RENAME4args')(data)
        return data

    def unpack_RENAME4resok(self):
        data = types.RENAME4resok()
        data.source_cinfo = self.unpack_change_info4()
        data.target_cinfo = self.unpack_change_info4()
        if hasattr(self, 'filter_RENAME4resok'):
            data = getattr(self, 'filter_RENAME4resok')(data)
        return data

    def unpack_RENAME4res(self):
        data = types.RENAME4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_RENAME4resok()
        else:
            pass
        if hasattr(self, 'filter_RENAME4res'):
            data = getattr(self, 'filter_RENAME4res')(data)
        return data

    def unpack_RENEW4args(self):
        data = types.RENEW4args()
        data.clientid = self.unpack_clientid4()
        if hasattr(self, 'filter_RENEW4args'):
            data = getattr(self, 'filter_RENEW4args')(data)
        return data

    def unpack_RENEW4res(self):
        data = types.RENEW4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_RENEW4res'):
            data = getattr(self, 'filter_RENEW4res')(data)
        return data

    def unpack_RESTOREFH4res(self):
        data = types.RESTOREFH4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_RESTOREFH4res'):
            data = getattr(self, 'filter_RESTOREFH4res')(data)
        return data

    def unpack_SAVEFH4res(self):
        data = types.SAVEFH4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_SAVEFH4res'):
            data = getattr(self, 'filter_SAVEFH4res')(data)
        return data

    def unpack_SECINFO4args(self):
        data = types.SECINFO4args()
        data.name = self.unpack_component4()
        if hasattr(self, 'filter_SECINFO4args'):
            data = getattr(self, 'filter_SECINFO4args')(data)
        return data

    def unpack_rpc_gss_svc_t(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.RPC_GSS_SVC_NONE, const.RPC_GSS_SVC_INTEGRITY, const.RPC_GSS_SVC_PRIVACY]:
            raise XDRError('value=%s not in enum rpc_gss_svc_t' % data)
        if hasattr(self, 'filter_rpc_gss_svc_t'):
            data = getattr(self, 'filter_rpc_gss_svc_t')(data)
        return data

    def unpack_rpcsec_gss_info(self):
        data = types.rpcsec_gss_info()
        data.oid = self.unpack_sec_oid4()
        data.qop = self.unpack_qop4()
        data.service = self.unpack_rpc_gss_svc_t()
        if hasattr(self, 'filter_rpcsec_gss_info'):
            data = getattr(self, 'filter_rpcsec_gss_info')(data)
        return data

    def unpack_secinfo4(self):
        data = types.secinfo4()
        data.flavor = self.unpack_uint32_t()
        if data.flavor == const.RPCSEC_GSS:
            data.flavor_info = self.unpack_rpcsec_gss_info()
        else:
            pass
        if hasattr(self, 'filter_secinfo4'):
            data = getattr(self, 'filter_secinfo4')(data)
        return data

    def unpack_SECINFO4resok(self):
        data = self.unpack_array(self.unpack_secinfo4)
        if hasattr(self, 'filter_SECINFO4resok'):
            data = getattr(self, 'filter_SECINFO4resok')(data)
        return data

    def unpack_SECINFO4res(self):
        data = types.SECINFO4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_SECINFO4resok()
        else:
            pass
        if hasattr(self, 'filter_SECINFO4res'):
            data = getattr(self, 'filter_SECINFO4res')(data)
        return data

    def unpack_SETATTR4args(self):
        data = types.SETATTR4args()
        data.stateid = self.unpack_stateid4()
        data.obj_attributes = self.unpack_fattr4()
        if hasattr(self, 'filter_SETATTR4args'):
            data = getattr(self, 'filter_SETATTR4args')(data)
        return data

    def unpack_SETATTR4res(self):
        data = types.SETATTR4res()
        data.status = self.unpack_nfsstat4()
        data.attrsset = self.unpack_bitmap4()
        if hasattr(self, 'filter_SETATTR4res'):
            data = getattr(self, 'filter_SETATTR4res')(data)
        return data

    def unpack_SETCLIENTID4args(self):
        data = types.SETCLIENTID4args()
        data.client = self.unpack_nfs_client_id4()
        data.callback = self.unpack_cb_client4()
        data.callback_ident = self.unpack_uint32_t()
        if hasattr(self, 'filter_SETCLIENTID4args'):
            data = getattr(self, 'filter_SETCLIENTID4args')(data)
        return data

    def unpack_SETCLIENTID4resok(self):
        data = types.SETCLIENTID4resok()
        data.clientid = self.unpack_clientid4()
        data.setclientid_confirm = self.unpack_verifier4()
        if hasattr(self, 'filter_SETCLIENTID4resok'):
            data = getattr(self, 'filter_SETCLIENTID4resok')(data)
        return data

    def unpack_SETCLIENTID4res(self):
        data = types.SETCLIENTID4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_SETCLIENTID4resok()
        elif data.status == const.NFS4ERR_CLID_INUSE:
            data.client_using = self.unpack_clientaddr4()
        else:
            pass
        if hasattr(self, 'filter_SETCLIENTID4res'):
            data = getattr(self, 'filter_SETCLIENTID4res')(data)
        return data

    def unpack_SETCLIENTID_CONFIRM4args(self):
        data = types.SETCLIENTID_CONFIRM4args()
        data.clientid = self.unpack_clientid4()
        data.setclientid_confirm = self.unpack_verifier4()
        if hasattr(self, 'filter_SETCLIENTID_CONFIRM4args'):
            data = getattr(self, 'filter_SETCLIENTID_CONFIRM4args')(data)
        return data

    def unpack_SETCLIENTID_CONFIRM4res(self):
        data = types.SETCLIENTID_CONFIRM4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_SETCLIENTID_CONFIRM4res'):
            data = getattr(self, 'filter_SETCLIENTID_CONFIRM4res')(data)
        return data

    def unpack_VERIFY4args(self):
        data = types.VERIFY4args()
        data.obj_attributes = self.unpack_fattr4()
        if hasattr(self, 'filter_VERIFY4args'):
            data = getattr(self, 'filter_VERIFY4args')(data)
        return data

    def unpack_VERIFY4res(self):
        data = types.VERIFY4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_VERIFY4res'):
            data = getattr(self, 'filter_VERIFY4res')(data)
        return data

    def unpack_WRITE4args(self):
        data = types.WRITE4args()
        data.stateid = self.unpack_stateid4()
        data.offset = self.unpack_offset4()
        data.stable = self.unpack_stable_how4()
        data.data = self.unpack_opaque()
        if hasattr(self, 'filter_WRITE4args'):
            data = getattr(self, 'filter_WRITE4args')(data)
        return data

    def unpack_WRITE4resok(self):
        data = types.WRITE4resok()
        data.count = self.unpack_count4()
        data.committed = self.unpack_stable_how4()
        data.writeverf = self.unpack_verifier4()
        if hasattr(self, 'filter_WRITE4resok'):
            data = getattr(self, 'filter_WRITE4resok')(data)
        return data

    def unpack_WRITE4res(self):
        data = types.WRITE4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_WRITE4resok()
        else:
            pass
        if hasattr(self, 'filter_WRITE4res'):
            data = getattr(self, 'filter_WRITE4res')(data)
        return data

    def unpack_RELEASE_LOCKOWNER4args(self):
        data = types.RELEASE_LOCKOWNER4args()
        data.lock_owner = self.unpack_lock_owner4()
        if hasattr(self, 'filter_RELEASE_LOCKOWNER4args'):
            data = getattr(self, 'filter_RELEASE_LOCKOWNER4args')(data)
        return data

    def unpack_RELEASE_LOCKOWNER4res(self):
        data = types.RELEASE_LOCKOWNER4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_RELEASE_LOCKOWNER4res'):
            data = getattr(self, 'filter_RELEASE_LOCKOWNER4res')(data)
        return data

    def unpack_ILLEGAL4res(self):
        data = types.ILLEGAL4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_ILLEGAL4res'):
            data = getattr(self, 'filter_ILLEGAL4res')(data)
        return data

    def unpack_gsshandle4_t(self):
        data = self.unpack_opaque()
        if hasattr(self, 'filter_gsshandle4_t'):
            data = getattr(self, 'filter_gsshandle4_t')(data)
        return data

    def unpack_gss_cb_handles4(self):
        data = types.gss_cb_handles4()
        data.gcbp_service = self.unpack_rpc_gss_svc_t()
        data.gcbp_handle_from_server = self.unpack_gsshandle4_t()
        data.gcbp_handle_from_client = self.unpack_gsshandle4_t()
        if hasattr(self, 'filter_gss_cb_handles4'):
            data = getattr(self, 'filter_gss_cb_handles4')(data)
        return data

    def unpack_callback_sec_parms4(self):
        data = types.callback_sec_parms4()
        data.cb_secflavor = self.unpack_uint32_t()
        if data.cb_secflavor == const.AUTH_NONE:
            pass
        elif data.cb_secflavor == const.AUTH_SYS:
            data.cbsp_sys_cred = self.unpack_authsys_parms()
        elif data.cb_secflavor == const.RPCSEC_GSS:
            data.cbsp_gss_handles = self.unpack_gss_cb_handles4()
        else:
            raise XDRError('bad switch=%s' % data.cb_secflavor)
        if hasattr(self, 'filter_callback_sec_parms4'):
            data = getattr(self, 'filter_callback_sec_parms4')(data)
        return data

    def unpack_BACKCHANNEL_CTL4args(self):
        data = types.BACKCHANNEL_CTL4args()
        data.bca_cb_program = self.unpack_uint32_t()
        data.bca_sec_parms = self.unpack_array(self.unpack_callback_sec_parms4)
        if hasattr(self, 'filter_BACKCHANNEL_CTL4args'):
            data = getattr(self, 'filter_BACKCHANNEL_CTL4args')(data)
        return data

    def unpack_BACKCHANNEL_CTL4res(self):
        data = types.BACKCHANNEL_CTL4res()
        data.bcr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_BACKCHANNEL_CTL4res'):
            data = getattr(self, 'filter_BACKCHANNEL_CTL4res')(data)
        return data

    def unpack_channel_dir_from_client4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.CDFC4_FORE, const.CDFC4_BACK, const.CDFC4_FORE_OR_BOTH, const.CDFC4_BACK_OR_BOTH]:
            raise XDRError('value=%s not in enum channel_dir_from_client4' % data)
        if hasattr(self, 'filter_channel_dir_from_client4'):
            data = getattr(self, 'filter_channel_dir_from_client4')(data)
        return data

    def unpack_BIND_CONN_TO_SESSION4args(self):
        data = types.BIND_CONN_TO_SESSION4args()
        data.bctsa_sessid = self.unpack_sessionid4()
        data.bctsa_dir = self.unpack_channel_dir_from_client4()
        data.bctsa_use_conn_in_rdma_mode = self.unpack_bool()
        if hasattr(self, 'filter_BIND_CONN_TO_SESSION4args'):
            data = getattr(self, 'filter_BIND_CONN_TO_SESSION4args')(data)
        return data

    def unpack_channel_dir_from_server4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.CDFS4_FORE, const.CDFS4_BACK, const.CDFS4_BOTH]:
            raise XDRError('value=%s not in enum channel_dir_from_server4' % data)
        if hasattr(self, 'filter_channel_dir_from_server4'):
            data = getattr(self, 'filter_channel_dir_from_server4')(data)
        return data

    def unpack_BIND_CONN_TO_SESSION4resok(self):
        data = types.BIND_CONN_TO_SESSION4resok()
        data.bctsr_sessid = self.unpack_sessionid4()
        data.bctsr_dir = self.unpack_channel_dir_from_server4()
        data.bctsr_use_conn_in_rdma_mode = self.unpack_bool()
        if hasattr(self, 'filter_BIND_CONN_TO_SESSION4resok'):
            data = getattr(self, 'filter_BIND_CONN_TO_SESSION4resok')(data)
        return data

    def unpack_BIND_CONN_TO_SESSION4res(self):
        data = types.BIND_CONN_TO_SESSION4res()
        data.bctsr_status = self.unpack_nfsstat4()
        if data.bctsr_status == const.NFS4_OK:
            data.bctsr_resok4 = self.unpack_BIND_CONN_TO_SESSION4resok()
        else:
            pass
        if hasattr(self, 'filter_BIND_CONN_TO_SESSION4res'):
            data = getattr(self, 'filter_BIND_CONN_TO_SESSION4res')(data)
        return data

    def unpack_state_protect_ops4(self):
        data = types.state_protect_ops4()
        data.spo_must_enforce = self.unpack_bitmap4()
        data.spo_must_allow = self.unpack_bitmap4()
        if hasattr(self, 'filter_state_protect_ops4'):
            data = getattr(self, 'filter_state_protect_ops4')(data)
        return data

    def unpack_ssv_sp_parms4(self):
        data = types.ssv_sp_parms4()
        data.ssp_ops = self.unpack_state_protect_ops4()
        data.ssp_hash_algs = self.unpack_array(self.unpack_sec_oid4)
        data.ssp_encr_algs = self.unpack_array(self.unpack_sec_oid4)
        data.ssp_window = self.unpack_uint32_t()
        data.ssp_num_gss_handles = self.unpack_uint32_t()
        if hasattr(self, 'filter_ssv_sp_parms4'):
            data = getattr(self, 'filter_ssv_sp_parms4')(data)
        return data

    def unpack_state_protect_how4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.SP4_NONE, const.SP4_MACH_CRED, const.SP4_SSV]:
            raise XDRError('value=%s not in enum state_protect_how4' % data)
        if hasattr(self, 'filter_state_protect_how4'):
            data = getattr(self, 'filter_state_protect_how4')(data)
        return data

    def unpack_state_protect4_a(self):
        data = types.state_protect4_a()
        data.spa_how = self.unpack_state_protect_how4()
        if data.spa_how == const.SP4_NONE:
            pass
        elif data.spa_how == const.SP4_MACH_CRED:
            data.spa_mach_ops = self.unpack_state_protect_ops4()
        elif data.spa_how == const.SP4_SSV:
            data.spa_ssv_parms = self.unpack_ssv_sp_parms4()
        else:
            raise XDRError('bad switch=%s' % data.spa_how)
        if hasattr(self, 'filter_state_protect4_a'):
            data = getattr(self, 'filter_state_protect4_a')(data)
        return data

    def unpack_EXCHANGE_ID4args(self):
        data = types.EXCHANGE_ID4args()
        data.eia_clientowner = self.unpack_client_owner4()
        data.eia_flags = self.unpack_uint32_t()
        data.eia_state_protect = self.unpack_state_protect4_a()
        data.eia_client_impl_id = self.unpack_array(self.unpack_nfs_impl_id4)
        if len(data.eia_client_impl_id) > 1 and self.check_array:
            raise XDRError('array length too long for data.eia_client_impl_id')
        if hasattr(self, 'filter_EXCHANGE_ID4args'):
            data = getattr(self, 'filter_EXCHANGE_ID4args')(data)
        return data

    def unpack_ssv_prot_info4(self):
        data = types.ssv_prot_info4()
        data.spi_ops = self.unpack_state_protect_ops4()
        data.spi_hash_alg = self.unpack_uint32_t()
        data.spi_encr_alg = self.unpack_uint32_t()
        data.spi_ssv_len = self.unpack_uint32_t()
        data.spi_window = self.unpack_uint32_t()
        data.spi_handles = self.unpack_array(self.unpack_gsshandle4_t)
        if hasattr(self, 'filter_ssv_prot_info4'):
            data = getattr(self, 'filter_ssv_prot_info4')(data)
        return data

    def unpack_state_protect4_r(self):
        data = types.state_protect4_r()
        data.spr_how = self.unpack_state_protect_how4()
        if data.spr_how == const.SP4_NONE:
            pass
        elif data.spr_how == const.SP4_MACH_CRED:
            data.spr_mach_ops = self.unpack_state_protect_ops4()
        elif data.spr_how == const.SP4_SSV:
            data.spr_ssv_info = self.unpack_ssv_prot_info4()
        else:
            raise XDRError('bad switch=%s' % data.spr_how)
        if hasattr(self, 'filter_state_protect4_r'):
            data = getattr(self, 'filter_state_protect4_r')(data)
        return data

    def unpack_EXCHANGE_ID4resok(self):
        data = types.EXCHANGE_ID4resok()
        data.eir_clientid = self.unpack_clientid4()
        data.eir_sequenceid = self.unpack_sequenceid4()
        data.eir_flags = self.unpack_uint32_t()
        data.eir_state_protect = self.unpack_state_protect4_r()
        data.eir_server_owner = self.unpack_server_owner4()
        data.eir_server_scope = self.unpack_opaque()
        if len(data.eir_server_scope) > const.NFS4_OPAQUE_LIMIT and self.check_array:
            raise XDRError('array length too long for data.eir_server_scope')
        data.eir_server_impl_id = self.unpack_array(self.unpack_nfs_impl_id4)
        if len(data.eir_server_impl_id) > 1 and self.check_array:
            raise XDRError('array length too long for data.eir_server_impl_id')
        if hasattr(self, 'filter_EXCHANGE_ID4resok'):
            data = getattr(self, 'filter_EXCHANGE_ID4resok')(data)
        return data

    def unpack_EXCHANGE_ID4res(self):
        data = types.EXCHANGE_ID4res()
        data.eir_status = self.unpack_nfsstat4()
        if data.eir_status == const.NFS4_OK:
            data.eir_resok4 = self.unpack_EXCHANGE_ID4resok()
        else:
            pass
        if hasattr(self, 'filter_EXCHANGE_ID4res'):
            data = getattr(self, 'filter_EXCHANGE_ID4res')(data)
        return data

    def unpack_channel_attrs4(self):
        data = types.channel_attrs4()
        data.ca_headerpadsize = self.unpack_count4()
        data.ca_maxrequestsize = self.unpack_count4()
        data.ca_maxresponsesize = self.unpack_count4()
        data.ca_maxresponsesize_cached = self.unpack_count4()
        data.ca_maxoperations = self.unpack_count4()
        data.ca_maxrequests = self.unpack_count4()
        data.ca_rdma_ird = self.unpack_array(self.unpack_uint32_t)
        if len(data.ca_rdma_ird) > 1 and self.check_array:
            raise XDRError('array length too long for data.ca_rdma_ird')
        if hasattr(self, 'filter_channel_attrs4'):
            data = getattr(self, 'filter_channel_attrs4')(data)
        return data

    def unpack_CREATE_SESSION4args(self):
        data = types.CREATE_SESSION4args()
        data.csa_clientid = self.unpack_clientid4()
        data.csa_sequence = self.unpack_sequenceid4()
        data.csa_flags = self.unpack_uint32_t()
        data.csa_fore_chan_attrs = self.unpack_channel_attrs4()
        data.csa_back_chan_attrs = self.unpack_channel_attrs4()
        data.csa_cb_program = self.unpack_uint32_t()
        data.csa_sec_parms = self.unpack_array(self.unpack_callback_sec_parms4)
        if hasattr(self, 'filter_CREATE_SESSION4args'):
            data = getattr(self, 'filter_CREATE_SESSION4args')(data)
        return data

    def unpack_CREATE_SESSION4resok(self):
        data = types.CREATE_SESSION4resok()
        data.csr_sessionid = self.unpack_sessionid4()
        data.csr_sequence = self.unpack_sequenceid4()
        data.csr_flags = self.unpack_uint32_t()
        data.csr_fore_chan_attrs = self.unpack_channel_attrs4()
        data.csr_back_chan_attrs = self.unpack_channel_attrs4()
        if hasattr(self, 'filter_CREATE_SESSION4resok'):
            data = getattr(self, 'filter_CREATE_SESSION4resok')(data)
        return data

    def unpack_CREATE_SESSION4res(self):
        data = types.CREATE_SESSION4res()
        data.csr_status = self.unpack_nfsstat4()
        if data.csr_status == const.NFS4_OK:
            data.csr_resok4 = self.unpack_CREATE_SESSION4resok()
        else:
            pass
        if hasattr(self, 'filter_CREATE_SESSION4res'):
            data = getattr(self, 'filter_CREATE_SESSION4res')(data)
        return data

    def unpack_DESTROY_SESSION4args(self):
        data = types.DESTROY_SESSION4args()
        data.dsa_sessionid = self.unpack_sessionid4()
        if hasattr(self, 'filter_DESTROY_SESSION4args'):
            data = getattr(self, 'filter_DESTROY_SESSION4args')(data)
        return data

    def unpack_DESTROY_SESSION4res(self):
        data = types.DESTROY_SESSION4res()
        data.dsr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_DESTROY_SESSION4res'):
            data = getattr(self, 'filter_DESTROY_SESSION4res')(data)
        return data

    def unpack_FREE_STATEID4args(self):
        data = types.FREE_STATEID4args()
        data.fsa_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_FREE_STATEID4args'):
            data = getattr(self, 'filter_FREE_STATEID4args')(data)
        return data

    def unpack_FREE_STATEID4res(self):
        data = types.FREE_STATEID4res()
        data.fsr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_FREE_STATEID4res'):
            data = getattr(self, 'filter_FREE_STATEID4res')(data)
        return data

    unpack_attr_notice4 = unpack_nfstime4

    def unpack_GET_DIR_DELEGATION4args(self):
        data = types.GET_DIR_DELEGATION4args()
        data.gdda_signal_deleg_avail = self.unpack_bool()
        data.gdda_notification_types = self.unpack_bitmap4()
        data.gdda_child_attr_delay = self.unpack_attr_notice4()
        data.gdda_dir_attr_delay = self.unpack_attr_notice4()
        data.gdda_child_attributes = self.unpack_bitmap4()
        data.gdda_dir_attributes = self.unpack_bitmap4()
        if hasattr(self, 'filter_GET_DIR_DELEGATION4args'):
            data = getattr(self, 'filter_GET_DIR_DELEGATION4args')(data)
        return data

    def unpack_GET_DIR_DELEGATION4resok(self):
        data = types.GET_DIR_DELEGATION4resok()
        data.gddr_cookieverf = self.unpack_verifier4()
        data.gddr_stateid = self.unpack_stateid4()
        data.gddr_notification = self.unpack_bitmap4()
        data.gddr_child_attributes = self.unpack_bitmap4()
        data.gddr_dir_attributes = self.unpack_bitmap4()
        if hasattr(self, 'filter_GET_DIR_DELEGATION4resok'):
            data = getattr(self, 'filter_GET_DIR_DELEGATION4resok')(data)
        return data

    def unpack_gddrnf4_status(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.GDD4_OK, const.GDD4_UNAVAIL]:
            raise XDRError('value=%s not in enum gddrnf4_status' % data)
        if hasattr(self, 'filter_gddrnf4_status'):
            data = getattr(self, 'filter_gddrnf4_status')(data)
        return data

    def unpack_GET_DIR_DELEGATION4res_non_fatal(self):
        data = types.GET_DIR_DELEGATION4res_non_fatal()
        data.gddrnf_status = self.unpack_gddrnf4_status()
        if data.gddrnf_status == const.GDD4_OK:
            data.gddrnf_resok4 = self.unpack_GET_DIR_DELEGATION4resok()
        elif data.gddrnf_status == const.GDD4_UNAVAIL:
            data.gddrnf_will_signal_deleg_avail = self.unpack_bool()
        else:
            raise XDRError('bad switch=%s' % data.gddrnf_status)
        if hasattr(self, 'filter_GET_DIR_DELEGATION4res_non_fatal'):
            data = getattr(self, 'filter_GET_DIR_DELEGATION4res_non_fatal')(data)
        return data

    def unpack_GET_DIR_DELEGATION4res(self):
        data = types.GET_DIR_DELEGATION4res()
        data.gddr_status = self.unpack_nfsstat4()
        if data.gddr_status == const.NFS4_OK:
            data.gddr_res_non_fatal4 = self.unpack_GET_DIR_DELEGATION4res_non_fatal()
        else:
            pass
        if hasattr(self, 'filter_GET_DIR_DELEGATION4res'):
            data = getattr(self, 'filter_GET_DIR_DELEGATION4res')(data)
        return data

    def unpack_GETDEVICEINFO4args(self):
        data = types.GETDEVICEINFO4args()
        data.gdia_device_id = self.unpack_deviceid4()
        data.gdia_layout_type = self.unpack_layouttype4()
        data.gdia_maxcount = self.unpack_count4()
        data.gdia_notify_types = self.unpack_bitmap4()
        if hasattr(self, 'filter_GETDEVICEINFO4args'):
            data = getattr(self, 'filter_GETDEVICEINFO4args')(data)
        return data

    def unpack_GETDEVICEINFO4resok(self):
        data = types.GETDEVICEINFO4resok()
        data.gdir_device_addr = self.unpack_device_addr4()
        data.gdir_notification = self.unpack_bitmap4()
        if hasattr(self, 'filter_GETDEVICEINFO4resok'):
            data = getattr(self, 'filter_GETDEVICEINFO4resok')(data)
        return data

    def unpack_GETDEVICEINFO4res(self):
        data = types.GETDEVICEINFO4res()
        data.gdir_status = self.unpack_nfsstat4()
        if data.gdir_status == const.NFS4_OK:
            data.gdir_resok4 = self.unpack_GETDEVICEINFO4resok()
        elif data.gdir_status == const.NFS4ERR_TOOSMALL:
            data.gdir_mincount = self.unpack_count4()
        else:
            pass
        if hasattr(self, 'filter_GETDEVICEINFO4res'):
            data = getattr(self, 'filter_GETDEVICEINFO4res')(data)
        return data

    def unpack_GETDEVICELIST4args(self):
        data = types.GETDEVICELIST4args()
        data.gdla_layout_type = self.unpack_layouttype4()
        data.gdla_maxdevices = self.unpack_count4()
        data.gdla_cookie = self.unpack_nfs_cookie4()
        data.gdla_cookieverf = self.unpack_verifier4()
        if hasattr(self, 'filter_GETDEVICELIST4args'):
            data = getattr(self, 'filter_GETDEVICELIST4args')(data)
        return data

    def unpack_GETDEVICELIST4resok(self):
        data = types.GETDEVICELIST4resok()
        data.gdlr_cookie = self.unpack_nfs_cookie4()
        data.gdlr_cookieverf = self.unpack_verifier4()
        data.gdlr_deviceid_list = self.unpack_array(self.unpack_deviceid4)
        data.gdlr_eof = self.unpack_bool()
        if hasattr(self, 'filter_GETDEVICELIST4resok'):
            data = getattr(self, 'filter_GETDEVICELIST4resok')(data)
        return data

    def unpack_GETDEVICELIST4res(self):
        data = types.GETDEVICELIST4res()
        data.gdlr_status = self.unpack_nfsstat4()
        if data.gdlr_status == const.NFS4_OK:
            data.gdlr_resok4 = self.unpack_GETDEVICELIST4resok()
        else:
            pass
        if hasattr(self, 'filter_GETDEVICELIST4res'):
            data = getattr(self, 'filter_GETDEVICELIST4res')(data)
        return data

    def unpack_newtime4(self):
        data = types.newtime4()
        data.nt_timechanged = self.unpack_bool()
        if data.nt_timechanged == const.TRUE:
            data.nt_time = self.unpack_nfstime4()
        elif data.nt_timechanged == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.nt_timechanged)
        if hasattr(self, 'filter_newtime4'):
            data = getattr(self, 'filter_newtime4')(data)
        return data

    def unpack_newoffset4(self):
        data = types.newoffset4()
        data.no_newoffset = self.unpack_bool()
        if data.no_newoffset == const.TRUE:
            data.no_offset = self.unpack_offset4()
        elif data.no_newoffset == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.no_newoffset)
        if hasattr(self, 'filter_newoffset4'):
            data = getattr(self, 'filter_newoffset4')(data)
        return data

    def unpack_LAYOUTCOMMIT4args(self):
        data = types.LAYOUTCOMMIT4args()
        data.loca_offset = self.unpack_offset4()
        data.loca_length = self.unpack_length4()
        data.loca_reclaim = self.unpack_bool()
        data.loca_stateid = self.unpack_stateid4()
        data.loca_last_write_offset = self.unpack_newoffset4()
        data.loca_time_modify = self.unpack_newtime4()
        data.loca_layoutupdate = self.unpack_layoutupdate4()
        if hasattr(self, 'filter_LAYOUTCOMMIT4args'):
            data = getattr(self, 'filter_LAYOUTCOMMIT4args')(data)
        return data

    def unpack_newsize4(self):
        data = types.newsize4()
        data.ns_sizechanged = self.unpack_bool()
        if data.ns_sizechanged == const.TRUE:
            data.ns_size = self.unpack_length4()
        elif data.ns_sizechanged == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.ns_sizechanged)
        if hasattr(self, 'filter_newsize4'):
            data = getattr(self, 'filter_newsize4')(data)
        return data

    def unpack_LAYOUTCOMMIT4resok(self):
        data = types.LAYOUTCOMMIT4resok()
        data.locr_newsize = self.unpack_newsize4()
        if hasattr(self, 'filter_LAYOUTCOMMIT4resok'):
            data = getattr(self, 'filter_LAYOUTCOMMIT4resok')(data)
        return data

    def unpack_LAYOUTCOMMIT4res(self):
        data = types.LAYOUTCOMMIT4res()
        data.locr_status = self.unpack_nfsstat4()
        if data.locr_status == const.NFS4_OK:
            data.locr_resok4 = self.unpack_LAYOUTCOMMIT4resok()
        else:
            pass
        if hasattr(self, 'filter_LAYOUTCOMMIT4res'):
            data = getattr(self, 'filter_LAYOUTCOMMIT4res')(data)
        return data

    def unpack_LAYOUTGET4args(self):
        data = types.LAYOUTGET4args()
        data.loga_signal_layout_avail = self.unpack_bool()
        data.loga_layout_type = self.unpack_layouttype4()
        data.loga_iomode = self.unpack_layoutiomode4()
        data.loga_offset = self.unpack_offset4()
        data.loga_length = self.unpack_length4()
        data.loga_minlength = self.unpack_length4()
        data.loga_stateid = self.unpack_stateid4()
        data.loga_maxcount = self.unpack_count4()
        if hasattr(self, 'filter_LAYOUTGET4args'):
            data = getattr(self, 'filter_LAYOUTGET4args')(data)
        return data

    def unpack_LAYOUTGET4resok(self):
        data = types.LAYOUTGET4resok()
        data.logr_return_on_close = self.unpack_bool()
        data.logr_stateid = self.unpack_stateid4()
        data.logr_layout = self.unpack_array(self.unpack_layout4)
        if hasattr(self, 'filter_LAYOUTGET4resok'):
            data = getattr(self, 'filter_LAYOUTGET4resok')(data)
        return data

    def unpack_LAYOUTGET4res(self):
        data = types.LAYOUTGET4res()
        data.logr_status = self.unpack_nfsstat4()
        if data.logr_status == const.NFS4_OK:
            data.logr_resok4 = self.unpack_LAYOUTGET4resok()
        elif data.logr_status == const.NFS4ERR_LAYOUTTRYLATER:
            data.logr_will_signal_layout_avail = self.unpack_bool()
        else:
            pass
        if hasattr(self, 'filter_LAYOUTGET4res'):
            data = getattr(self, 'filter_LAYOUTGET4res')(data)
        return data

    def unpack_LAYOUTRETURN4args(self):
        data = types.LAYOUTRETURN4args()
        data.lora_reclaim = self.unpack_bool()
        data.lora_layout_type = self.unpack_layouttype4()
        data.lora_iomode = self.unpack_layoutiomode4()
        data.lora_layoutreturn = self.unpack_layoutreturn4()
        if hasattr(self, 'filter_LAYOUTRETURN4args'):
            data = getattr(self, 'filter_LAYOUTRETURN4args')(data)
        return data

    def unpack_layoutreturn_stateid(self):
        data = types.layoutreturn_stateid()
        data.lrs_present = self.unpack_bool()
        if data.lrs_present == const.TRUE:
            data.lrs_stateid = self.unpack_stateid4()
        elif data.lrs_present == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.lrs_present)
        if hasattr(self, 'filter_layoutreturn_stateid'):
            data = getattr(self, 'filter_layoutreturn_stateid')(data)
        return data

    def unpack_LAYOUTRETURN4res(self):
        data = types.LAYOUTRETURN4res()
        data.lorr_status = self.unpack_nfsstat4()
        if data.lorr_status == const.NFS4_OK:
            data.lorr_stateid = self.unpack_layoutreturn_stateid()
        else:
            pass
        if hasattr(self, 'filter_LAYOUTRETURN4res'):
            data = getattr(self, 'filter_LAYOUTRETURN4res')(data)
        return data

    def unpack_secinfo_style4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.SECINFO_STYLE4_CURRENT_FH, const.SECINFO_STYLE4_PARENT]:
            raise XDRError('value=%s not in enum secinfo_style4' % data)
        if hasattr(self, 'filter_secinfo_style4'):
            data = getattr(self, 'filter_secinfo_style4')(data)
        return data

    unpack_SECINFO_NO_NAME4args = unpack_secinfo_style4

    unpack_SECINFO_NO_NAME4res = unpack_SECINFO4res

    def unpack_SEQUENCE4args(self):
        data = types.SEQUENCE4args()
        data.sa_sessionid = self.unpack_sessionid4()
        data.sa_sequenceid = self.unpack_sequenceid4()
        data.sa_slotid = self.unpack_slotid4()
        data.sa_highest_slotid = self.unpack_slotid4()
        data.sa_cachethis = self.unpack_bool()
        if hasattr(self, 'filter_SEQUENCE4args'):
            data = getattr(self, 'filter_SEQUENCE4args')(data)
        return data

    def unpack_SEQUENCE4resok(self):
        data = types.SEQUENCE4resok()
        data.sr_sessionid = self.unpack_sessionid4()
        data.sr_sequenceid = self.unpack_sequenceid4()
        data.sr_slotid = self.unpack_slotid4()
        data.sr_highest_slotid = self.unpack_slotid4()
        data.sr_target_highest_slotid = self.unpack_slotid4()
        data.sr_status_flags = self.unpack_uint32_t()
        if hasattr(self, 'filter_SEQUENCE4resok'):
            data = getattr(self, 'filter_SEQUENCE4resok')(data)
        return data

    def unpack_SEQUENCE4res(self):
        data = types.SEQUENCE4res()
        data.sr_status = self.unpack_nfsstat4()
        if data.sr_status == const.NFS4_OK:
            data.sr_resok4 = self.unpack_SEQUENCE4resok()
        else:
            pass
        if hasattr(self, 'filter_SEQUENCE4res'):
            data = getattr(self, 'filter_SEQUENCE4res')(data)
        return data

    def unpack_ssa_digest_input4(self):
        data = types.ssa_digest_input4()
        data.sdi_seqargs = self.unpack_SEQUENCE4args()
        if hasattr(self, 'filter_ssa_digest_input4'):
            data = getattr(self, 'filter_ssa_digest_input4')(data)
        return data

    def unpack_SET_SSV4args(self):
        data = types.SET_SSV4args()
        data.ssa_ssv = self.unpack_opaque()
        data.ssa_digest = self.unpack_opaque()
        if hasattr(self, 'filter_SET_SSV4args'):
            data = getattr(self, 'filter_SET_SSV4args')(data)
        return data

    def unpack_ssr_digest_input4(self):
        data = types.ssr_digest_input4()
        data.sdi_seqres = self.unpack_SEQUENCE4res()
        if hasattr(self, 'filter_ssr_digest_input4'):
            data = getattr(self, 'filter_ssr_digest_input4')(data)
        return data

    def unpack_SET_SSV4resok(self):
        data = types.SET_SSV4resok()
        data.ssr_digest = self.unpack_opaque()
        if hasattr(self, 'filter_SET_SSV4resok'):
            data = getattr(self, 'filter_SET_SSV4resok')(data)
        return data

    def unpack_SET_SSV4res(self):
        data = types.SET_SSV4res()
        data.ssr_status = self.unpack_nfsstat4()
        if data.ssr_status == const.NFS4_OK:
            data.ssr_resok4 = self.unpack_SET_SSV4resok()
        else:
            pass
        if hasattr(self, 'filter_SET_SSV4res'):
            data = getattr(self, 'filter_SET_SSV4res')(data)
        return data

    def unpack_TEST_STATEID4args(self):
        data = types.TEST_STATEID4args()
        data.ts_stateids = self.unpack_array(self.unpack_stateid4)
        if hasattr(self, 'filter_TEST_STATEID4args'):
            data = getattr(self, 'filter_TEST_STATEID4args')(data)
        return data

    def unpack_TEST_STATEID4resok(self):
        data = types.TEST_STATEID4resok()
        data.tsr_status_codes = self.unpack_array(self.unpack_nfsstat4)
        if hasattr(self, 'filter_TEST_STATEID4resok'):
            data = getattr(self, 'filter_TEST_STATEID4resok')(data)
        return data

    def unpack_TEST_STATEID4res(self):
        data = types.TEST_STATEID4res()
        data.tsr_status = self.unpack_nfsstat4()
        if data.tsr_status == const.NFS4_OK:
            data.tsr_resok4 = self.unpack_TEST_STATEID4resok()
        else:
            pass
        if hasattr(self, 'filter_TEST_STATEID4res'):
            data = getattr(self, 'filter_TEST_STATEID4res')(data)
        return data

    def unpack_deleg_claim4(self):
        data = types.deleg_claim4()
        data.dc_claim = self.unpack_open_claim_type4()
        if data.dc_claim == const.CLAIM_FH:
            pass
        elif data.dc_claim == const.CLAIM_DELEG_PREV_FH:
            pass
        elif data.dc_claim == const.CLAIM_PREVIOUS:
            data.dc_delegate_type = self.unpack_open_delegation_type4()
        else:
            raise XDRError('bad switch=%s' % data.dc_claim)
        if hasattr(self, 'filter_deleg_claim4'):
            data = getattr(self, 'filter_deleg_claim4')(data)
        return data

    def unpack_WANT_DELEGATION4args(self):
        data = types.WANT_DELEGATION4args()
        data.wda_want = self.unpack_uint32_t()
        data.wda_claim = self.unpack_deleg_claim4()
        if hasattr(self, 'filter_WANT_DELEGATION4args'):
            data = getattr(self, 'filter_WANT_DELEGATION4args')(data)
        return data

    def unpack_WANT_DELEGATION4res(self):
        data = types.WANT_DELEGATION4res()
        data.wdr_status = self.unpack_nfsstat4()
        if data.wdr_status == const.NFS4_OK:
            data.wdr_resok4 = self.unpack_open_delegation4()
        else:
            pass
        if hasattr(self, 'filter_WANT_DELEGATION4res'):
            data = getattr(self, 'filter_WANT_DELEGATION4res')(data)
        return data

    def unpack_DESTROY_CLIENTID4args(self):
        data = types.DESTROY_CLIENTID4args()
        data.dca_clientid = self.unpack_clientid4()
        if hasattr(self, 'filter_DESTROY_CLIENTID4args'):
            data = getattr(self, 'filter_DESTROY_CLIENTID4args')(data)
        return data

    def unpack_DESTROY_CLIENTID4res(self):
        data = types.DESTROY_CLIENTID4res()
        data.dcr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_DESTROY_CLIENTID4res'):
            data = getattr(self, 'filter_DESTROY_CLIENTID4res')(data)
        return data

    def unpack_RECLAIM_COMPLETE4args(self):
        data = types.RECLAIM_COMPLETE4args()
        data.rca_one_fs = self.unpack_bool()
        if hasattr(self, 'filter_RECLAIM_COMPLETE4args'):
            data = getattr(self, 'filter_RECLAIM_COMPLETE4args')(data)
        return data

    def unpack_RECLAIM_COMPLETE4res(self):
        data = types.RECLAIM_COMPLETE4res()
        data.rcr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_RECLAIM_COMPLETE4res'):
            data = getattr(self, 'filter_RECLAIM_COMPLETE4res')(data)
        return data

    def unpack_COPY4args(self):
        data = types.COPY4args()
        data.ca_src_stateid = self.unpack_stateid4()
        data.ca_dst_stateid = self.unpack_stateid4()
        data.ca_src_offset = self.unpack_offset4()
        data.ca_dst_offset = self.unpack_offset4()
        data.ca_count = self.unpack_length4()
        data.ca_consecutive = self.unpack_bool()
        data.ca_synchronous = self.unpack_bool()
        data.ca_source_server = self.unpack_array(self.unpack_netloc4)
        if hasattr(self, 'filter_COPY4args'):
            data = getattr(self, 'filter_COPY4args')(data)
        return data

    def unpack_copy_requirements4(self):
        data = types.copy_requirements4()
        data.cr_consecutive = self.unpack_bool()
        data.cr_synchronous = self.unpack_bool()
        if hasattr(self, 'filter_copy_requirements4'):
            data = getattr(self, 'filter_copy_requirements4')(data)
        return data

    def unpack_COPY4resok(self):
        data = types.COPY4resok()
        data.cr_response = self.unpack_write_response4()
        data.cr_requirements = self.unpack_copy_requirements4()
        if hasattr(self, 'filter_COPY4resok'):
            data = getattr(self, 'filter_COPY4resok')(data)
        return data

    def unpack_COPY4res(self):
        data = types.COPY4res()
        data.cr_status = self.unpack_nfsstat4()
        if data.cr_status == const.NFS4_OK:
            data.cr_resok4 = self.unpack_COPY4resok()
        elif data.cr_status == const.NFS4ERR_OFFLOAD_NO_REQS:
            data.cr_requirements = self.unpack_copy_requirements4()
        else:
            pass
        if hasattr(self, 'filter_COPY4res'):
            data = getattr(self, 'filter_COPY4res')(data)
        return data

    def unpack_COPY_NOTIFY4args(self):
        data = types.COPY_NOTIFY4args()
        data.cna_src_stateid = self.unpack_stateid4()
        data.cna_destination_server = self.unpack_netloc4()
        if hasattr(self, 'filter_COPY_NOTIFY4args'):
            data = getattr(self, 'filter_COPY_NOTIFY4args')(data)
        return data

    def unpack_COPY_NOTIFY4resok(self):
        data = types.COPY_NOTIFY4resok()
        data.cnr_lease_time = self.unpack_nfstime4()
        data.cnr_stateid = self.unpack_stateid4()
        data.cnr_source_server = self.unpack_array(self.unpack_netloc4)
        if hasattr(self, 'filter_COPY_NOTIFY4resok'):
            data = getattr(self, 'filter_COPY_NOTIFY4resok')(data)
        return data

    def unpack_COPY_NOTIFY4res(self):
        data = types.COPY_NOTIFY4res()
        data.cnr_status = self.unpack_nfsstat4()
        if data.cnr_status == const.NFS4_OK:
            data.resok4 = self.unpack_COPY_NOTIFY4resok()
        else:
            pass
        if hasattr(self, 'filter_COPY_NOTIFY4res'):
            data = getattr(self, 'filter_COPY_NOTIFY4res')(data)
        return data

    def unpack_OFFLOAD_CANCEL4args(self):
        data = types.OFFLOAD_CANCEL4args()
        data.oca_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_OFFLOAD_CANCEL4args'):
            data = getattr(self, 'filter_OFFLOAD_CANCEL4args')(data)
        return data

    def unpack_OFFLOAD_CANCEL4res(self):
        data = types.OFFLOAD_CANCEL4res()
        data.ocr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_OFFLOAD_CANCEL4res'):
            data = getattr(self, 'filter_OFFLOAD_CANCEL4res')(data)
        return data

    def unpack_OFFLOAD_STATUS4args(self):
        data = types.OFFLOAD_STATUS4args()
        data.osa_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_OFFLOAD_STATUS4args'):
            data = getattr(self, 'filter_OFFLOAD_STATUS4args')(data)
        return data

    def unpack_OFFLOAD_STATUS4resok(self):
        data = types.OFFLOAD_STATUS4resok()
        data.osr_count = self.unpack_length4()
        data.osr_complete = self.unpack_array(self.unpack_nfsstat4)
        if len(data.osr_complete) > 1 and self.check_array:
            raise XDRError('array length too long for data.osr_complete')
        if hasattr(self, 'filter_OFFLOAD_STATUS4resok'):
            data = getattr(self, 'filter_OFFLOAD_STATUS4resok')(data)
        return data

    def unpack_OFFLOAD_STATUS4res(self):
        data = types.OFFLOAD_STATUS4res()
        data.osr_status = self.unpack_nfsstat4()
        if data.osr_status == const.NFS4_OK:
            data.osr_resok4 = self.unpack_OFFLOAD_STATUS4resok()
        else:
            pass
        if hasattr(self, 'filter_OFFLOAD_STATUS4res'):
            data = getattr(self, 'filter_OFFLOAD_STATUS4res')(data)
        return data

    def unpack_ALLOCATE4args(self):
        data = types.ALLOCATE4args()
        data.aa_stateid = self.unpack_stateid4()
        data.aa_offset = self.unpack_offset4()
        data.aa_length = self.unpack_length4()
        if hasattr(self, 'filter_ALLOCATE4args'):
            data = getattr(self, 'filter_ALLOCATE4args')(data)
        return data

    def unpack_ALLOCATE4res(self):
        data = types.ALLOCATE4res()
        data.ar_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_ALLOCATE4res'):
            data = getattr(self, 'filter_ALLOCATE4res')(data)
        return data

    def unpack_DEALLOCATE4args(self):
        data = types.DEALLOCATE4args()
        data.da_stateid = self.unpack_stateid4()
        data.da_offset = self.unpack_offset4()
        data.da_length = self.unpack_length4()
        if hasattr(self, 'filter_DEALLOCATE4args'):
            data = getattr(self, 'filter_DEALLOCATE4args')(data)
        return data

    def unpack_DEALLOCATE4res(self):
        data = types.DEALLOCATE4res()
        data.dr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_DEALLOCATE4res'):
            data = getattr(self, 'filter_DEALLOCATE4res')(data)
        return data

    def unpack_IO_ADVISE_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.IO_ADVISE4_NORMAL, const.IO_ADVISE4_SEQUENTIAL, const.IO_ADVISE4_SEQUENTIAL_BACKWARDS, const.IO_ADVISE4_RANDOM, const.IO_ADVISE4_WILLNEED, const.IO_ADVISE4_WILLNEED_OPPORTUNISTIC, const.IO_ADVISE4_DONTNEED, const.IO_ADVISE4_NOREUSE, const.IO_ADVISE4_READ, const.IO_ADVISE4_WRITE, const.IO_ADVISE4_INIT_PROXIMITY]:
            raise XDRError('value=%s not in enum IO_ADVISE_type4' % data)
        if hasattr(self, 'filter_IO_ADVISE_type4'):
            data = getattr(self, 'filter_IO_ADVISE_type4')(data)
        return data

    def unpack_IO_ADVISE4args(self):
        data = types.IO_ADVISE4args()
        data.iaa_stateid = self.unpack_stateid4()
        data.iaa_offset = self.unpack_offset4()
        data.iaa_count = self.unpack_length4()
        data.iaa_hints = self.unpack_bitmap4()
        if hasattr(self, 'filter_IO_ADVISE4args'):
            data = getattr(self, 'filter_IO_ADVISE4args')(data)
        return data

    def unpack_IO_ADVISE4resok(self):
        data = types.IO_ADVISE4resok()
        data.ior_hints = self.unpack_bitmap4()
        if hasattr(self, 'filter_IO_ADVISE4resok'):
            data = getattr(self, 'filter_IO_ADVISE4resok')(data)
        return data

    def unpack_IO_ADVISE4res(self):
        data = types.IO_ADVISE4res()
        data.ior_status = self.unpack_nfsstat4()
        if data.ior_status == const.NFS4_OK:
            data.resok4 = self.unpack_IO_ADVISE4resok()
        else:
            pass
        if hasattr(self, 'filter_IO_ADVISE4res'):
            data = getattr(self, 'filter_IO_ADVISE4res')(data)
        return data

    def unpack_device_error4(self):
        data = types.device_error4()
        data.de_deviceid = self.unpack_deviceid4()
        data.de_status = self.unpack_nfsstat4()
        data.de_opnum = self.unpack_nfs_opnum4()
        if hasattr(self, 'filter_device_error4'):
            data = getattr(self, 'filter_device_error4')(data)
        return data

    def unpack_LAYOUTERROR4args(self):
        data = types.LAYOUTERROR4args()
        data.lea_offset = self.unpack_offset4()
        data.lea_length = self.unpack_length4()
        data.lea_stateid = self.unpack_stateid4()
        data.lea_errors = self.unpack_array(self.unpack_device_error4)
        if hasattr(self, 'filter_LAYOUTERROR4args'):
            data = getattr(self, 'filter_LAYOUTERROR4args')(data)
        return data

    def unpack_LAYOUTERROR4res(self):
        data = types.LAYOUTERROR4res()
        data.ler_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_LAYOUTERROR4res'):
            data = getattr(self, 'filter_LAYOUTERROR4res')(data)
        return data

    def unpack_io_info4(self):
        data = types.io_info4()
        data.ii_count = self.unpack_uint64_t()
        data.ii_bytes = self.unpack_uint64_t()
        if hasattr(self, 'filter_io_info4'):
            data = getattr(self, 'filter_io_info4')(data)
        return data

    def unpack_LAYOUTSTATS4args(self):
        data = types.LAYOUTSTATS4args()
        data.lsa_offset = self.unpack_offset4()
        data.lsa_length = self.unpack_length4()
        data.lsa_stateid = self.unpack_stateid4()
        data.lsa_read = self.unpack_io_info4()
        data.lsa_write = self.unpack_io_info4()
        data.lsa_deviceid = self.unpack_deviceid4()
        data.lsa_layoutupdate = self.unpack_layoutupdate4()
        if hasattr(self, 'filter_LAYOUTSTATS4args'):
            data = getattr(self, 'filter_LAYOUTSTATS4args')(data)
        return data

    def unpack_LAYOUTSTATS4res(self):
        data = types.LAYOUTSTATS4res()
        data.lsr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_LAYOUTSTATS4res'):
            data = getattr(self, 'filter_LAYOUTSTATS4res')(data)
        return data

    def unpack_READ_PLUS4args(self):
        data = types.READ_PLUS4args()
        data.rpa_stateid = self.unpack_stateid4()
        data.rpa_offset = self.unpack_offset4()
        data.rpa_count = self.unpack_count4()
        if hasattr(self, 'filter_READ_PLUS4args'):
            data = getattr(self, 'filter_READ_PLUS4args')(data)
        return data

    def unpack_read_plus_content(self):
        data = types.read_plus_content()
        data.rpc_content = self.unpack_data_content4()
        if data.rpc_content == const.NFS4_CONTENT_DATA:
            data.rpc_data = self.unpack_data4()
        elif data.rpc_content == const.NFS4_CONTENT_HOLE:
            data.rpc_hole = self.unpack_data_info4()
        else:
            pass
        if hasattr(self, 'filter_read_plus_content'):
            data = getattr(self, 'filter_read_plus_content')(data)
        return data

    def unpack_read_plus_res4(self):
        data = types.read_plus_res4()
        data.rpr_eof = self.unpack_bool()
        data.rpr_contents = self.unpack_array(self.unpack_read_plus_content)
        if hasattr(self, 'filter_read_plus_res4'):
            data = getattr(self, 'filter_read_plus_res4')(data)
        return data

    def unpack_READ_PLUS4res(self):
        data = types.READ_PLUS4res()
        data.rp_status = self.unpack_nfsstat4()
        if data.rp_status == const.NFS4_OK:
            data.rp_resok4 = self.unpack_read_plus_res4()
        else:
            pass
        if hasattr(self, 'filter_READ_PLUS4res'):
            data = getattr(self, 'filter_READ_PLUS4res')(data)
        return data

    def unpack_SEEK4args(self):
        data = types.SEEK4args()
        data.sa_stateid = self.unpack_stateid4()
        data.sa_offset = self.unpack_offset4()
        data.sa_what = self.unpack_data_content4()
        if hasattr(self, 'filter_SEEK4args'):
            data = getattr(self, 'filter_SEEK4args')(data)
        return data

    def unpack_seek_res4(self):
        data = types.seek_res4()
        data.sr_eof = self.unpack_bool()
        data.sr_offset = self.unpack_offset4()
        if hasattr(self, 'filter_seek_res4'):
            data = getattr(self, 'filter_seek_res4')(data)
        return data

    def unpack_SEEK4res(self):
        data = types.SEEK4res()
        data.sa_status = self.unpack_nfsstat4()
        if data.sa_status == const.NFS4_OK:
            data.resok4 = self.unpack_seek_res4()
        else:
            pass
        if hasattr(self, 'filter_SEEK4res'):
            data = getattr(self, 'filter_SEEK4res')(data)
        return data

    def unpack_WRITE_SAME4args(self):
        data = types.WRITE_SAME4args()
        data.wsa_stateid = self.unpack_stateid4()
        data.wsa_stable = self.unpack_stable_how4()
        data.wsa_adb = self.unpack_app_data_block4()
        if hasattr(self, 'filter_WRITE_SAME4args'):
            data = getattr(self, 'filter_WRITE_SAME4args')(data)
        return data

    def unpack_WRITE_SAME4res(self):
        data = types.WRITE_SAME4res()
        data.wsr_status = self.unpack_nfsstat4()
        if data.wsr_status == const.NFS4_OK:
            data.resok4 = self.unpack_write_response4()
        else:
            pass
        if hasattr(self, 'filter_WRITE_SAME4res'):
            data = getattr(self, 'filter_WRITE_SAME4res')(data)
        return data

    def unpack_ff_device_versions4(self):
        data = types.ff_device_versions4()
        data.ffdv_version = self.unpack_uint32_t()
        data.ffdv_minorversion = self.unpack_uint32_t()
        data.ffdv_rsize = self.unpack_uint32_t()
        data.ffdv_wsize = self.unpack_uint32_t()
        data.ffdv_tightly_coupled = self.unpack_bool()
        if hasattr(self, 'filter_ff_device_versions4'):
            data = getattr(self, 'filter_ff_device_versions4')(data)
        return data

    def unpack_ff_device_addr4(self):
        data = types.ff_device_addr4()
        data.ffda_netaddrs = self.unpack_multipath_list4()
        data.ffda_versions = self.unpack_array(self.unpack_ff_device_versions4)
        if hasattr(self, 'filter_ff_device_addr4'):
            data = getattr(self, 'filter_ff_device_addr4')(data)
        return data

    unpack_ff_flags4 = unpack_uint32_t

    def unpack_ff_data_server4(self):
        data = types.ff_data_server4()
        data.ffds_deviceid = self.unpack_deviceid4()
        data.ffds_efficiency = self.unpack_uint32_t()
        data.ffds_stateid = self.unpack_stateid4()
        data.ffds_fh_vers = self.unpack_array(self.unpack_nfs_fh4)
        data.ffds_user = self.unpack_fattr4_owner()
        data.ffds_group = self.unpack_fattr4_owner_group()
        if hasattr(self, 'filter_ff_data_server4'):
            data = getattr(self, 'filter_ff_data_server4')(data)
        return data

    def unpack_ff_mirror4(self):
        data = types.ff_mirror4()
        data.ffm_data_servers = self.unpack_array(self.unpack_ff_data_server4)
        if hasattr(self, 'filter_ff_mirror4'):
            data = getattr(self, 'filter_ff_mirror4')(data)
        return data

    def unpack_ff_layout4(self):
        data = types.ff_layout4()
        data.ffl_stripe_unit = self.unpack_length4()
        data.ffl_mirrors = self.unpack_array(self.unpack_ff_mirror4)
        data.ffl_flags = self.unpack_ff_flags4()
        data.ffl_stats_collect_hint = self.unpack_uint32_t()
        if hasattr(self, 'filter_ff_layout4'):
            data = getattr(self, 'filter_ff_layout4')(data)
        return data

    def unpack_ff_ioerr4(self):
        data = types.ff_ioerr4()
        data.ffie_offset = self.unpack_offset4()
        data.ffie_length = self.unpack_length4()
        data.ffie_stateid = self.unpack_stateid4()
        data.ffie_errors = self.unpack_array(self.unpack_device_error4)
        if hasattr(self, 'filter_ff_ioerr4'):
            data = getattr(self, 'filter_ff_ioerr4')(data)
        return data

    def unpack_ff_io_latency4(self):
        data = types.ff_io_latency4()
        data.ffil_ops_requested = self.unpack_uint64_t()
        data.ffil_bytes_requested = self.unpack_uint64_t()
        data.ffil_ops_completed = self.unpack_uint64_t()
        data.ffil_bytes_completed = self.unpack_uint64_t()
        data.ffil_bytes_not_delivered = self.unpack_uint64_t()
        data.ffil_total_busy_time = self.unpack_nfstime4()
        data.ffil_aggregate_completion_time = self.unpack_nfstime4()
        if hasattr(self, 'filter_ff_io_latency4'):
            data = getattr(self, 'filter_ff_io_latency4')(data)
        return data

    def unpack_ff_layoutupdate4(self):
        data = types.ff_layoutupdate4()
        data.ffl_addr = self.unpack_netaddr4()
        data.ffl_fhandle = self.unpack_nfs_fh4()
        data.ffl_read = self.unpack_ff_io_latency4()
        data.ffl_write = self.unpack_ff_io_latency4()
        data.ffl_duration = self.unpack_nfstime4()
        data.ffl_local = self.unpack_bool()
        if hasattr(self, 'filter_ff_layoutupdate4'):
            data = getattr(self, 'filter_ff_layoutupdate4')(data)
        return data

    def unpack_ff_iostats4(self):
        data = types.ff_iostats4()
        data.ffis_offset = self.unpack_offset4()
        data.ffis_length = self.unpack_length4()
        data.ffis_stateid = self.unpack_stateid4()
        data.ffis_read = self.unpack_io_info4()
        data.ffis_write = self.unpack_io_info4()
        data.ffis_deviceid = self.unpack_deviceid4()
        data.ffis_layoutupdate = self.unpack_ff_layoutupdate4()
        if hasattr(self, 'filter_ff_iostats4'):
            data = getattr(self, 'filter_ff_iostats4')(data)
        return data

    def unpack_ff_layoutreturn4(self):
        data = types.ff_layoutreturn4()
        data.fflr_ioerr_report = self.unpack_array(self.unpack_ff_ioerr4)
        data.fflr_iostats_report = self.unpack_array(self.unpack_ff_iostats4)
        if hasattr(self, 'filter_ff_layoutreturn4'):
            data = getattr(self, 'filter_ff_layoutreturn4')(data)
        return data

    def unpack_ff_mirrors_hint(self):
        data = types.ff_mirrors_hint()
        data.ffmc_valid = self.unpack_bool()
        if data.ffmc_valid == const.TRUE:
            data.ffmc_mirrors = self.unpack_uint32_t()
        elif data.ffmc_valid == const.FALSE:
            pass
        else:
            raise XDRError('bad switch=%s' % data.ffmc_valid)
        if hasattr(self, 'filter_ff_mirrors_hint'):
            data = getattr(self, 'filter_ff_mirrors_hint')(data)
        return data

    def unpack_ff_layouthint4(self):
        data = types.ff_layouthint4()
        data.fflh_mirrors_hint = self.unpack_ff_mirrors_hint()
        if hasattr(self, 'filter_ff_layouthint4'):
            data = getattr(self, 'filter_ff_layouthint4')(data)
        return data

    def unpack_ff_cb_recall_any_mask(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.FF_RCA4_TYPE_MASK_READ, const.FF_RCA4_TYPE_MASK_RW]:
            raise XDRError('value=%s not in enum ff_cb_recall_any_mask' % data)
        if hasattr(self, 'filter_ff_cb_recall_any_mask'):
            data = getattr(self, 'filter_ff_cb_recall_any_mask')(data)
        return data

    def unpack_GETXATTR4args(self):
        data = types.GETXATTR4args()
        data.gxa_name = self.unpack_xattrkey4()
        if hasattr(self, 'filter_GETXATTR4args'):
            data = getattr(self, 'filter_GETXATTR4args')(data)
        return data

    def unpack_GETXATTR4res(self):
        data = types.GETXATTR4res()
        data.gxr_status = self.unpack_nfsstat4()
        if data.gxr_status == const.NFS4_OK:
            data.gxr_value = self.unpack_xattrvalue4()
        else:
            pass
        if hasattr(self, 'filter_GETXATTR4res'):
            data = getattr(self, 'filter_GETXATTR4res')(data)
        return data

    def unpack_setxattr_option4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.SETXATTR4_EITHER, const.SETXATTR4_CREATE, const.SETXATTR4_REPLACE]:
            raise XDRError('value=%s not in enum setxattr_option4' % data)
        if hasattr(self, 'filter_setxattr_option4'):
            data = getattr(self, 'filter_setxattr_option4')(data)
        return data

    def unpack_SETXATTR4args(self):
        data = types.SETXATTR4args()
        data.sxa_option = self.unpack_setxattr_option4()
        data.sxa_key = self.unpack_xattrkey4()
        data.sxa_value = self.unpack_xattrvalue4()
        if hasattr(self, 'filter_SETXATTR4args'):
            data = getattr(self, 'filter_SETXATTR4args')(data)
        return data

    def unpack_SETXATTR4res(self):
        data = types.SETXATTR4res()
        data.sxr_status = self.unpack_nfsstat4()
        if data.sxr_status == const.NFS4_OK:
            data.sxr_info = self.unpack_change_info4()
        else:
            pass
        if hasattr(self, 'filter_SETXATTR4res'):
            data = getattr(self, 'filter_SETXATTR4res')(data)
        return data

    def unpack_LISTXATTRS4args(self):
        data = types.LISTXATTRS4args()
        data.lxa_cookie = self.unpack_nfs_cookie4()
        data.lxa_maxcount = self.unpack_count4()
        if hasattr(self, 'filter_LISTXATTRS4args'):
            data = getattr(self, 'filter_LISTXATTRS4args')(data)
        return data

    def unpack_LISTXATTRS4resok(self):
        data = types.LISTXATTRS4resok()
        data.lxr_cookie = self.unpack_nfs_cookie4()
        data.lxr_names = self.unpack_array(self.unpack_xattrkey4)
        data.lxr_eof = self.unpack_bool()
        if hasattr(self, 'filter_LISTXATTRS4resok'):
            data = getattr(self, 'filter_LISTXATTRS4resok')(data)
        return data

    def unpack_LISTXATTRS4res(self):
        data = types.LISTXATTRS4res()
        data.lxr_status = self.unpack_nfsstat4()
        if data.lxr_status == const.NFS4_OK:
            data.lxr_value = self.unpack_LISTXATTRS4resok()
        else:
            pass
        if hasattr(self, 'filter_LISTXATTRS4res'):
            data = getattr(self, 'filter_LISTXATTRS4res')(data)
        return data

    def unpack_REMOVEXATTR4args(self):
        data = types.REMOVEXATTR4args()
        data.rxa_name = self.unpack_xattrkey4()
        if hasattr(self, 'filter_REMOVEXATTR4args'):
            data = getattr(self, 'filter_REMOVEXATTR4args')(data)
        return data

    def unpack_REMOVEXATTR4res(self):
        data = types.REMOVEXATTR4res()
        data.rxr_status = self.unpack_nfsstat4()
        if data.rxr_status == const.NFS4_OK:
            data.rxr_info = self.unpack_change_info4()
        else:
            pass
        if hasattr(self, 'filter_REMOVEXATTR4res'):
            data = getattr(self, 'filter_REMOVEXATTR4res')(data)
        return data

    def unpack_nfs_argop4(self):
        data = types.nfs_argop4()
        data.argop = self.unpack_nfs_opnum4()
        if data.argop == const.OP_ACCESS:
            data.opaccess = self.unpack_ACCESS4args()
        elif data.argop == const.OP_CLOSE:
            data.opclose = self.unpack_CLOSE4args()
        elif data.argop == const.OP_COMMIT:
            data.opcommit = self.unpack_COMMIT4args()
        elif data.argop == const.OP_CREATE:
            data.opcreate = self.unpack_CREATE4args()
        elif data.argop == const.OP_DELEGPURGE:
            data.opdelegpurge = self.unpack_DELEGPURGE4args()
        elif data.argop == const.OP_DELEGRETURN:
            data.opdelegreturn = self.unpack_DELEGRETURN4args()
        elif data.argop == const.OP_GETATTR:
            data.opgetattr = self.unpack_GETATTR4args()
        elif data.argop == const.OP_GETFH:
            pass
        elif data.argop == const.OP_LINK:
            data.oplink = self.unpack_LINK4args()
        elif data.argop == const.OP_LOCK:
            data.oplock = self.unpack_LOCK4args()
        elif data.argop == const.OP_LOCKT:
            data.oplockt = self.unpack_LOCKT4args()
        elif data.argop == const.OP_LOCKU:
            data.oplocku = self.unpack_LOCKU4args()
        elif data.argop == const.OP_LOOKUP:
            data.oplookup = self.unpack_LOOKUP4args()
        elif data.argop == const.OP_LOOKUPP:
            pass
        elif data.argop == const.OP_NVERIFY:
            data.opnverify = self.unpack_NVERIFY4args()
        elif data.argop == const.OP_OPEN:
            data.opopen = self.unpack_OPEN4args()
        elif data.argop == const.OP_OPENATTR:
            data.opopenattr = self.unpack_OPENATTR4args()
        elif data.argop == const.OP_OPEN_CONFIRM:
            data.opopen_confirm = self.unpack_OPEN_CONFIRM4args()
        elif data.argop == const.OP_OPEN_DOWNGRADE:
            data.opopen_downgrade = self.unpack_OPEN_DOWNGRADE4args()
        elif data.argop == const.OP_PUTFH:
            data.opputfh = self.unpack_PUTFH4args()
        elif data.argop == const.OP_PUTPUBFH:
            pass
        elif data.argop == const.OP_PUTROOTFH:
            pass
        elif data.argop == const.OP_READ:
            data.opread = self.unpack_READ4args()
        elif data.argop == const.OP_READDIR:
            data.opreaddir = self.unpack_READDIR4args()
        elif data.argop == const.OP_READLINK:
            pass
        elif data.argop == const.OP_REMOVE:
            data.opremove = self.unpack_REMOVE4args()
        elif data.argop == const.OP_RENAME:
            data.oprename = self.unpack_RENAME4args()
        elif data.argop == const.OP_RENEW:
            data.oprenew = self.unpack_RENEW4args()
        elif data.argop == const.OP_RESTOREFH:
            pass
        elif data.argop == const.OP_SAVEFH:
            pass
        elif data.argop == const.OP_SECINFO:
            data.opsecinfo = self.unpack_SECINFO4args()
        elif data.argop == const.OP_SETATTR:
            data.opsetattr = self.unpack_SETATTR4args()
        elif data.argop == const.OP_SETCLIENTID:
            data.opsetclientid = self.unpack_SETCLIENTID4args()
        elif data.argop == const.OP_SETCLIENTID_CONFIRM:
            data.opsetclientid_confirm = self.unpack_SETCLIENTID_CONFIRM4args()
        elif data.argop == const.OP_VERIFY:
            data.opverify = self.unpack_VERIFY4args()
        elif data.argop == const.OP_WRITE:
            data.opwrite = self.unpack_WRITE4args()
        elif data.argop == const.OP_RELEASE_LOCKOWNER:
            data.oprelease_lockowner = self.unpack_RELEASE_LOCKOWNER4args()
        elif data.argop == const.OP_BACKCHANNEL_CTL:
            data.opbackchannel_ctl = self.unpack_BACKCHANNEL_CTL4args()
        elif data.argop == const.OP_BIND_CONN_TO_SESSION:
            data.opbind_conn_to_session = self.unpack_BIND_CONN_TO_SESSION4args()
        elif data.argop == const.OP_EXCHANGE_ID:
            data.opexchange_id = self.unpack_EXCHANGE_ID4args()
        elif data.argop == const.OP_CREATE_SESSION:
            data.opcreate_session = self.unpack_CREATE_SESSION4args()
        elif data.argop == const.OP_DESTROY_SESSION:
            data.opdestroy_session = self.unpack_DESTROY_SESSION4args()
        elif data.argop == const.OP_FREE_STATEID:
            data.opfree_stateid = self.unpack_FREE_STATEID4args()
        elif data.argop == const.OP_GET_DIR_DELEGATION:
            data.opget_dir_delegation = self.unpack_GET_DIR_DELEGATION4args()
        elif data.argop == const.OP_GETDEVICEINFO:
            data.opgetdeviceinfo = self.unpack_GETDEVICEINFO4args()
        elif data.argop == const.OP_GETDEVICELIST:
            data.opgetdevicelist = self.unpack_GETDEVICELIST4args()
        elif data.argop == const.OP_LAYOUTCOMMIT:
            data.oplayoutcommit = self.unpack_LAYOUTCOMMIT4args()
        elif data.argop == const.OP_LAYOUTGET:
            data.oplayoutget = self.unpack_LAYOUTGET4args()
        elif data.argop == const.OP_LAYOUTRETURN:
            data.oplayoutreturn = self.unpack_LAYOUTRETURN4args()
        elif data.argop == const.OP_SECINFO_NO_NAME:
            data.opsecinfo_no_name = self.unpack_SECINFO_NO_NAME4args()
        elif data.argop == const.OP_SEQUENCE:
            data.opsequence = self.unpack_SEQUENCE4args()
        elif data.argop == const.OP_SET_SSV:
            data.opset_ssv = self.unpack_SET_SSV4args()
        elif data.argop == const.OP_TEST_STATEID:
            data.optest_stateid = self.unpack_TEST_STATEID4args()
        elif data.argop == const.OP_WANT_DELEGATION:
            data.opwant_delegation = self.unpack_WANT_DELEGATION4args()
        elif data.argop == const.OP_DESTROY_CLIENTID:
            data.opdestroy_clientid = self.unpack_DESTROY_CLIENTID4args()
        elif data.argop == const.OP_RECLAIM_COMPLETE:
            data.opreclaim_complete = self.unpack_RECLAIM_COMPLETE4args()
        elif data.argop == const.OP_ALLOCATE:
            data.opallocate = self.unpack_ALLOCATE4args()
        elif data.argop == const.OP_COPY:
            data.opcopy = self.unpack_COPY4args()
        elif data.argop == const.OP_COPY_NOTIFY:
            data.opoffload_notify = self.unpack_COPY_NOTIFY4args()
        elif data.argop == const.OP_DEALLOCATE:
            data.opdeallocate = self.unpack_DEALLOCATE4args()
        elif data.argop == const.OP_IO_ADVISE:
            data.opio_advise = self.unpack_IO_ADVISE4args()
        elif data.argop == const.OP_LAYOUTERROR:
            data.oplayouterror = self.unpack_LAYOUTERROR4args()
        elif data.argop == const.OP_LAYOUTSTATS:
            data.oplayoutstats = self.unpack_LAYOUTSTATS4args()
        elif data.argop == const.OP_OFFLOAD_CANCEL:
            data.opoffload_cancel = self.unpack_OFFLOAD_CANCEL4args()
        elif data.argop == const.OP_OFFLOAD_STATUS:
            data.opoffload_status = self.unpack_OFFLOAD_STATUS4args()
        elif data.argop == const.OP_READ_PLUS:
            data.opread_plus = self.unpack_READ_PLUS4args()
        elif data.argop == const.OP_SEEK:
            data.opseek = self.unpack_SEEK4args()
        elif data.argop == const.OP_WRITE_SAME:
            data.opwrite_same = self.unpack_WRITE_SAME4args()
        elif data.argop == const.OP_CLONE:
            data.opclone = self.unpack_CLONE4args()
        elif data.argop == const.OP_GETXATTR:
            data.opgetxattr = self.unpack_GETXATTR4args()
        elif data.argop == const.OP_SETXATTR:
            data.opsetxattr = self.unpack_SETXATTR4args()
        elif data.argop == const.OP_LISTXATTRS:
            data.oplistxattrs = self.unpack_LISTXATTRS4args()
        elif data.argop == const.OP_REMOVEXATTR:
            data.opremovexattr = self.unpack_REMOVEXATTR4args()
        elif data.argop == const.OP_ILLEGAL:
            pass
        else:
            raise XDRError('bad switch=%s' % data.argop)
        if hasattr(self, 'filter_nfs_argop4'):
            data = getattr(self, 'filter_nfs_argop4')(data)
        return data

    def unpack_nfs_resop4(self):
        data = types.nfs_resop4()
        data.resop = self.unpack_nfs_opnum4()
        if data.resop == const.OP_ACCESS:
            data.opaccess = self.unpack_ACCESS4res()
        elif data.resop == const.OP_CLOSE:
            data.opclose = self.unpack_CLOSE4res()
        elif data.resop == const.OP_COMMIT:
            data.opcommit = self.unpack_COMMIT4res()
        elif data.resop == const.OP_CREATE:
            data.opcreate = self.unpack_CREATE4res()
        elif data.resop == const.OP_DELEGPURGE:
            data.opdelegpurge = self.unpack_DELEGPURGE4res()
        elif data.resop == const.OP_DELEGRETURN:
            data.opdelegreturn = self.unpack_DELEGRETURN4res()
        elif data.resop == const.OP_GETATTR:
            data.opgetattr = self.unpack_GETATTR4res()
        elif data.resop == const.OP_GETFH:
            data.opgetfh = self.unpack_GETFH4res()
        elif data.resop == const.OP_LINK:
            data.oplink = self.unpack_LINK4res()
        elif data.resop == const.OP_LOCK:
            data.oplock = self.unpack_LOCK4res()
        elif data.resop == const.OP_LOCKT:
            data.oplockt = self.unpack_LOCKT4res()
        elif data.resop == const.OP_LOCKU:
            data.oplocku = self.unpack_LOCKU4res()
        elif data.resop == const.OP_LOOKUP:
            data.oplookup = self.unpack_LOOKUP4res()
        elif data.resop == const.OP_LOOKUPP:
            data.oplookupp = self.unpack_LOOKUPP4res()
        elif data.resop == const.OP_NVERIFY:
            data.opnverify = self.unpack_NVERIFY4res()
        elif data.resop == const.OP_OPEN:
            data.opopen = self.unpack_OPEN4res()
        elif data.resop == const.OP_OPENATTR:
            data.opopenattr = self.unpack_OPENATTR4res()
        elif data.resop == const.OP_OPEN_CONFIRM:
            data.opopen_confirm = self.unpack_OPEN_CONFIRM4res()
        elif data.resop == const.OP_OPEN_DOWNGRADE:
            data.opopen_downgrade = self.unpack_OPEN_DOWNGRADE4res()
        elif data.resop == const.OP_PUTFH:
            data.opputfh = self.unpack_PUTFH4res()
        elif data.resop == const.OP_PUTPUBFH:
            data.opputpubfh = self.unpack_PUTPUBFH4res()
        elif data.resop == const.OP_PUTROOTFH:
            data.opputrootfh = self.unpack_PUTROOTFH4res()
        elif data.resop == const.OP_READ:
            data.opread = self.unpack_READ4res()
        elif data.resop == const.OP_READDIR:
            data.opreaddir = self.unpack_READDIR4res()
        elif data.resop == const.OP_READLINK:
            data.opreadlink = self.unpack_READLINK4res()
        elif data.resop == const.OP_REMOVE:
            data.opremove = self.unpack_REMOVE4res()
        elif data.resop == const.OP_RENAME:
            data.oprename = self.unpack_RENAME4res()
        elif data.resop == const.OP_RENEW:
            data.oprenew = self.unpack_RENEW4res()
        elif data.resop == const.OP_RESTOREFH:
            data.oprestorefh = self.unpack_RESTOREFH4res()
        elif data.resop == const.OP_SAVEFH:
            data.opsavefh = self.unpack_SAVEFH4res()
        elif data.resop == const.OP_SECINFO:
            data.opsecinfo = self.unpack_SECINFO4res()
        elif data.resop == const.OP_SETATTR:
            data.opsetattr = self.unpack_SETATTR4res()
        elif data.resop == const.OP_SETCLIENTID:
            data.opsetclientid = self.unpack_SETCLIENTID4res()
        elif data.resop == const.OP_SETCLIENTID_CONFIRM:
            data.opsetclientid_confirm = self.unpack_SETCLIENTID_CONFIRM4res()
        elif data.resop == const.OP_VERIFY:
            data.opverify = self.unpack_VERIFY4res()
        elif data.resop == const.OP_WRITE:
            data.opwrite = self.unpack_WRITE4res()
        elif data.resop == const.OP_RELEASE_LOCKOWNER:
            data.oprelease_lockowner = self.unpack_RELEASE_LOCKOWNER4res()
        elif data.resop == const.OP_BACKCHANNEL_CTL:
            data.opbackchannel_ctl = self.unpack_BACKCHANNEL_CTL4res()
        elif data.resop == const.OP_BIND_CONN_TO_SESSION:
            data.opbind_conn_to_session = self.unpack_BIND_CONN_TO_SESSION4res()
        elif data.resop == const.OP_EXCHANGE_ID:
            data.opexchange_id = self.unpack_EXCHANGE_ID4res()
        elif data.resop == const.OP_CREATE_SESSION:
            data.opcreate_session = self.unpack_CREATE_SESSION4res()
        elif data.resop == const.OP_DESTROY_SESSION:
            data.opdestroy_session = self.unpack_DESTROY_SESSION4res()
        elif data.resop == const.OP_FREE_STATEID:
            data.opfree_stateid = self.unpack_FREE_STATEID4res()
        elif data.resop == const.OP_GET_DIR_DELEGATION:
            data.opget_dir_delegation = self.unpack_GET_DIR_DELEGATION4res()
        elif data.resop == const.OP_GETDEVICEINFO:
            data.opgetdeviceinfo = self.unpack_GETDEVICEINFO4res()
        elif data.resop == const.OP_GETDEVICELIST:
            data.opgetdevicelist = self.unpack_GETDEVICELIST4res()
        elif data.resop == const.OP_LAYOUTCOMMIT:
            data.oplayoutcommit = self.unpack_LAYOUTCOMMIT4res()
        elif data.resop == const.OP_LAYOUTGET:
            data.oplayoutget = self.unpack_LAYOUTGET4res()
        elif data.resop == const.OP_LAYOUTRETURN:
            data.oplayoutreturn = self.unpack_LAYOUTRETURN4res()
        elif data.resop == const.OP_SECINFO_NO_NAME:
            data.opsecinfo_no_name = self.unpack_SECINFO_NO_NAME4res()
        elif data.resop == const.OP_SEQUENCE:
            data.opsequence = self.unpack_SEQUENCE4res()
        elif data.resop == const.OP_SET_SSV:
            data.opset_ssv = self.unpack_SET_SSV4res()
        elif data.resop == const.OP_TEST_STATEID:
            data.optest_stateid = self.unpack_TEST_STATEID4res()
        elif data.resop == const.OP_WANT_DELEGATION:
            data.opwant_delegation = self.unpack_WANT_DELEGATION4res()
        elif data.resop == const.OP_DESTROY_CLIENTID:
            data.opdestroy_clientid = self.unpack_DESTROY_CLIENTID4res()
        elif data.resop == const.OP_RECLAIM_COMPLETE:
            data.opreclaim_complete = self.unpack_RECLAIM_COMPLETE4res()
        elif data.resop == const.OP_ALLOCATE:
            data.opallocate = self.unpack_ALLOCATE4res()
        elif data.resop == const.OP_COPY:
            data.opcopy = self.unpack_COPY4res()
        elif data.resop == const.OP_COPY_NOTIFY:
            data.opcopy_notify = self.unpack_COPY_NOTIFY4res()
        elif data.resop == const.OP_DEALLOCATE:
            data.opdeallocate = self.unpack_DEALLOCATE4res()
        elif data.resop == const.OP_IO_ADVISE:
            data.opio_advise = self.unpack_IO_ADVISE4res()
        elif data.resop == const.OP_LAYOUTERROR:
            data.oplayouterror = self.unpack_LAYOUTERROR4res()
        elif data.resop == const.OP_LAYOUTSTATS:
            data.oplayputstats = self.unpack_LAYOUTSTATS4res()
        elif data.resop == const.OP_OFFLOAD_CANCEL:
            data.opoffload_cancel = self.unpack_OFFLOAD_CANCEL4res()
        elif data.resop == const.OP_OFFLOAD_STATUS:
            data.opoffload_status = self.unpack_OFFLOAD_STATUS4res()
        elif data.resop == const.OP_READ_PLUS:
            data.opread_plus = self.unpack_READ_PLUS4res()
        elif data.resop == const.OP_SEEK:
            data.opseek = self.unpack_SEEK4res()
        elif data.resop == const.OP_WRITE_SAME:
            data.opwrite_same = self.unpack_WRITE_SAME4res()
        elif data.resop == const.OP_CLONE:
            data.opclone = self.unpack_CLONE4res()
        elif data.resop == const.OP_GETXATTR:
            data.opgetxattr = self.unpack_GETXATTR4res()
        elif data.resop == const.OP_SETXATTR:
            data.opsetxattr = self.unpack_SETXATTR4res()
        elif data.resop == const.OP_LISTXATTRS:
            data.oplistxattrs = self.unpack_LISTXATTRS4res()
        elif data.resop == const.OP_REMOVEXATTR:
            data.opremovexattr = self.unpack_REMOVEXATTR4res()
        elif data.resop == const.OP_ILLEGAL:
            data.opillegal = self.unpack_ILLEGAL4res()
        else:
            raise XDRError('bad switch=%s' % data.resop)
        if hasattr(self, 'filter_nfs_resop4'):
            data = getattr(self, 'filter_nfs_resop4')(data)
        return data

    def unpack_COMPOUND4args(self):
        data = types.COMPOUND4args()
        data.tag = self.unpack_utf8str_cs()
        data.minorversion = self.unpack_uint32_t()
        data.argarray = self.unpack_array(self.unpack_nfs_argop4)
        if hasattr(self, 'filter_COMPOUND4args'):
            data = getattr(self, 'filter_COMPOUND4args')(data)
        return data

    def unpack_COMPOUND4res(self):
        data = types.COMPOUND4res()
        data.status = self.unpack_nfsstat4()
        data.tag = self.unpack_utf8str_cs()
        data.resarray = self.unpack_array(self.unpack_nfs_resop4)
        if hasattr(self, 'filter_COMPOUND4res'):
            data = getattr(self, 'filter_COMPOUND4res')(data)
        return data

    def unpack_CB_GETATTR4args(self):
        data = types.CB_GETATTR4args()
        data.fh = self.unpack_nfs_fh4()
        data.attr_request = self.unpack_bitmap4()
        if hasattr(self, 'filter_CB_GETATTR4args'):
            data = getattr(self, 'filter_CB_GETATTR4args')(data)
        return data

    def unpack_CB_GETATTR4resok(self):
        data = types.CB_GETATTR4resok()
        data.obj_attributes = self.unpack_fattr4()
        if hasattr(self, 'filter_CB_GETATTR4resok'):
            data = getattr(self, 'filter_CB_GETATTR4resok')(data)
        return data

    def unpack_CB_GETATTR4res(self):
        data = types.CB_GETATTR4res()
        data.status = self.unpack_nfsstat4()
        if data.status == const.NFS4_OK:
            data.resok4 = self.unpack_CB_GETATTR4resok()
        else:
            pass
        if hasattr(self, 'filter_CB_GETATTR4res'):
            data = getattr(self, 'filter_CB_GETATTR4res')(data)
        return data

    def unpack_CB_RECALL4args(self):
        data = types.CB_RECALL4args()
        data.stateid = self.unpack_stateid4()
        data.truncate = self.unpack_bool()
        data.fh = self.unpack_nfs_fh4()
        if hasattr(self, 'filter_CB_RECALL4args'):
            data = getattr(self, 'filter_CB_RECALL4args')(data)
        return data

    def unpack_CB_RECALL4res(self):
        data = types.CB_RECALL4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_RECALL4res'):
            data = getattr(self, 'filter_CB_RECALL4res')(data)
        return data

    def unpack_CB_ILLEGAL4res(self):
        data = types.CB_ILLEGAL4res()
        data.status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_ILLEGAL4res'):
            data = getattr(self, 'filter_CB_ILLEGAL4res')(data)
        return data

    def unpack_layoutrecall_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.LAYOUTRECALL4_FILE, const.LAYOUTRECALL4_FSID, const.LAYOUTRECALL4_ALL]:
            raise XDRError('value=%s not in enum layoutrecall_type4' % data)
        if hasattr(self, 'filter_layoutrecall_type4'):
            data = getattr(self, 'filter_layoutrecall_type4')(data)
        return data

    def unpack_layoutrecall_file4(self):
        data = types.layoutrecall_file4()
        data.lor_fh = self.unpack_nfs_fh4()
        data.lor_offset = self.unpack_offset4()
        data.lor_length = self.unpack_length4()
        data.lor_stateid = self.unpack_stateid4()
        if hasattr(self, 'filter_layoutrecall_file4'):
            data = getattr(self, 'filter_layoutrecall_file4')(data)
        return data

    def unpack_layoutrecall4(self):
        data = types.layoutrecall4()
        data.lor_recalltype = self.unpack_layoutrecall_type4()
        if data.lor_recalltype == const.LAYOUTRECALL4_FILE:
            data.lor_layout = self.unpack_layoutrecall_file4()
        elif data.lor_recalltype == const.LAYOUTRECALL4_FSID:
            data.lor_fsid = self.unpack_fsid4()
        elif data.lor_recalltype == const.LAYOUTRECALL4_ALL:
            pass
        else:
            raise XDRError('bad switch=%s' % data.lor_recalltype)
        if hasattr(self, 'filter_layoutrecall4'):
            data = getattr(self, 'filter_layoutrecall4')(data)
        return data

    def unpack_CB_LAYOUTRECALL4args(self):
        data = types.CB_LAYOUTRECALL4args()
        data.clora_type = self.unpack_layouttype4()
        data.clora_iomode = self.unpack_layoutiomode4()
        data.clora_changed = self.unpack_bool()
        data.clora_recall = self.unpack_layoutrecall4()
        if hasattr(self, 'filter_CB_LAYOUTRECALL4args'):
            data = getattr(self, 'filter_CB_LAYOUTRECALL4args')(data)
        return data

    def unpack_CB_LAYOUTRECALL4res(self):
        data = types.CB_LAYOUTRECALL4res()
        data.clorr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_LAYOUTRECALL4res'):
            data = getattr(self, 'filter_CB_LAYOUTRECALL4res')(data)
        return data

    def unpack_notify_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NOTIFY4_CHANGE_CHILD_ATTRS, const.NOTIFY4_CHANGE_DIR_ATTRS, const.NOTIFY4_REMOVE_ENTRY, const.NOTIFY4_ADD_ENTRY, const.NOTIFY4_RENAME_ENTRY, const.NOTIFY4_CHANGE_COOKIE_VERIFIER]:
            raise XDRError('value=%s not in enum notify_type4' % data)
        if hasattr(self, 'filter_notify_type4'):
            data = getattr(self, 'filter_notify_type4')(data)
        return data

    def unpack_notify_entry4(self):
        data = types.notify_entry4()
        data.ne_file = self.unpack_component4()
        data.ne_attrs = self.unpack_fattr4()
        if hasattr(self, 'filter_notify_entry4'):
            data = getattr(self, 'filter_notify_entry4')(data)
        return data

    def unpack_prev_entry4(self):
        data = types.prev_entry4()
        data.pe_prev_entry = self.unpack_notify_entry4()
        data.pe_prev_entry_cookie = self.unpack_nfs_cookie4()
        if hasattr(self, 'filter_prev_entry4'):
            data = getattr(self, 'filter_prev_entry4')(data)
        return data

    def unpack_notify_remove4(self):
        data = types.notify_remove4()
        data.nrm_old_entry = self.unpack_notify_entry4()
        data.nrm_old_entry_cookie = self.unpack_nfs_cookie4()
        if hasattr(self, 'filter_notify_remove4'):
            data = getattr(self, 'filter_notify_remove4')(data)
        return data

    def unpack_notify_add4(self):
        data = types.notify_add4()
        data.nad_old_entry = self.unpack_array(self.unpack_notify_remove4)
        if len(data.nad_old_entry) > 1 and self.check_array:
            raise XDRError('array length too long for data.nad_old_entry')
        data.nad_new_entry = self.unpack_notify_entry4()
        data.nad_new_entry_cookie = self.unpack_array(self.unpack_nfs_cookie4)
        if len(data.nad_new_entry_cookie) > 1 and self.check_array:
            raise XDRError('array length too long for data.nad_new_entry_cookie')
        data.nad_prev_entry = self.unpack_array(self.unpack_prev_entry4)
        if len(data.nad_prev_entry) > 1 and self.check_array:
            raise XDRError('array length too long for data.nad_prev_entry')
        data.nad_last_entry = self.unpack_bool()
        if hasattr(self, 'filter_notify_add4'):
            data = getattr(self, 'filter_notify_add4')(data)
        return data

    def unpack_notify_attr4(self):
        data = types.notify_attr4()
        data.na_changed_entry = self.unpack_notify_entry4()
        if hasattr(self, 'filter_notify_attr4'):
            data = getattr(self, 'filter_notify_attr4')(data)
        return data

    def unpack_notify_rename4(self):
        data = types.notify_rename4()
        data.nrn_old_entry = self.unpack_notify_remove4()
        data.nrn_new_entry = self.unpack_notify_add4()
        if hasattr(self, 'filter_notify_rename4'):
            data = getattr(self, 'filter_notify_rename4')(data)
        return data

    def unpack_notify_verifier4(self):
        data = types.notify_verifier4()
        data.nv_old_cookieverf = self.unpack_verifier4()
        data.nv_new_cookieverf = self.unpack_verifier4()
        if hasattr(self, 'filter_notify_verifier4'):
            data = getattr(self, 'filter_notify_verifier4')(data)
        return data

    def unpack_notifylist4(self):
        data = self.unpack_opaque()
        if hasattr(self, 'filter_notifylist4'):
            data = getattr(self, 'filter_notifylist4')(data)
        return data

    def unpack_notify4(self):
        data = types.notify4()
        data.notify_mask = self.unpack_bitmap4()
        data.notify_vals = self.unpack_notifylist4()
        if hasattr(self, 'filter_notify4'):
            data = getattr(self, 'filter_notify4')(data)
        return data

    def unpack_CB_NOTIFY4args(self):
        data = types.CB_NOTIFY4args()
        data.cna_stateid = self.unpack_stateid4()
        data.cna_fh = self.unpack_nfs_fh4()
        data.cna_changes = self.unpack_array(self.unpack_notify4)
        if hasattr(self, 'filter_CB_NOTIFY4args'):
            data = getattr(self, 'filter_CB_NOTIFY4args')(data)
        return data

    def unpack_CB_NOTIFY4res(self):
        data = types.CB_NOTIFY4res()
        data.cnr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_NOTIFY4res'):
            data = getattr(self, 'filter_CB_NOTIFY4res')(data)
        return data

    def unpack_CB_PUSH_DELEG4args(self):
        data = types.CB_PUSH_DELEG4args()
        data.cpda_fh = self.unpack_nfs_fh4()
        data.cpda_delegation = self.unpack_open_delegation4()
        if hasattr(self, 'filter_CB_PUSH_DELEG4args'):
            data = getattr(self, 'filter_CB_PUSH_DELEG4args')(data)
        return data

    def unpack_CB_PUSH_DELEG4res(self):
        data = types.CB_PUSH_DELEG4res()
        data.cpdr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_PUSH_DELEG4res'):
            data = getattr(self, 'filter_CB_PUSH_DELEG4res')(data)
        return data

    def unpack_CB_RECALL_ANY4args(self):
        data = types.CB_RECALL_ANY4args()
        data.craa_objects_to_keep = self.unpack_uint32_t()
        data.craa_type_mask = self.unpack_bitmap4()
        if hasattr(self, 'filter_CB_RECALL_ANY4args'):
            data = getattr(self, 'filter_CB_RECALL_ANY4args')(data)
        return data

    def unpack_CB_RECALL_ANY4res(self):
        data = types.CB_RECALL_ANY4res()
        data.crar_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_RECALL_ANY4res'):
            data = getattr(self, 'filter_CB_RECALL_ANY4res')(data)
        return data

    unpack_CB_RECALLABLE_OBJ_AVAIL4args = unpack_CB_RECALL_ANY4args

    def unpack_CB_RECALLABLE_OBJ_AVAIL4res(self):
        data = types.CB_RECALLABLE_OBJ_AVAIL4res()
        data.croa_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_RECALLABLE_OBJ_AVAIL4res'):
            data = getattr(self, 'filter_CB_RECALLABLE_OBJ_AVAIL4res')(data)
        return data

    def unpack_CB_RECALL_SLOT4args(self):
        data = types.CB_RECALL_SLOT4args()
        data.rsa_target_highest_slotid = self.unpack_slotid4()
        if hasattr(self, 'filter_CB_RECALL_SLOT4args'):
            data = getattr(self, 'filter_CB_RECALL_SLOT4args')(data)
        return data

    def unpack_CB_RECALL_SLOT4res(self):
        data = types.CB_RECALL_SLOT4res()
        data.rsr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_RECALL_SLOT4res'):
            data = getattr(self, 'filter_CB_RECALL_SLOT4res')(data)
        return data

    def unpack_referring_call4(self):
        data = types.referring_call4()
        data.rc_sequenceid = self.unpack_sequenceid4()
        data.rc_slotid = self.unpack_slotid4()
        if hasattr(self, 'filter_referring_call4'):
            data = getattr(self, 'filter_referring_call4')(data)
        return data

    def unpack_referring_call_list4(self):
        data = types.referring_call_list4()
        data.rcl_sessionid = self.unpack_sessionid4()
        data.rcl_referring_calls = self.unpack_array(self.unpack_referring_call4)
        if hasattr(self, 'filter_referring_call_list4'):
            data = getattr(self, 'filter_referring_call_list4')(data)
        return data

    def unpack_CB_SEQUENCE4args(self):
        data = types.CB_SEQUENCE4args()
        data.csa_sessionid = self.unpack_sessionid4()
        data.csa_sequenceid = self.unpack_sequenceid4()
        data.csa_slotid = self.unpack_slotid4()
        data.csa_highest_slotid = self.unpack_slotid4()
        data.csa_cachethis = self.unpack_bool()
        data.csa_referring_call_lists = self.unpack_array(self.unpack_referring_call_list4)
        if hasattr(self, 'filter_CB_SEQUENCE4args'):
            data = getattr(self, 'filter_CB_SEQUENCE4args')(data)
        return data

    def unpack_CB_SEQUENCE4resok(self):
        data = types.CB_SEQUENCE4resok()
        data.csr_sessionid = self.unpack_sessionid4()
        data.csr_sequenceid = self.unpack_sequenceid4()
        data.csr_slotid = self.unpack_slotid4()
        data.csr_highest_slotid = self.unpack_slotid4()
        data.csr_target_highest_slotid = self.unpack_slotid4()
        if hasattr(self, 'filter_CB_SEQUENCE4resok'):
            data = getattr(self, 'filter_CB_SEQUENCE4resok')(data)
        return data

    def unpack_CB_SEQUENCE4res(self):
        data = types.CB_SEQUENCE4res()
        data.csr_status = self.unpack_nfsstat4()
        if data.csr_status == const.NFS4_OK:
            data.csr_resok4 = self.unpack_CB_SEQUENCE4resok()
        else:
            pass
        if hasattr(self, 'filter_CB_SEQUENCE4res'):
            data = getattr(self, 'filter_CB_SEQUENCE4res')(data)
        return data

    def unpack_CB_WANTS_CANCELLED4args(self):
        data = types.CB_WANTS_CANCELLED4args()
        data.cwca_contended_wants_cancelled = self.unpack_bool()
        data.cwca_resourced_wants_cancelled = self.unpack_bool()
        if hasattr(self, 'filter_CB_WANTS_CANCELLED4args'):
            data = getattr(self, 'filter_CB_WANTS_CANCELLED4args')(data)
        return data

    def unpack_CB_WANTS_CANCELLED4res(self):
        data = types.CB_WANTS_CANCELLED4res()
        data.cwcr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_WANTS_CANCELLED4res'):
            data = getattr(self, 'filter_CB_WANTS_CANCELLED4res')(data)
        return data

    def unpack_CB_NOTIFY_LOCK4args(self):
        data = types.CB_NOTIFY_LOCK4args()
        data.cnla_fh = self.unpack_nfs_fh4()
        data.cnla_lock_owner = self.unpack_lock_owner4()
        if hasattr(self, 'filter_CB_NOTIFY_LOCK4args'):
            data = getattr(self, 'filter_CB_NOTIFY_LOCK4args')(data)
        return data

    def unpack_CB_NOTIFY_LOCK4res(self):
        data = types.CB_NOTIFY_LOCK4res()
        data.cnlr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_NOTIFY_LOCK4res'):
            data = getattr(self, 'filter_CB_NOTIFY_LOCK4res')(data)
        return data

    def unpack_notify_deviceid_type4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.NOTIFY_DEVICEID4_CHANGE, const.NOTIFY_DEVICEID4_DELETE]:
            raise XDRError('value=%s not in enum notify_deviceid_type4' % data)
        if hasattr(self, 'filter_notify_deviceid_type4'):
            data = getattr(self, 'filter_notify_deviceid_type4')(data)
        return data

    def unpack_notify_deviceid_delete4(self):
        data = types.notify_deviceid_delete4()
        data.ndd_layouttype = self.unpack_layouttype4()
        data.ndd_deviceid = self.unpack_deviceid4()
        if hasattr(self, 'filter_notify_deviceid_delete4'):
            data = getattr(self, 'filter_notify_deviceid_delete4')(data)
        return data

    def unpack_notify_deviceid_change4(self):
        data = types.notify_deviceid_change4()
        data.ndc_layouttype = self.unpack_layouttype4()
        data.ndc_deviceid = self.unpack_deviceid4()
        data.ndc_immediate = self.unpack_bool()
        if hasattr(self, 'filter_notify_deviceid_change4'):
            data = getattr(self, 'filter_notify_deviceid_change4')(data)
        return data

    def unpack_CB_NOTIFY_DEVICEID4args(self):
        data = types.CB_NOTIFY_DEVICEID4args()
        data.cnda_changes = self.unpack_array(self.unpack_notify4)
        if hasattr(self, 'filter_CB_NOTIFY_DEVICEID4args'):
            data = getattr(self, 'filter_CB_NOTIFY_DEVICEID4args')(data)
        return data

    def unpack_CB_NOTIFY_DEVICEID4res(self):
        data = types.CB_NOTIFY_DEVICEID4res()
        data.cndr_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_NOTIFY_DEVICEID4res'):
            data = getattr(self, 'filter_CB_NOTIFY_DEVICEID4res')(data)
        return data

    def unpack_offload_info4(self):
        data = types.offload_info4()
        data.coa_status = self.unpack_nfsstat4()
        if data.coa_status == const.NFS4_OK:
            data.coa_resok4 = self.unpack_write_response4()
        else:
            data.coa_bytes_copied = self.unpack_length4()
        if hasattr(self, 'filter_offload_info4'):
            data = getattr(self, 'filter_offload_info4')(data)
        return data

    def unpack_CB_OFFLOAD4args(self):
        data = types.CB_OFFLOAD4args()
        data.coa_fh = self.unpack_nfs_fh4()
        data.coa_stateid = self.unpack_stateid4()
        data.coa_offload_info = self.unpack_offload_info4()
        if hasattr(self, 'filter_CB_OFFLOAD4args'):
            data = getattr(self, 'filter_CB_OFFLOAD4args')(data)
        return data

    def unpack_CB_OFFLOAD4res(self):
        data = types.CB_OFFLOAD4res()
        data.cor_status = self.unpack_nfsstat4()
        if hasattr(self, 'filter_CB_OFFLOAD4res'):
            data = getattr(self, 'filter_CB_OFFLOAD4res')(data)
        return data

    def unpack_nfs_cb_opnum4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OP_CB_GETATTR, const.OP_CB_RECALL, const.OP_CB_LAYOUTRECALL, const.OP_CB_NOTIFY, const.OP_CB_PUSH_DELEG, const.OP_CB_RECALL_ANY, const.OP_CB_RECALLABLE_OBJ_AVAIL, const.OP_CB_RECALL_SLOT, const.OP_CB_SEQUENCE, const.OP_CB_WANTS_CANCELLED, const.OP_CB_NOTIFY_LOCK, const.OP_CB_NOTIFY_DEVICEID, const.OP_CB_OFFLOAD, const.OP_CB_ILLEGAL]:
            raise XDRError('value=%s not in enum nfs_cb_opnum4' % data)
        if hasattr(self, 'filter_nfs_cb_opnum4'):
            data = getattr(self, 'filter_nfs_cb_opnum4')(data)
        return data

    def unpack_nfs_cb_argop4(self):
        data = types.nfs_cb_argop4()
        data.argop = self.unpack_unsigned()
        if data.argop == const.OP_CB_GETATTR:
            data.opcbgetattr = self.unpack_CB_GETATTR4args()
        elif data.argop == const.OP_CB_RECALL:
            data.opcbrecall = self.unpack_CB_RECALL4args()
        elif data.argop == const.OP_CB_LAYOUTRECALL:
            data.opcblayoutrecall = self.unpack_CB_LAYOUTRECALL4args()
        elif data.argop == const.OP_CB_NOTIFY:
            data.opcbnotify = self.unpack_CB_NOTIFY4args()
        elif data.argop == const.OP_CB_PUSH_DELEG:
            data.opcbpush_deleg = self.unpack_CB_PUSH_DELEG4args()
        elif data.argop == const.OP_CB_RECALL_ANY:
            data.opcbrecall_any = self.unpack_CB_RECALL_ANY4args()
        elif data.argop == const.OP_CB_RECALLABLE_OBJ_AVAIL:
            data.opcbrecallable_obj_avail = self.unpack_CB_RECALLABLE_OBJ_AVAIL4args()
        elif data.argop == const.OP_CB_RECALL_SLOT:
            data.opcbrecall_slot = self.unpack_CB_RECALL_SLOT4args()
        elif data.argop == const.OP_CB_SEQUENCE:
            data.opcbsequence = self.unpack_CB_SEQUENCE4args()
        elif data.argop == const.OP_CB_WANTS_CANCELLED:
            data.opcbwants_cancelled = self.unpack_CB_WANTS_CANCELLED4args()
        elif data.argop == const.OP_CB_NOTIFY_LOCK:
            data.opcbnotify_lock = self.unpack_CB_NOTIFY_LOCK4args()
        elif data.argop == const.OP_CB_NOTIFY_DEVICEID:
            data.opcbnotify_deviceid = self.unpack_CB_NOTIFY_DEVICEID4args()
        elif data.argop == const.OP_CB_OFFLOAD:
            data.opcboffload = self.unpack_CB_OFFLOAD4args()
        elif data.argop == const.OP_CB_ILLEGAL:
            pass
        else:
            raise XDRError('bad switch=%s' % data.argop)
        if hasattr(self, 'filter_nfs_cb_argop4'):
            data = getattr(self, 'filter_nfs_cb_argop4')(data)
        return data

    def unpack_nfs_cb_resop4(self):
        data = types.nfs_cb_resop4()
        data.resop = self.unpack_unsigned()
        if data.resop == const.OP_CB_GETATTR:
            data.opcbgetattr = self.unpack_CB_GETATTR4res()
        elif data.resop == const.OP_CB_RECALL:
            data.opcbrecall = self.unpack_CB_RECALL4res()
        elif data.resop == const.OP_CB_LAYOUTRECALL:
            data.opcblayoutrecall = self.unpack_CB_LAYOUTRECALL4res()
        elif data.resop == const.OP_CB_NOTIFY:
            data.opcbnotify = self.unpack_CB_NOTIFY4res()
        elif data.resop == const.OP_CB_PUSH_DELEG:
            data.opcbpush_deleg = self.unpack_CB_PUSH_DELEG4res()
        elif data.resop == const.OP_CB_RECALL_ANY:
            data.opcbrecall_any = self.unpack_CB_RECALL_ANY4res()
        elif data.resop == const.OP_CB_RECALLABLE_OBJ_AVAIL:
            data.opcbrecallable_obj_avail = self.unpack_CB_RECALLABLE_OBJ_AVAIL4res()
        elif data.resop == const.OP_CB_RECALL_SLOT:
            data.opcbrecall_slot = self.unpack_CB_RECALL_SLOT4res()
        elif data.resop == const.OP_CB_SEQUENCE:
            data.opcbsequence = self.unpack_CB_SEQUENCE4res()
        elif data.resop == const.OP_CB_WANTS_CANCELLED:
            data.opcbwants_cancelled = self.unpack_CB_WANTS_CANCELLED4res()
        elif data.resop == const.OP_CB_NOTIFY_LOCK:
            data.opcbnotify_lock = self.unpack_CB_NOTIFY_LOCK4res()
        elif data.resop == const.OP_CB_NOTIFY_DEVICEID:
            data.opcbnotify_deviceid = self.unpack_CB_NOTIFY_DEVICEID4res()
        elif data.resop == const.OP_CB_OFFLOAD:
            data.opcboffload = self.unpack_CB_OFFLOAD4res()
        elif data.resop == const.OP_CB_ILLEGAL:
            data.opcbillegal = self.unpack_CB_ILLEGAL4res()
        else:
            raise XDRError('bad switch=%s' % data.resop)
        if hasattr(self, 'filter_nfs_cb_resop4'):
            data = getattr(self, 'filter_nfs_cb_resop4')(data)
        return data

    def unpack_CB_COMPOUND4args(self):
        data = types.CB_COMPOUND4args()
        data.tag = self.unpack_utf8str_cs()
        data.minorversion = self.unpack_uint32_t()
        data.callback_ident = self.unpack_uint32_t()
        data.argarray = self.unpack_array(self.unpack_nfs_cb_argop4)
        if hasattr(self, 'filter_CB_COMPOUND4args'):
            data = getattr(self, 'filter_CB_COMPOUND4args')(data)
        return data

    def unpack_CB_COMPOUND4res(self):
        data = types.CB_COMPOUND4res()
        data.status = self.unpack_nfsstat4()
        data.tag = self.unpack_utf8str_cs()
        data.resarray = self.unpack_array(self.unpack_nfs_cb_resop4)
        if hasattr(self, 'filter_CB_COMPOUND4res'):
            data = getattr(self, 'filter_CB_COMPOUND4res')(data)
        return data

    unpack_fattr4_offline = unpack_bool

    def unpack_open_arguments4(self):
        data = types.open_arguments4()
        data.oa_share_access = self.unpack_bitmap4()
        data.oa_share_deny = self.unpack_bitmap4()
        data.oa_share_access_want = self.unpack_bitmap4()
        data.oa_open_claim = self.unpack_bitmap4()
        data.oa_create_mode = self.unpack_bitmap4()
        if hasattr(self, 'filter_open_arguments4'):
            data = getattr(self, 'filter_open_arguments4')(data)
        return data

    def unpack_open_args_share_access4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OPEN_ARGS_SHARE_ACCESS_READ, const.OPEN_ARGS_SHARE_ACCESS_WRITE, const.OPEN_ARGS_SHARE_ACCESS_BOTH]:
            raise XDRError('value=%s not in enum open_args_share_access4' % data)
        if hasattr(self, 'filter_open_args_share_access4'):
            data = getattr(self, 'filter_open_args_share_access4')(data)
        return data

    def unpack_open_args_share_deny4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OPEN_ARGS_SHARE_DENY_NONE, const.OPEN_ARGS_SHARE_DENY_READ, const.OPEN_ARGS_SHARE_DENY_WRITE, const.OPEN_ARGS_SHARE_DENY_BOTH]:
            raise XDRError('value=%s not in enum open_args_share_deny4' % data)
        if hasattr(self, 'filter_open_args_share_deny4'):
            data = getattr(self, 'filter_open_args_share_deny4')(data)
        return data

    def unpack_open_args_share_access_want4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OPEN_ARGS_SHARE_ACCESS_WANT_ANY_DELEG, const.OPEN_ARGS_SHARE_ACCESS_WANT_NO_DELEG, const.OPEN_ARGS_SHARE_ACCESS_WANT_CANCEL, const.OPEN_ARGS_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL, const.OPEN_ARGS_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED, const.OPEN_ARGS_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS, const.OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION]:
            raise XDRError('value=%s not in enum open_args_share_access_want4' % data)
        if hasattr(self, 'filter_open_args_share_access_want4'):
            data = getattr(self, 'filter_open_args_share_access_want4')(data)
        return data

    def unpack_open_args_open_claim4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OPEN_ARGS_OPEN_CLAIM_NULL, const.OPEN_ARGS_OPEN_CLAIM_PREVIOUS, const.OPEN_ARGS_OPEN_CLAIM_DELEGATE_CUR, const.OPEN_ARGS_OPEN_CLAIM_DELEGATE_PREV, const.OPEN_ARGS_OPEN_CLAIM_FH, const.OPEN_ARGS_OPEN_CLAIM_DELEG_CUR_FH, const.OPEN_ARGS_OPEN_CLAIM_DELEG_PREV_FH]:
            raise XDRError('value=%s not in enum open_args_open_claim4' % data)
        if hasattr(self, 'filter_open_args_open_claim4'):
            data = getattr(self, 'filter_open_args_open_claim4')(data)
        return data

    def unpack_open_args_createmode4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OPEN_ARGS_CREATEMODE_UNCHECKED4, const.OPEN_ARGS_CREATE_MODE_GUARDED, const.OPEN_ARGS_CREATEMODE_EXCLUSIVE4, const.OPEN_ARGS_CREATE_MODE_EXCLUSIVE4_1]:
            raise XDRError('value=%s not in enum open_args_createmode4' % data)
        if hasattr(self, 'filter_open_args_createmode4'):
            data = getattr(self, 'filter_open_args_createmode4')(data)
        return data

    unpack_fattr4_open_arguments = unpack_open_arguments4

    unpack_fattr4_time_deleg_access = unpack_nfstime4

    unpack_fattr4_time_deleg_modify = unpack_nfstime4

